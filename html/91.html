
            <!DOCTYPE html>
            <html lang="zh-CN">
                <head>
                    <meta charset="UTF-8">
                    <title>
 FFmpeg源代码简单分析：avformat_find_stream_info() - CSDN博客
</title>

                <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-60a2c245da.min.css">
                <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-88717cedf2.min.css">

                <script type="text/javascript">
                var username = "";
                </script>

                <script src="https://csdnimg.cn/public/common/libs/jquery/jquery-1.9.1.min.js" type="text/javascript"></script>

                <!-- 新版上报 -->
                <!-- 新版上报end -->
                <link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.3/css/sandalstrap.min.css"> 
                </head>
                <body>    
        
                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
                    <div class="container clearfix pt0" id="mainBox">
        <main style="width: 100%;"><div class="blog-content-box">
 <div class="article-title-box" id="article_anchors_91">
  <span class="article-type type-1 float-left">
   原
  </span>
  <h1 class="title-article">
   FFmpeg源代码简单分析：avformat_find_stream_info()
  </h1>
 </div>
 <div class="article-info-box">
  <div class="article-bar-top d-flex">
   <span class="time">
    2015年03月06日 11:15:37
   </span>
   <div ">
    <span class="read-count">
     阅读数：35964
    </span>
   </div>
  </div>
 </div>
 <article>
  <div class="article_content clearfix csdn-tracking-statistics" data-dsm="post" data-mod="popu_307" data-pid="blog" id="article_content">
   <link href="https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css" rel="stylesheet"/>
   <div class="htmledit_views">
    <p>
    </p>
    <p align="left">
     =====================================================
    </p>
    <p align="left">
     FFmpeg的库函数源代码分析文章列表：
    </p>
    <p align="left">
     【架构图】
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44220151">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码结构图 -
      </span>
      <span style="color:#0000FF;">
       解码
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44226355">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码结构图 -
      </span>
      <span style="color:#0000FF;">
       编码
      </span>
     </a>
    </p>
    <p align="left">
     【通用】
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/12677129">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       av_register_all()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/12677265">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avcodec_register_all()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/41176777">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：内存的分配和释放（
      </span>
      <span style="color:#0000FF;">
       av_malloc()
      </span>
      <span style="color:#0000FF;">
       、
      </span>
      <span style="color:#0000FF;">
       av_free()
      </span>
      <span style="color:#0000FF;">
       等）
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/41181155">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：常见结构体的初始化和销毁（
      </span>
      <span style="color:#0000FF;">
       AVFormatContext
      </span>
      <span style="color:#0000FF;">
       ，
      </span>
      <span style="color:#0000FF;">
       AVFrame
      </span>
      <span style="color:#0000FF;">
       等）
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/41199947">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avio_open2()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44084557">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       av_find_decoder()
      </span>
      <span style="color:#0000FF;">
       和
      </span>
      <span style="color:#0000FF;">
       av_find_encoder()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44117891">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avcodec_open2()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44206699">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avcodec_close()
      </span>
     </a>
    </p>
    <p align="left">
     【解码】
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/8661601">
      <span style="color:#0000FF;">
       图解
      </span>
      <span style="color:#0000FF;">
       FFMPEG
      </span>
      <span style="color:#0000FF;">
       打开媒体的函数
      </span>
      <span style="color:#0000FF;">
       avformat_open_input
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44064715">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avformat_open_input()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44084321">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avformat_find_stream_info()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/12678577">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       av_read_frame()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/12679719">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avcodec_decode_video2()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44110683">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avformat_close_input()
      </span>
     </a>
    </p>
    <p align="left">
     【编码】
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/41198929">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avformat_alloc_output_context2()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44116215">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avformat_write_header()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44206485">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avcodec_encode_video()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44199673">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       av_write_frame()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44201645">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       av_write_trailer()
      </span>
     </a>
    </p>
    <p align="left">
     【其它】
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44243155">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：日志输出系统（
      </span>
      <span style="color:#0000FF;">
       av_log()
      </span>
      <span style="color:#0000FF;">
       等）
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44268323">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：结构体成员管理系统
      </span>
      <span style="color:#0000FF;">
       -AVClass
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44279329">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：结构体成员管理系统
      </span>
      <span style="color:#0000FF;">
       -AVOption
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44305697">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       libswscale
      </span>
      <span style="color:#0000FF;">
       的
      </span>
      <span style="color:#0000FF;">
       sws_getContext()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44346687">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       libswscale
      </span>
      <span style="color:#0000FF;">
       的
      </span>
      <span style="color:#0000FF;">
       sws_scale()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/41211121">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       libavdevice
      </span>
      <span style="color:#0000FF;">
       的
      </span>
      <span style="color:#0000FF;">
       avdevice_register_all()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44597955">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       libavdevice
      </span>
      <span style="color:#0000FF;">
       的
      </span>
      <span style="color:#0000FF;">
       gdigrab
      </span>
     </a>
    </p>
    <p align="left">
     【脚本】
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44556525">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       makefile
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44587465">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       configure
      </span>
     </a>
    </p>
    <p align="left">
     【H.264】
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44864509">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       的
      </span>
      <span style="color:#0000FF;">
       H.264
      </span>
      <span style="color:#0000FF;">
       解码器源代码简单分析：概述
      </span>
     </a>
    </p>
    <p align="left">
     =====================================================
    </p>
    <br/>
    <p>
     本文简单分析FFmpeg中一个常用的函数：avformat_find_stream_info()。该函数可以读取一部分视音频数据并且获得一些相关的信息。avformat_find_stream_info()的声明位于libavformat\avformat.h，如下所示。
    </p>
    <pre class="cpp">/**
 * Read packets of a media file to get stream information. This
 * is useful for file formats with no headers such as MPEG. This
 * function also computes the real framerate in case of MPEG-2 repeat
 * frame mode.
 * The logical file position is not changed by this function;
 * examined packets may be buffered for later processing.
 *
 * @param ic media file handle
 * @param options  If non-NULL, an ic.nb_streams long array of pointers to
 *                 dictionaries, where i-th member contains options for
 *                 codec corresponding to i-th stream.
 *                 On return each dictionary will be filled with options that were not found.
 * @return &gt;=0 if OK, AVERROR_xxx on error
 *
 * @note this function isn't guaranteed to open all the codecs, so
 *       options being non-empty at return is a perfectly normal behavior.
 *
 * @todo Let the user decide somehow what information is needed so that
 *       we do not waste time getting stuff the user does not need.
 */
int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options);</pre>
    <br/>
    简单解释一下它的参数的含义：
    <br/>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
     ic：输入的AVFormatContext。
     <br/>
     options：额外的选项，目前没有深入研究过。
    </blockquote>
    函数正常执行后返回值大于等于0。
    <br/>
    该函数最典型的例子可以参考：
    <a href="http://blog.csdn.net/leixiaohua1020/article/details/38868499">
     最简单的基于FFMPEG+SDL的视频播放器 ver2 （采用SDL2.0）
    </a>
    <br/>
    <br/>
    <p>
     PS：由于该函数比较复杂，所以只看了一部分代码，以后有时间再进一步分析。
    </p>
    <h2>
     函数调用关系图
    </h2>
    函数的调用关系如下图所示。
    <br/>
    <div style="text-align:center;">
     <img alt="" src="https://img-blog.csdn.net/20150306173746865"/>
     <br/>
    </div>
    <div style="text-align:center;">
     <br/>
    </div>
    <h2>
     avformat_find_stream_info()
    </h2>
    avformat_find_stream_info()的定义位于libavformat\utils.c。它的代码比较长，如下所示。
    <br/>
    <pre class="cpp">int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
{
    int i, count, ret = 0, j;
    int64_t read_size;
    AVStream *st;
    AVPacket pkt1, *pkt;
    int64_t old_offset  = avio_tell(ic-&gt;pb);
    // new streams might appear, no options for those
    int orig_nb_streams = ic-&gt;nb_streams;
    int flush_codecs;
    int64_t max_analyze_duration = ic-&gt;max_analyze_duration2;
    int64_t probesize = ic-&gt;probesize2;


    if (!max_analyze_duration)
        max_analyze_duration = ic-&gt;max_analyze_duration;
    if (ic-&gt;probesize)
        probesize = ic-&gt;probesize;
    flush_codecs = probesize &gt; 0;


    av_opt_set(ic, "skip_clear", "1", AV_OPT_SEARCH_CHILDREN);


    if (!max_analyze_duration) {
        if (!strcmp(ic-&gt;iformat-&gt;name, "flv") &amp;&amp; !(ic-&gt;ctx_flags &amp; AVFMTCTX_NOHEADER)) {
            max_analyze_duration = 10*AV_TIME_BASE;
        } else
            max_analyze_duration = 5*AV_TIME_BASE;
    }


    if (ic-&gt;pb)
        av_log(ic, AV_LOG_DEBUG, "Before avformat_find_stream_info() pos: %"PRId64" bytes read:%"PRId64" seeks:%d\n",
               avio_tell(ic-&gt;pb), ic-&gt;pb-&gt;bytes_read, ic-&gt;pb-&gt;seek_count);


    for (i = 0; i &lt; ic-&gt;nb_streams; i++) {
        const AVCodec *codec;
        AVDictionary *thread_opt = NULL;
        st = ic-&gt;streams[i];


        if (st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO ||
            st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) {
/*            if (!st-&gt;time_base.num)
                st-&gt;time_base = */
            if (!st-&gt;codec-&gt;time_base.num)
                st-&gt;codec-&gt;time_base = st-&gt;time_base;
        }
        // only for the split stuff
        if (!st-&gt;parser &amp;&amp; !(ic-&gt;flags &amp; AVFMT_FLAG_NOPARSE)) {
            st-&gt;parser = av_parser_init(st-&gt;codec-&gt;codec_id);
            if (st-&gt;parser) {
                if (st-&gt;need_parsing == AVSTREAM_PARSE_HEADERS) {
                    st-&gt;parser-&gt;flags |= PARSER_FLAG_COMPLETE_FRAMES;
                } else if (st-&gt;need_parsing == AVSTREAM_PARSE_FULL_RAW) {
                    st-&gt;parser-&gt;flags |= PARSER_FLAG_USE_CODEC_TS;
                }
            } else if (st-&gt;need_parsing) {
                av_log(ic, AV_LOG_VERBOSE, "parser not found for codec "
                       "%s, packets or times may be invalid.\n",
                       avcodec_get_name(st-&gt;codec-&gt;codec_id));
            }
        }
        codec = find_decoder(ic, st, st-&gt;codec-&gt;codec_id);


        /* Force thread count to 1 since the H.264 decoder will not extract
         * SPS and PPS to extradata during multi-threaded decoding. */
        av_dict_set(options ? &amp;options[i] : &amp;thread_opt, "threads", "1", 0);


        if (ic-&gt;codec_whitelist)
            av_dict_set(options ? &amp;options[i] : &amp;thread_opt, "codec_whitelist", ic-&gt;codec_whitelist, 0);


        /* Ensure that subtitle_header is properly set. */
        if (st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE
            &amp;&amp; codec &amp;&amp; !st-&gt;codec-&gt;codec) {
            if (avcodec_open2(st-&gt;codec, codec, options ? &amp;options[i] : &amp;thread_opt) &lt; 0)
                av_log(ic, AV_LOG_WARNING,
                       "Failed to open codec in av_find_stream_info\n");
        }


        // Try to just open decoders, in case this is enough to get parameters.
        if (!has_codec_parameters(st, NULL) &amp;&amp; st-&gt;request_probe &lt;= 0) {
            if (codec &amp;&amp; !st-&gt;codec-&gt;codec)
                if (avcodec_open2(st-&gt;codec, codec, options ? &amp;options[i] : &amp;thread_opt) &lt; 0)
                    av_log(ic, AV_LOG_WARNING,
                           "Failed to open codec in av_find_stream_info\n");
        }
        if (!options)
            av_dict_free(&amp;thread_opt);
    }


    for (i = 0; i &lt; ic-&gt;nb_streams; i++) {
#if FF_API_R_FRAME_RATE
        ic-&gt;streams[i]-&gt;info-&gt;last_dts = AV_NOPTS_VALUE;
#endif
        ic-&gt;streams[i]-&gt;info-&gt;fps_first_dts = AV_NOPTS_VALUE;
        ic-&gt;streams[i]-&gt;info-&gt;fps_last_dts  = AV_NOPTS_VALUE;
    }


    count     = 0;
    read_size = 0;
    for (;;) {
        if (ff_check_interrupt(&amp;ic-&gt;interrupt_callback)) {
            ret = AVERROR_EXIT;
            av_log(ic, AV_LOG_DEBUG, "interrupted\n");
            break;
        }


        /* check if one codec still needs to be handled */
        for (i = 0; i &lt; ic-&gt;nb_streams; i++) {
            int fps_analyze_framecount = 20;


            st = ic-&gt;streams[i];
            if (!has_codec_parameters(st, NULL))
                break;
            /* If the timebase is coarse (like the usual millisecond precision
             * of mkv), we need to analyze more frames to reliably arrive at
             * the correct fps. */
            if (av_q2d(st-&gt;time_base) &gt; 0.0005)
                fps_analyze_framecount *= 2;
            if (!tb_unreliable(st-&gt;codec))
                fps_analyze_framecount = 0;
            if (ic-&gt;fps_probe_size &gt;= 0)
                fps_analyze_framecount = ic-&gt;fps_probe_size;
            if (st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC)
                fps_analyze_framecount = 0;
            /* variable fps and no guess at the real fps */
            if (!(st-&gt;r_frame_rate.num &amp;&amp; st-&gt;avg_frame_rate.num) &amp;&amp;
                st-&gt;info-&gt;duration_count &lt; fps_analyze_framecount &amp;&amp;
                st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO)
                break;
            if (st-&gt;parser &amp;&amp; st-&gt;parser-&gt;parser-&gt;split &amp;&amp;
                !st-&gt;codec-&gt;extradata)
                break;
            if (st-&gt;first_dts == AV_NOPTS_VALUE &amp;&amp;
                !(ic-&gt;iformat-&gt;flags &amp; AVFMT_NOTIMESTAMPS) &amp;&amp;
                st-&gt;codec_info_nb_frames &lt; ic-&gt;max_ts_probe &amp;&amp;
                (st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO ||
                 st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO))
                break;
        }
        if (i == ic-&gt;nb_streams) {
            /* NOTE: If the format has no header, then we need to read some
             * packets to get most of the streams, so we cannot stop here. */
            if (!(ic-&gt;ctx_flags &amp; AVFMTCTX_NOHEADER)) {
                /* If we found the info for all the codecs, we can stop. */
                ret = count;
                av_log(ic, AV_LOG_DEBUG, "All info found\n");
                flush_codecs = 0;
                break;
            }
        }
        /* We did not get all the codec info, but we read too much data. */
        if (read_size &gt;= probesize) {
            ret = count;
            av_log(ic, AV_LOG_DEBUG,
                   "Probe buffer size limit of %"PRId64" bytes reached\n", probesize);
            for (i = 0; i &lt; ic-&gt;nb_streams; i++)
                if (!ic-&gt;streams[i]-&gt;r_frame_rate.num &amp;&amp;
                    ic-&gt;streams[i]-&gt;info-&gt;duration_count &lt;= 1 &amp;&amp;
                    ic-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO &amp;&amp;
                    strcmp(ic-&gt;iformat-&gt;name, "image2"))
                    av_log(ic, AV_LOG_WARNING,
                           "Stream #%d: not enough frames to estimate rate; "
                           "consider increasing probesize\n", i);
            break;
        }


        /* NOTE: A new stream can be added there if no header in file
         * (AVFMTCTX_NOHEADER). */
        ret = read_frame_internal(ic, &amp;pkt1);
        if (ret == AVERROR(EAGAIN))
            continue;


        if (ret &lt; 0) {
            /* EOF or error*/
            break;
        }


        if (ic-&gt;flags &amp; AVFMT_FLAG_NOBUFFER)
            free_packet_buffer(&amp;ic-&gt;packet_buffer, &amp;ic-&gt;packet_buffer_end);
        {
            pkt = add_to_pktbuf(&amp;ic-&gt;packet_buffer, &amp;pkt1,
                                &amp;ic-&gt;packet_buffer_end);
            if (!pkt) {
                ret = AVERROR(ENOMEM);
                goto find_stream_info_err;
            }
            if ((ret = av_dup_packet(pkt)) &lt; 0)
                goto find_stream_info_err;
        }


        st = ic-&gt;streams[pkt-&gt;stream_index];
        if (!(st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC))
            read_size += pkt-&gt;size;


        if (pkt-&gt;dts != AV_NOPTS_VALUE &amp;&amp; st-&gt;codec_info_nb_frames &gt; 1) {
            /* check for non-increasing dts */
            if (st-&gt;info-&gt;fps_last_dts != AV_NOPTS_VALUE &amp;&amp;
                st-&gt;info-&gt;fps_last_dts &gt;= pkt-&gt;dts) {
                av_log(ic, AV_LOG_DEBUG,
                       "Non-increasing DTS in stream %d: packet %d with DTS "
                       "%"PRId64", packet %d with DTS %"PRId64"\n",
                       st-&gt;index, st-&gt;info-&gt;fps_last_dts_idx,
                       st-&gt;info-&gt;fps_last_dts, st-&gt;codec_info_nb_frames,
                       pkt-&gt;dts);
                st-&gt;info-&gt;fps_first_dts =
                st-&gt;info-&gt;fps_last_dts  = AV_NOPTS_VALUE;
            }
            /* Check for a discontinuity in dts. If the difference in dts
             * is more than 1000 times the average packet duration in the
             * sequence, we treat it as a discontinuity. */
            if (st-&gt;info-&gt;fps_last_dts != AV_NOPTS_VALUE &amp;&amp;
                st-&gt;info-&gt;fps_last_dts_idx &gt; st-&gt;info-&gt;fps_first_dts_idx &amp;&amp;
                (pkt-&gt;dts - st-&gt;info-&gt;fps_last_dts) / 1000 &gt;
                (st-&gt;info-&gt;fps_last_dts     - st-&gt;info-&gt;fps_first_dts) /
                (st-&gt;info-&gt;fps_last_dts_idx - st-&gt;info-&gt;fps_first_dts_idx)) {
                av_log(ic, AV_LOG_WARNING,
                       "DTS discontinuity in stream %d: packet %d with DTS "
                       "%"PRId64", packet %d with DTS %"PRId64"\n",
                       st-&gt;index, st-&gt;info-&gt;fps_last_dts_idx,
                       st-&gt;info-&gt;fps_last_dts, st-&gt;codec_info_nb_frames,
                       pkt-&gt;dts);
                st-&gt;info-&gt;fps_first_dts =
                st-&gt;info-&gt;fps_last_dts  = AV_NOPTS_VALUE;
            }


            /* update stored dts values */
            if (st-&gt;info-&gt;fps_first_dts == AV_NOPTS_VALUE) {
                st-&gt;info-&gt;fps_first_dts     = pkt-&gt;dts;
                st-&gt;info-&gt;fps_first_dts_idx = st-&gt;codec_info_nb_frames;
            }
            st-&gt;info-&gt;fps_last_dts     = pkt-&gt;dts;
            st-&gt;info-&gt;fps_last_dts_idx = st-&gt;codec_info_nb_frames;
        }
        if (st-&gt;codec_info_nb_frames&gt;1) {
            int64_t t = 0;


            if (st-&gt;time_base.den &gt; 0)
                t = av_rescale_q(st-&gt;info-&gt;codec_info_duration, st-&gt;time_base, AV_TIME_BASE_Q);
            if (st-&gt;avg_frame_rate.num &gt; 0)
                t = FFMAX(t, av_rescale_q(st-&gt;codec_info_nb_frames, av_inv_q(st-&gt;avg_frame_rate), AV_TIME_BASE_Q));


            if (   t == 0
                &amp;&amp; st-&gt;codec_info_nb_frames&gt;30
                &amp;&amp; st-&gt;info-&gt;fps_first_dts != AV_NOPTS_VALUE
                &amp;&amp; st-&gt;info-&gt;fps_last_dts  != AV_NOPTS_VALUE)
                t = FFMAX(t, av_rescale_q(st-&gt;info-&gt;fps_last_dts - st-&gt;info-&gt;fps_first_dts, st-&gt;time_base, AV_TIME_BASE_Q));


            if (t &gt;= max_analyze_duration) {
                av_log(ic, AV_LOG_VERBOSE, "max_analyze_duration %"PRId64" reached at %"PRId64" microseconds\n",
                       max_analyze_duration,
                       t);
                if (ic-&gt;flags &amp; AVFMT_FLAG_NOBUFFER)
                    av_packet_unref(pkt);
                break;
            }
            if (pkt-&gt;duration) {
                st-&gt;info-&gt;codec_info_duration        += pkt-&gt;duration;
                st-&gt;info-&gt;codec_info_duration_fields += st-&gt;parser &amp;&amp; st-&gt;need_parsing &amp;&amp; st-&gt;codec-&gt;ticks_per_frame ==2 ? st-&gt;parser-&gt;repeat_pict + 1 : 2;
            }
        }
#if FF_API_R_FRAME_RATE
        if (st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO)
            ff_rfps_add_frame(ic, st, pkt-&gt;dts);
#endif
        if (st-&gt;parser &amp;&amp; st-&gt;parser-&gt;parser-&gt;split &amp;&amp; !st-&gt;codec-&gt;extradata) {
            int i = st-&gt;parser-&gt;parser-&gt;split(st-&gt;codec, pkt-&gt;data, pkt-&gt;size);
            if (i &gt; 0 &amp;&amp; i &lt; FF_MAX_EXTRADATA_SIZE) {
                if (ff_alloc_extradata(st-&gt;codec, i))
                    return AVERROR(ENOMEM);
                memcpy(st-&gt;codec-&gt;extradata, pkt-&gt;data,
                       st-&gt;codec-&gt;extradata_size);
            }
        }


        /* If still no information, we try to open the codec and to
         * decompress the frame. We try to avoid that in most cases as
         * it takes longer and uses more memory. For MPEG-4, we need to
         * decompress for QuickTime.
         *
         * If CODEC_CAP_CHANNEL_CONF is set this will force decoding of at
         * least one frame of codec data, this makes sure the codec initializes
         * the channel configuration and does not only trust the values from
         * the container. */
        try_decode_frame(ic, st, pkt,
                         (options &amp;&amp; i &lt; orig_nb_streams) ? &amp;options[i] : NULL);


        if (ic-&gt;flags &amp; AVFMT_FLAG_NOBUFFER)
            av_packet_unref(pkt);


        st-&gt;codec_info_nb_frames++;
        count++;
    }


    if (flush_codecs) {
        AVPacket empty_pkt = { 0 };
        int err = 0;
        av_init_packet(&amp;empty_pkt);


        for (i = 0; i &lt; ic-&gt;nb_streams; i++) {


            st = ic-&gt;streams[i];


            /* flush the decoders */
            if (st-&gt;info-&gt;found_decoder == 1) {
                do {
                    err = try_decode_frame(ic, st, &amp;empty_pkt,
                                            (options &amp;&amp; i &lt; orig_nb_streams)
                                            ? &amp;options[i] : NULL);
                } while (err &gt; 0 &amp;&amp; !has_codec_parameters(st, NULL));


                if (err &lt; 0) {
                    av_log(ic, AV_LOG_INFO,
                        "decoding for stream %d failed\n", st-&gt;index);
                }
            }
        }
    }


    // close codecs which were opened in try_decode_frame()
    for (i = 0; i &lt; ic-&gt;nb_streams; i++) {
        st = ic-&gt;streams[i];
        avcodec_close(st-&gt;codec);
    }


    ff_rfps_calculate(ic);


    for (i = 0; i &lt; ic-&gt;nb_streams; i++) {
        st = ic-&gt;streams[i];
        if (st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO) {
            if (st-&gt;codec-&gt;codec_id == AV_CODEC_ID_RAWVIDEO &amp;&amp; !st-&gt;codec-&gt;codec_tag &amp;&amp; !st-&gt;codec-&gt;bits_per_coded_sample) {
                uint32_t tag= avcodec_pix_fmt_to_codec_tag(st-&gt;codec-&gt;pix_fmt);
                if (avpriv_find_pix_fmt(avpriv_get_raw_pix_fmt_tags(), tag) == st-&gt;codec-&gt;pix_fmt)
                    st-&gt;codec-&gt;codec_tag= tag;
            }


            /* estimate average framerate if not set by demuxer */
            if (st-&gt;info-&gt;codec_info_duration_fields &amp;&amp;
                !st-&gt;avg_frame_rate.num &amp;&amp;
                st-&gt;info-&gt;codec_info_duration) {
                int best_fps      = 0;
                double best_error = 0.01;


                if (st-&gt;info-&gt;codec_info_duration        &gt;= INT64_MAX / st-&gt;time_base.num / 2||
                    st-&gt;info-&gt;codec_info_duration_fields &gt;= INT64_MAX / st-&gt;time_base.den ||
                    st-&gt;info-&gt;codec_info_duration        &lt; 0)
                    continue;
                av_reduce(&amp;st-&gt;avg_frame_rate.num, &amp;st-&gt;avg_frame_rate.den,
                          st-&gt;info-&gt;codec_info_duration_fields * (int64_t) st-&gt;time_base.den,
                          st-&gt;info-&gt;codec_info_duration * 2 * (int64_t) st-&gt;time_base.num, 60000);


                /* Round guessed framerate to a "standard" framerate if it's
                 * within 1% of the original estimate. */
                for (j = 0; j &lt; MAX_STD_TIMEBASES; j++) {
                    AVRational std_fps = { get_std_framerate(j), 12 * 1001 };
                    double error       = fabs(av_q2d(st-&gt;avg_frame_rate) /
                                              av_q2d(std_fps) - 1);


                    if (error &lt; best_error) {
                        best_error = error;
                        best_fps   = std_fps.num;
                    }
                }
                if (best_fps)
                    av_reduce(&amp;st-&gt;avg_frame_rate.num, &amp;st-&gt;avg_frame_rate.den,
                              best_fps, 12 * 1001, INT_MAX);
            }


            if (!st-&gt;r_frame_rate.num) {
                if (    st-&gt;codec-&gt;time_base.den * (int64_t) st-&gt;time_base.num
                    &lt;= st-&gt;codec-&gt;time_base.num * st-&gt;codec-&gt;ticks_per_frame * (int64_t) st-&gt;time_base.den) {
                    st-&gt;r_frame_rate.num = st-&gt;codec-&gt;time_base.den;
                    st-&gt;r_frame_rate.den = st-&gt;codec-&gt;time_base.num * st-&gt;codec-&gt;ticks_per_frame;
                } else {
                    st-&gt;r_frame_rate.num = st-&gt;time_base.den;
                    st-&gt;r_frame_rate.den = st-&gt;time_base.num;
                }
            }
        } else if (st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
            if (!st-&gt;codec-&gt;bits_per_coded_sample)
                st-&gt;codec-&gt;bits_per_coded_sample =
                    av_get_bits_per_sample(st-&gt;codec-&gt;codec_id);
            // set stream disposition based on audio service type
            switch (st-&gt;codec-&gt;audio_service_type) {
            case AV_AUDIO_SERVICE_TYPE_EFFECTS:
                st-&gt;disposition = AV_DISPOSITION_CLEAN_EFFECTS;
                break;
            case AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED:
                st-&gt;disposition = AV_DISPOSITION_VISUAL_IMPAIRED;
                break;
            case AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED:
                st-&gt;disposition = AV_DISPOSITION_HEARING_IMPAIRED;
                break;
            case AV_AUDIO_SERVICE_TYPE_COMMENTARY:
                st-&gt;disposition = AV_DISPOSITION_COMMENT;
                break;
            case AV_AUDIO_SERVICE_TYPE_KARAOKE:
                st-&gt;disposition = AV_DISPOSITION_KARAOKE;
                break;
            }
        }
    }


    if (probesize)
    estimate_timings(ic, old_offset);


    av_opt_set(ic, "skip_clear", "0", AV_OPT_SEARCH_CHILDREN);


    if (ret &gt;= 0 &amp;&amp; ic-&gt;nb_streams)
        /* We could not have all the codec parameters before EOF. */
        ret = -1;
    for (i = 0; i &lt; ic-&gt;nb_streams; i++) {
        const char *errmsg;
        st = ic-&gt;streams[i];
        if (!has_codec_parameters(st, &amp;errmsg)) {
            char buf[256];
            avcodec_string(buf, sizeof(buf), st-&gt;codec, 0);
            av_log(ic, AV_LOG_WARNING,
                   "Could not find codec parameters for stream %d (%s): %s\n"
                   "Consider increasing the value for the 'analyzeduration' and 'probesize' options\n",
                   i, buf, errmsg);
        } else {
            ret = 0;
        }
    }


    compute_chapters_end(ic);


find_stream_info_err:
    for (i = 0; i &lt; ic-&gt;nb_streams; i++) {
        st = ic-&gt;streams[i];
        if (ic-&gt;streams[i]-&gt;codec-&gt;codec_type != AVMEDIA_TYPE_AUDIO)
            ic-&gt;streams[i]-&gt;codec-&gt;thread_count = 0;
        if (st-&gt;info)
            av_freep(&amp;st-&gt;info-&gt;duration_error);
        av_freep(&amp;ic-&gt;streams[i]-&gt;info);
    }
    if (ic-&gt;pb)
        av_log(ic, AV_LOG_DEBUG, "After avformat_find_stream_info() pos: %"PRId64" bytes read:%"PRId64" seeks:%d frames:%d\n",
               avio_tell(ic-&gt;pb), ic-&gt;pb-&gt;bytes_read, ic-&gt;pb-&gt;seek_count, count);
    return ret;
}</pre>
    <br/>
    由于avformat_find_stream_info()代码比较长，难以全部分析，在这里只能简单记录一下它的要点。该函数主要用于给每个媒体流（音频/视频）的AVStream结构体赋值。我们大致浏览一下这个函数的代码，会发现它其实已经实现了解码器的查找，解码器的打开，视音频帧的读取，视音频帧的解码等工作。换句话说，该函数实际上已经“走通”的解码的整个流程。下面看一下除了成员变量赋值之外，该函数的几个关键流程。
    <br/>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
    </blockquote>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
     1.查找解码器：find_decoder()
     <br/>
     2.打开解码器：avcodec_open2()
     <br/>
     3.读取完整的一帧压缩编码的数据：read_frame_internal()
     <br/>
     <span style="font-family:'FangSong_GB2312';">
      注：av_read_frame()内部实际上就是调用的read_frame_internal()。
     </span>
     <br/>
     4.解码一些压缩编码数据：try_decode_frame()
    </blockquote>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
    </blockquote>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
    </blockquote>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
    </blockquote>
    下面选择上述流程中几个关键函数的代码简单看一下。
    <br/>
    <br/>
    <h2>
     find_decoder()
    </h2>
    find_decoder()用于找到合适的解码器，它的定义如下所示。
    <br/>
    <pre class="cpp">static const AVCodec *find_decoder(AVFormatContext *s, AVStream *st, enum AVCodecID codec_id)
{
    if (st-&gt;codec-&gt;codec)
        return st-&gt;codec-&gt;codec;


    switch (st-&gt;codec-&gt;codec_type) {
    case AVMEDIA_TYPE_VIDEO:
        if (s-&gt;video_codec)    return s-&gt;video_codec;
        break;
    case AVMEDIA_TYPE_AUDIO:
        if (s-&gt;audio_codec)    return s-&gt;audio_codec;
        break;
    case AVMEDIA_TYPE_SUBTITLE:
        if (s-&gt;subtitle_codec) return s-&gt;subtitle_codec;
        break;
    }


    return avcodec_find_decoder(codec_id);
}</pre>
    <br/>
    从代码中可以看出，如果指定的AVStream已经包含了解码器，则函数什么也不做直接返回。否则调用avcodec_find_decoder()获取解码器。avcodec_find_decoder()是一个FFmpeg的API函数，在这里不做详细分析。
    <br/>
    <br/>
    <h2>
     read_frame_internal()
    </h2>
    <p>
     read_frame_internal()的功能是读取一帧压缩码流数据。FFmpeg的API函数av_read_frame()内部调用的就是read_frame_internal()。有关这方面的知识可以参考文章：
    </p>
    <a href="http://blog.csdn.net/leixiaohua1020/article/details/12678577">
     ffmpeg 源代码简单分析 ： av_read_frame()
    </a>
    <br/>
    因此，可以认为read_frame_internal()和av_read_frame()的功能基本上是等同的。
    <br/>
    <br/>
    <h2>
     try_decode_frame()
    </h2>
    try_decode_frame()的功能可以从字面上的意思进行理解：“尝试解码一些帧”，它的定义如下所示。
    <br/>
    <pre class="cpp">/* returns 1 or 0 if or if not decoded data was returned, or a negative error */
static int try_decode_frame(AVFormatContext *s, AVStream *st, AVPacket *avpkt,
                            AVDictionary **options)
{
    const AVCodec *codec;
    int got_picture = 1, ret = 0;
    AVFrame *frame = av_frame_alloc();
    AVSubtitle subtitle;
    AVPacket pkt = *avpkt;


    if (!frame)
        return AVERROR(ENOMEM);


    if (!avcodec_is_open(st-&gt;codec) &amp;&amp;
        st-&gt;info-&gt;found_decoder &lt;= 0 &amp;&amp;
        (st-&gt;codec-&gt;codec_id != -st-&gt;info-&gt;found_decoder || !st-&gt;codec-&gt;codec_id)) {
        AVDictionary *thread_opt = NULL;


        codec = find_decoder(s, st, st-&gt;codec-&gt;codec_id);


        if (!codec) {
            st-&gt;info-&gt;found_decoder = -st-&gt;codec-&gt;codec_id;
            ret                     = -1;
            goto fail;
        }


        /* Force thread count to 1 since the H.264 decoder will not extract
         * SPS and PPS to extradata during multi-threaded decoding. */
        av_dict_set(options ? options : &amp;thread_opt, "threads", "1", 0);
        if (s-&gt;codec_whitelist)
            av_dict_set(options ? options : &amp;thread_opt, "codec_whitelist", s-&gt;codec_whitelist, 0);
        ret = avcodec_open2(st-&gt;codec, codec, options ? options : &amp;thread_opt);
        if (!options)
            av_dict_free(&amp;thread_opt);
        if (ret &lt; 0) {
            st-&gt;info-&gt;found_decoder = -st-&gt;codec-&gt;codec_id;
            goto fail;
        }
        st-&gt;info-&gt;found_decoder = 1;
    } else if (!st-&gt;info-&gt;found_decoder)
        st-&gt;info-&gt;found_decoder = 1;


    if (st-&gt;info-&gt;found_decoder &lt; 0) {
        ret = -1;
        goto fail;
    }


    while ((pkt.size &gt; 0 || (!pkt.data &amp;&amp; got_picture)) &amp;&amp;
           ret &gt;= 0 &amp;&amp;
           (!has_codec_parameters(st, NULL) || !has_decode_delay_been_guessed(st) ||
            (!st-&gt;codec_info_nb_frames &amp;&amp;
             st-&gt;codec-&gt;codec-&gt;capabilities &amp; CODEC_CAP_CHANNEL_CONF))) {
        got_picture = 0;
        switch (st-&gt;codec-&gt;codec_type) {
        case AVMEDIA_TYPE_VIDEO:
            ret = avcodec_decode_video2(st-&gt;codec, frame,
                                        &amp;got_picture, &amp;pkt);
            break;
        case AVMEDIA_TYPE_AUDIO:
            ret = avcodec_decode_audio4(st-&gt;codec, frame, &amp;got_picture, &amp;pkt);
            break;
        case AVMEDIA_TYPE_SUBTITLE:
            ret = avcodec_decode_subtitle2(st-&gt;codec, &amp;subtitle,
                                           &amp;got_picture, &amp;pkt);
            ret = pkt.size;
            break;
        default:
            break;
        }
        if (ret &gt;= 0) {
            if (got_picture)
                st-&gt;nb_decoded_frames++;
            pkt.data += ret;
            pkt.size -= ret;
            ret       = got_picture;
        }
    }


    if (!pkt.data &amp;&amp; !got_picture)
        ret = -1;


fail:
    av_frame_free(&amp;frame);
    return ret;
}</pre>
    <br/>
    从try_decode_frame()的定义可以看出，该函数首先判断视音频流的解码器是否已经打开，如果没有打开的话，先打开相应的解码器。接下来根据视音频流类型的不同，调用不同的解码函数进行解码：视频流调用avcodec_decode_video2()，音频流调用avcodec_decode_audio4()，字幕流调用avcodec_decode_subtitle2()。解码的循环会一直持续下去直到满足了while()的所有条件。
    <br/>
    <p>
     while()语句的条件中有一个has_codec_parameters()函数，用于判断AVStream中的成员变量是否都已经设置完毕。该函数在avformat_find_stream_info()中的多个地方被使用过。下面简单看一下该函数。
    </p>
    <p>
     <br/>
    </p>
    <h3>
     has_codec_parameters()
    </h3>
    has_codec_parameters()用于检查AVStream中的成员变量是否都已经设置完毕。函数的定义如下。
    <br/>
    <pre class="cpp">static int has_codec_parameters(AVStream *st, const char **errmsg_ptr)
{
    AVCodecContext *avctx = st-&gt;codec;


#define FAIL(errmsg) do {                                         \
        if (errmsg_ptr)                                           \
            *errmsg_ptr = errmsg;                                 \
        return 0;                                                 \
    } while (0)


    if (   avctx-&gt;codec_id == AV_CODEC_ID_NONE
        &amp;&amp; avctx-&gt;codec_type != AVMEDIA_TYPE_DATA)
        FAIL("unknown codec");
    switch (avctx-&gt;codec_type) {
    case AVMEDIA_TYPE_AUDIO:
        if (!avctx-&gt;frame_size &amp;&amp; determinable_frame_size(avctx))
            FAIL("unspecified frame size");
        if (st-&gt;info-&gt;found_decoder &gt;= 0 &amp;&amp;
            avctx-&gt;sample_fmt == AV_SAMPLE_FMT_NONE)
            FAIL("unspecified sample format");
        if (!avctx-&gt;sample_rate)
            FAIL("unspecified sample rate");
        if (!avctx-&gt;channels)
            FAIL("unspecified number of channels");
        if (st-&gt;info-&gt;found_decoder &gt;= 0 &amp;&amp; !st-&gt;nb_decoded_frames &amp;&amp; avctx-&gt;codec_id == AV_CODEC_ID_DTS)
            FAIL("no decodable DTS frames");
        break;
    case AVMEDIA_TYPE_VIDEO:
        if (!avctx-&gt;width)
            FAIL("unspecified size");
        if (st-&gt;info-&gt;found_decoder &gt;= 0 &amp;&amp; avctx-&gt;pix_fmt == AV_PIX_FMT_NONE)
            FAIL("unspecified pixel format");
        if (st-&gt;codec-&gt;codec_id == AV_CODEC_ID_RV30 || st-&gt;codec-&gt;codec_id == AV_CODEC_ID_RV40)
            if (!st-&gt;sample_aspect_ratio.num &amp;&amp; !st-&gt;codec-&gt;sample_aspect_ratio.num &amp;&amp; !st-&gt;codec_info_nb_frames)
                FAIL("no frame in rv30/40 and no sar");
        break;
    case AVMEDIA_TYPE_SUBTITLE:
        if (avctx-&gt;codec_id == AV_CODEC_ID_HDMV_PGS_SUBTITLE &amp;&amp; !avctx-&gt;width)
            FAIL("unspecified size");
        break;
    case AVMEDIA_TYPE_DATA:
        if (avctx-&gt;codec_id == AV_CODEC_ID_NONE) return 1;
    }


    return 1;
}</pre>
    <br/>
    <br/>
    <h2>
     estimate_timings()
    </h2>
    estimate_timings()位于avformat_find_stream_info()最后面，用于估算AVFormatContext以及AVStream的时长duration。它的代码如下所示。
    <br/>
    <pre class="cpp">static void estimate_timings(AVFormatContext *ic, int64_t old_offset)
{
    int64_t file_size;


    /* get the file size, if possible */
    if (ic-&gt;iformat-&gt;flags &amp; AVFMT_NOFILE) {
        file_size = 0;
    } else {
        file_size = avio_size(ic-&gt;pb);
        file_size = FFMAX(0, file_size);
    }


    if ((!strcmp(ic-&gt;iformat-&gt;name, "mpeg") ||
         !strcmp(ic-&gt;iformat-&gt;name, "mpegts")) &amp;&amp;
        file_size &amp;&amp; ic-&gt;pb-&gt;seekable) {
        /* get accurate estimate from the PTSes */
        estimate_timings_from_pts(ic, old_offset);
        ic-&gt;duration_estimation_method = AVFMT_DURATION_FROM_PTS;
    } else if (has_duration(ic)) {
        /* at least one component has timings - we use them for all
         * the components */
        fill_all_stream_timings(ic);
        ic-&gt;duration_estimation_method = AVFMT_DURATION_FROM_STREAM;
    } else {
        /* less precise: use bitrate info */
        estimate_timings_from_bit_rate(ic);
        ic-&gt;duration_estimation_method = AVFMT_DURATION_FROM_BITRATE;
    }
    update_stream_timings(ic);


    {
        int i;
        AVStream av_unused *st;
        for (i = 0; i &lt; ic-&gt;nb_streams; i++) {
            st = ic-&gt;streams[i];
            av_dlog(ic, "%d: start_time: %0.3f duration: %0.3f\n", i,
                    (double) st-&gt;start_time / AV_TIME_BASE,
                    (double) st-&gt;duration   / AV_TIME_BASE);
        }
        av_dlog(ic,
                "stream: start_time: %0.3f duration: %0.3f bitrate=%d kb/s\n",
                (double) ic-&gt;start_time / AV_TIME_BASE,
                (double) ic-&gt;duration   / AV_TIME_BASE,
                ic-&gt;bit_rate / 1000);
    }
}</pre>
    <br/>
    从estimate_timings()的代码中可以看出，有3种估算方法：
    <br/>
    （1）通过pts（显示时间戳）。该方法调用estimate_timings_from_pts()。它的基本思想就是读取视音频流中的结束位置AVPacket的PTS和起始位置AVPacket的PTS，两者相减得到时长信息。
    <br/>
    （2）通过已知流的时长。该方法调用fill_all_stream_timings()。它的代码没有细看，但从函数的注释的意思来说，应该是当有些视音频流有时长信息的时候，直接赋值给其他视音频流。
    <br/>
    （3）通过bitrate（码率）。该方法调用estimate_timings_from_bit_rate()。它的基本思想就是获得整个文件大小，以及整个文件的bitrate，两者相除之后得到时长信息。
    <br/>
    <br/>
    <h3>
     estimate_timings_from_bit_rate()
    </h3>
    在这里附上上述几种方法中最简单的函数estimate_timings_from_bit_rate()的代码。
    <br/>
    <pre class="cpp">static void estimate_timings_from_bit_rate(AVFormatContext *ic)
{
    int64_t filesize, duration;
    int i, show_warning = 0;
    AVStream *st;


    /* if bit_rate is already set, we believe it */
    if (ic-&gt;bit_rate &lt;= 0) {
        int bit_rate = 0;
        for (i = 0; i &lt; ic-&gt;nb_streams; i++) {
            st = ic-&gt;streams[i];
            if (st-&gt;codec-&gt;bit_rate &gt; 0) {
                if (INT_MAX - st-&gt;codec-&gt;bit_rate &lt; bit_rate) {
                    bit_rate = 0;
                    break;
                }
                bit_rate += st-&gt;codec-&gt;bit_rate;
            }
        }
        ic-&gt;bit_rate = bit_rate;
    }


    /* if duration is already set, we believe it */
    if (ic-&gt;duration == AV_NOPTS_VALUE &amp;&amp;
        ic-&gt;bit_rate != 0) {
        filesize = ic-&gt;pb ? avio_size(ic-&gt;pb) : 0;
        if (filesize &gt; ic-&gt;data_offset) {
            filesize -= ic-&gt;data_offset;
            for (i = 0; i &lt; ic-&gt;nb_streams; i++) {
                st      = ic-&gt;streams[i];
                if (   st-&gt;time_base.num &lt;= INT64_MAX / ic-&gt;bit_rate
                    &amp;&amp; st-&gt;duration == AV_NOPTS_VALUE) {
                    duration = av_rescale(8 * filesize, st-&gt;time_base.den,
                                          ic-&gt;bit_rate *
                                          (int64_t) st-&gt;time_base.num);
                    st-&gt;duration = duration;
                    show_warning = 1;
                }
            }
        }
    }
    if (show_warning)
        av_log(ic, AV_LOG_WARNING,
               "Estimating duration from bitrate, this may be inaccurate\n");
}</pre>
    <br/>
    从代码中可以看出，该函数做了两步工作：
    <br/>
    （1）如果AVFormatContext中没有bit_rate信息，就把所有AVStream的bit_rate加起来作为AVFormatContext的bit_rate信息。
    <br/>
    （2）使用文件大小filesize除以bitrate得到时长信息。具体的方法是：
    <br/>
    <div style="text-align:center;">
     <strong>
      AVStream-&gt;duration=(filesize*8/bit_rate)/time_base
     </strong>
    </div>
    <span style="font-family:'FangSong_GB2312';">
     PS：
     <br/>
     1）filesize乘以8是因为需要把Byte转换为Bit
     <br/>
     2）具体的实现函数是那个av_rescale()函数。x=av_rescale(a,b,c)的含义是x=a*b/c。
     <br/>
     3）之所以要除以time_base，是因为AVStream中的duration的单位是time_base，注意这和AVFormatContext中的duration的单位（单位是AV_TIME_BASE，固定取值为1000000）是不一样的。
    </span>
    <br/>
    <p>
     <br/>
    </p>
    <p>
     至此，avformat_find_stream_info()主要的函数就分析完了。
    </p>
    <p>
     <br/>
    </p>
    <p>
     <strong>
      <span style="color:#990000;">
       雷霄骅
       <br/>
       leixiaohua1020@126.com
       <br/>
       http://blog.csdn.net/leixiaohua1020
      </span>
     </strong>
     <br/>
    </p>
   </div>
  </div>
  <div style="display:none;" class="hide-article-box text-center csdn-tracking-statistics tracking-click" data-mod="popu_376">
   <a class="btn btn-red-hollow" id="btn-readmore">
    阅读更多
   </a>
  </div>
 </article>
 <div class="article-bar-bottom">
  <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。			https://blog.csdn.net/leixiaohua1020/article/details/44084321
  </div>
  <div class="tags-box artic-tag-box">
   <span class="label">
    文章标签：
   </span>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=FFmpeg&amp;t=blog" target="_blank">
    FFmpeg
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=源代码&amp;t=blog" target="_blank">
    源代码
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=AVFormatContext&amp;t=blog" target="_blank">
    AVFormatContext
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=媒体信息&amp;t=blog" target="_blank">
    媒体信息
   </a>
  </div>
  <div class="tags-box">
   <span class="label">
    个人分类：
   </span>
   <a class="tag-link" href="https://blog.csdn.net/leixiaohua1020/article/category/1360795" target="_blank">
    FFMPEG
   </a>
  </div>
  <div class="tags-box">
   <span class="label">
    所属专栏：
   </span>
   <a class="tag-link" href="https://blog.csdn.net/column/details/ffmpeg-devel.html" target="_blank">
    FFmpeg
   </a>
  </div>
 </div>
 <!-- !empty($pre_next_article[0]) -->
</div>
<div class="recommend-box">
                            <div style="background: #fff; border: dashed 1px #666; padding-left: 1em; padding-top: 1em; padding-bottom: 1em;">
                                <span style="font-size: 0.8em; font-weight: bold;">
                                    此PDF由<a style="color:#0000ff" href="http://www.github.com/spygg"  target="_blank">spygg</a>生成,请尊重原作者版权!!!
                                    <br/>
                                    我的邮箱:liushidc@163.com
                                </span>
                                </div> 
                        </div>
                    </main>
      
                </div>

            <script>
                var recommendCount = 0;
                var articleTit = "";
                var articleId = "";
                var commentscount = 0;

                //1禁止评论，2正常
                var commentAuth = 1;
                //百度搜索
                var baiduKey = "";
                var needInsertBaidu = "";
            </script>
            <script src="https://csdnimg.cn/release/phoenix/template/js/detail-effe72036e.min.js"></script>
            </body>
        </html>