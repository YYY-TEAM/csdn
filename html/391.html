
            <!DOCTYPE html>
            <html lang="zh-CN">
                <head>
                    <meta charset="UTF-8">
                    <title>
 字节序（Endian），大端（Big-Endian），小端（Little-Endian） - CSDN博客
</title>

                <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-60a2c245da.min.css">
                <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-88717cedf2.min.css">

                <script type="text/javascript">
                var username = "";
                </script>

                <script src="https://csdnimg.cn/public/common/libs/jquery/jquery-1.9.1.min.js" type="text/javascript"></script>

                <!-- 新版上报 -->
                <!-- 新版上报end -->
                <link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.3/css/sandalstrap.min.css"> 
                </head>
                <body>    
        
                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
                    <div class="container clearfix pt0" id="mainBox">
        <main style="width: 100%;"><div class="blog-content-box">
 <div class="article-title-box" id="article_anchors_391">
  <span class="article-type type-2 float-left">
   转
  </span>
  <h1 class="title-article">
   字节序（Endian），大端（Big-Endian），小端（Little-Endian）
  </h1>
 </div>
 <div class="article-info-box">
  <div class="article-bar-top d-flex">
   <span class="time">
    2013年10月13日 17:56:53
   </span>
   <div ">
    <span class="read-count">
     阅读数：3699
    </span>
   </div>
  </div>
 </div>
 <article>
  <div class="article_content clearfix csdn-tracking-statistics" data-dsm="post" data-mod="popu_307" data-pid="blog" id="article_content">
   <link href="https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css" rel="stylesheet"/>
   <div class="htmledit_views">
    <p>
     在各种计算机体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如果不达成一致的规则，通信双方将无法进行正确的编/译码从而导致通信失败。目前在各种体系的计算机中通常采用的字节存储机制主要有两种：
    </p>
    <p>
     big-edian和little-endian。
    </p>
    <p>
     <strong>
     </strong>
    </p>
    <p>
     <strong>
     </strong>
    </p>
    <p>
     <strong>
      字节顺序 Endian
     </strong>
    </p>
    <p>
     现代的计算机系统一般采用
     <strong>
      字节
     </strong>
     (Octet, 8 bit Byte)作为逻辑寻址单位。当物理单位的长度大于1个字节时，就要区分
     <strong>
      字节顺序
     </strong>
     (Byte Order, or
     <a href="http://en.wikipedia.org/wiki/Endianness">
      <span>
       <u>
        Endianness
       </u>
      </span>
     </a>
     )。常见的字节顺序有两种：
     <strong>
      Big
 Endian
     </strong>
     (High-byte first)和
     <strong>
      Little Endian
     </strong>
     (Low-byte first)，这就是表2.1中的
     <strong>
      BE
     </strong>
     和
     <strong>
      LE
     </strong>
     。Intel X86平台采用Little Endian，而PowerPC处理器则采用了Big Endian。举例来说，整型数字$
     <strong>
      1234ABCD
     </strong>
     存储的时候就会有两种方式：
     <strong>
     </strong>
    </p>
    <table border="1" cellpadding="0" cellspacing="0">
     <tbody>
      <tr>
       <td valign="top">
        <p align="center">
         字节顺序
        </p>
       </td>
       <td valign="top">
        <p align="center">
         内存数据
        </p>
       </td>
       <td valign="top">
        <p align="center">
         备注
        </p>
       </td>
      </tr>
      <tr>
       <td valign="top">
        <p>
         <span style="font-family:'宋体';">
          Big Endian (BE)
         </span>
        </p>
       </td>
       <td valign="top">
        <p align="center">
         0xAB 0xCD 0x12 0x34
        </p>
       </td>
       <td valign="top">
        <p>
         <span style="font-family:'宋体';">
          此时的0xAB被称为
          <a href="http://en.wikipedia.org/wiki/Most_significant_byte">
           <span>
            <u>
             most significant byte
            </u>
           </span>
          </a>
          (
          <em>
           MSB
          </em>
          )
         </span>
        </p>
       </td>
      </tr>
      <tr>
       <td valign="top">
        <p>
         <span style="font-family:'宋体';">
          Little Endian (LE)
         </span>
        </p>
       </td>
       <td valign="top">
        <p align="center">
         0xCD 0xAB 0x34 0x12
        </p>
       </td>
       <td valign="top">
        <p>
         <span style="font-family:'宋体';">
          此时的0xCD被称为
          <a href="http://en.wikipedia.org/wiki/Least_significant_byte">
           <span>
            <u>
             least significant byte
            </u>
           </span>
          </a>
          (
          <em>
           LSB
          </em>
          )
         </span>
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <p>
    </p>
    <p>
     词源：据Jargon File记载，endian这个词来源于Jonathan Swift在1726年写的讽刺小说 "Gulliver's Travels"（《格利佛游记》）。该小说在描述Gulliver畅游小人国时碰到了如下的一个场景。在小人国里的小人因为非常小（身高6英寸）所以总是碰到一些意想不到的问题。有一次因为对水煮蛋该从大的一端（Big-End）剥开还是小的一端（Little-End）剥开的争论而引发了一场战争，并形成了两支截然对立的队伍：支持从Big-End剥开的人Swift就称作Big-Endians而支持从Little-End剥开的人就称作Little-Endians……（后缀ian表明的就是支持某种观点的人:-）。Endian这个词由此而来。
    </p>
    <p>
     1980年，Danny Cohen在其著名的论文"On Holy Wars and a Plea for Peace"中为了平息一场关于在消息中字节该以什么样的顺序进行传送的争论而引用了该词。该文中，Cohen非常形象贴切地把支持从一个消息序列的MSB开始传送的那伙人叫做Big-Endians，支持从LSB开始传送的相对应地叫做Little-Endians。此后Endian这个词便随着这篇论文而被广为采用。
    </p>
    <p align="center">
     <img alt="" border="0" height="353" src="http://www.cppblog.com/images/cppblog_com/tx7do/250px-Endianessmap_svg.png" width="250"/>
     <a href="http://en.wikipedia.org/wiki/File:Endianessmap.svg" title="Mapping registers to memory locations">
     </a>
    </p>
    <p align="center">
     Mapping registers to memory locations
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     <strong>
      最高有效位 MSB: Most Significant Bit
     </strong>
    </p>
    <p>
     最高有效位(MSB)，有时候叫做最左边的位，是在一个n位二进制数字中的n-1位，这个位有最高的权重(2^(n-1))。第一个或最左边的位，当这个数字被用一般的方式书写时。
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     <strong>
      最低有效位 LSB: Least Significant Bit
     </strong>
    </p>
    <p>
     最低有效位(LSB)是给这些单元值的一个二进制整数位位置，就是，决定是否这个数字是偶数或奇数。LSB有时候是指最右边的位，因为写较不重要的数字到右边位置符号的协定。它类似于一个十进制整数的最不重要的数字，它是在一个(最右边)位置的数字。
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     <strong>
      大端Big-Endian
     </strong>
    </p>
    <p>
     低地址存放最高有效位（MSB），既高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。
    </p>
    <p>
     计算机体系结构中一种描述多字节存储顺序的术语，在这种机制中最高有效位（MSB）存放在最低端的地址上。采用这种机制的处理器有IBM3700系列、PDP-10、Mortolora微处理器系列和绝大多数的RISC处理器。
    </p>
    <p align="center">
     <img alt="" border="0" height="250" src="http://www.cppblog.com/images/cppblog_com/tx7do/280px-Big-Endian_svg.png" width="280"/>
     <a href="http://en.wikipedia.org/wiki/File:Big-Endian.svg" title="Big-Endian.svg">
     </a>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     <strong>
      小端Little-Endian
     </strong>
    </p>
    <p>
     低地址存放最低有效位（LSB），既低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。
    </p>
    <p>
     计算机体系结构中一种描述多字节存储顺序的术语，在这种机制中最不重要字节（LSB）存放在最低端的地址上。采用这种机制的处理器有PDP-11、VAX、Intel系列微处理器和一些网络通信设备。该术语除了描述多字节存储顺序外还常常用来描述一个字节中各个比特的排放次序。
    </p>
    <p align="center">
     <img alt="" border="0" height="250" src="http://www.cppblog.com/images/cppblog_com/tx7do/280px-Little-Endian_svg.png" width="280"/>
     <a href="http://en.wikipedia.org/wiki/File:Little-Endian.svg" title="Little-Endian.svg">
     </a>
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     <strong>
      中端 Middle-Endian
     </strong>
    </p>
    <p>
     除了big-endian和little-endian之外的多字节存储顺序就是middle-endian，比如以4个字节为例：象以3-4-1-2或者2-1-4-3这样的顺序存储的就是middle-endian。这种存储顺序偶尔会在一些小型机体系中的十进制数的压缩格式中出现。
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     <strong>
      网络字节序 Network Order
     </strong>
    </p>
    <p>
     TCP/IP各层协议将字节序定义为Big-Endian，因此TCP/IP协议中使用的字节序通常称之为网络字节序。
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     <strong>
      主机序 Host Orader
     </strong>
    </p>
    <p>
     它遵循Little-Endian规则。所以当两台主机之间要通过TCP/IP协议进行通信的时候就需要调用相应的函数进行主机序（Little-Endian）和网络序（Big-Endian）的转换。
    </p>
    <p>
    </p>
    <p>
    </p>
    <p>
     <strong>
      C++怎样判别大端小端
     </strong>
    </p>
    <p>
     使用宏的方法：
    </p>
    <p>
    </p>
    <div>
     <pre class="cpp">const int endian = 1;
#define is_bigendian() ( (*(char*) &amp;endian) == 0 )
#define is_littlendbian() ( (*(char*) &amp;endian) == 1 )
</pre>
     <br/>
    </div>
    <p>
     方法二：
    </p>
    <p>
    </p>
    <pre class="cpp">bool    IsLittleEndian()
{
union   
{    
long    val;
char    Char[sizeof(long)];
}u;
//    1-小端（Intel）;    0-大端(Motor)
u.val = 1;  
if ( u.Char[0] == 1 )
{
// 小端
return true;
}  
else if ( u.Char[sizeof(long)-1] == 1 )
{
// 大端
return false;  
} 
throw( "Unknown!" );
}</pre>
    <br/>
    <br/>
    <p>
    </p>
    <p>
     <strong>
      小知识
     </strong>
    </p>
    <p>
     Java使用的是Big-Endian。
    </p>
    <p>
    </p>
    原文地址：
    <a href="http://www.cppblog.com/tx7do/archive/2009/01/06/71276.html">
     http://www.cppblog.com/tx7do/archive/2009/01/06/71276.html
    </a>
   </div>
  </div>
  <div style="display:none;" class="hide-article-box text-center csdn-tracking-statistics tracking-click" data-mod="popu_376">
   <a class="btn btn-red-hollow" id="btn-readmore">
    阅读更多
   </a>
  </div>
 </article>
 <div class="article-bar-bottom">
  <div class="tags-box artic-tag-box">
   <span class="label">
    文章标签：
   </span>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=字节序&amp;t=blog" target="_blank">
    字节序
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=大端&amp;t=blog" target="_blank">
    大端
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=Big-Endian&amp;t=blog" target="_blank">
    Big-Endian
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=小端&amp;t=blog" target="_blank">
    小端
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=Little-Endian&amp;t=blog" target="_blank">
    Little-Endian
   </a>
  </div>
  <div class="tags-box">
   <span class="label">
    个人分类：
   </span>
   <a class="tag-link" href="https://blog.csdn.net/leixiaohua1020/article/category/1647545" target="_blank">
    纯编程
   </a>
  </div>
 </div>
 <!-- !empty($pre_next_article[0]) -->
</div>
<div class="recommend-box">
                            <div style="background: #fff; border: dashed 1px #666; padding-left: 1em; padding-top: 1em; padding-bottom: 1em;">
                                <span style="font-size: 0.8em; font-weight: bold;">
                                    此PDF由<a style="color:#0000ff" href="http://www.github.com/spygg"  target="_blank">spygg</a>生成,请尊重原作者版权!!!
                                    <br/>
                                    我的邮箱:liushidc@163.com
                                </span>
                                </div> 
                        </div>
                    </main>
      
                </div>

            <script>
                var recommendCount = 0;
                var articleTit = "";
                var articleId = "";
                var commentscount = 0;

                //1禁止评论，2正常
                var commentAuth = 1;
                //百度搜索
                var baiduKey = "";
                var needInsertBaidu = "";
            </script>
            <script src="https://csdnimg.cn/release/phoenix/template/js/detail-effe72036e.min.js"></script>
            </body>
        </html>