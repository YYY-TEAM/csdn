
            <!DOCTYPE html>
            <html lang="zh-CN">
                <head>
                    <meta charset="UTF-8">
                    <title>
 ffmpeg函数介绍 - CSDN博客
</title>

                <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-60a2c245da.min.css">
                <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-88717cedf2.min.css">

                <script type="text/javascript">
                var username = "";
                </script>

                <script src="https://csdnimg.cn/public/common/libs/jquery/jquery-1.9.1.min.js" type="text/javascript"></script>

                <!-- 新版上报 -->
                <!-- 新版上报end -->
                <link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.3/css/sandalstrap.min.css"> 
                </head>
                <body>    
        
                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
                    <div class="container clearfix pt0" id="mainBox">
        <main style="width: 100%;"><div class="blog-content-box">
 <div class="article-title-box" id="article_anchors_473">
  <span class="article-type type-2 float-left">
   转
  </span>
  <h1 class="title-article">
   ffmpeg函数介绍
  </h1>
 </div>
 <div class="article-info-box">
  <div class="article-bar-top d-flex">
   <span class="time">
    2013年09月24日 16:01:44
   </span>
   <div ">
    <span class="read-count">
     阅读数：31598
    </span>
   </div>
  </div>
 </div>
 <article>
  <div class="article_content clearfix csdn-tracking-statistics" data-dsm="post" data-mod="popu_307" data-pid="blog" id="article_content">
   <link href="https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css" rel="stylesheet"/>
   <div class="htmledit_views">
    <p>
     本文对在使用ffmpeg进行音视频编解码时使用到的一些函数做一个简单介绍,我当前使用的ffmpeg版本为:0.8.5,因为本人发现在不同的版本中,有些函数名称会有点小改动,所以在此有必要说明下ffmpeg的版本号。
    </p>
    <p>
     ffmpeg本人也是刚接触，本文将采用累加的方法逐个介绍我使用到的函数，如有不妥之处，还望谅解！
    </p>
    <p>
    </p>
    <p>
     头文件引入方法:
    </p>
    <div>
     <p align="left">
      <span style="color:#0000FF;">
       extern
      </span>
      <span style="color:#a31515;">
       "C"
      </span>
      {
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       #include
      </span>
      <span style="color:#a31515;">
       "libavcodec/avcodec.h"
      </span>
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       #include
      </span>
      <span style="color:#a31515;">
       "libavformat/avformat.h"
      </span>
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       #include
      </span>
      <span style="color:#a31515;">
       "libavutil/avutil.h"
      </span>
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       #include
      </span>
      <span style="color:#a31515;">
       "libavutil/mem.h"
      </span>
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       #include
      </span>
      <span style="color:#a31515;">
       "libavutil/fifo.h"
      </span>
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       #include
      </span>
      <span style="color:#a31515;">
       "libswscale/swscale.h"
      </span>
     </p>
     <p align="left">
      };
     </p>
     <p align="left">
     </p>
    </div>
    <div>
     <span style="font-size:18px;">
      <strong>
       1 avcodec_init()
      </strong>
     </span>
    </div>
    <div>
     <p align="left">
      <span style="color:#008000;">
       /**
      </span>
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * Initialize libavcodec.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * If called more than once, does nothing.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      *
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @warning This function must be called before any other libavcodec
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * function.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      *
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @warning This function is not thread-safe.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      */
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       void
      </span>
      avcodec_init(
      <span style="color:#0000FF;">
       void
      </span>
      );
     </p>
     <p align="left">
      // 初始化libavcodec,一般最先调用该函数
     </p>
     <p align="left">
      // 引入头文件：
      <span style="color:#0000FF;">
       #include
      </span>
      <span style="color:#a31515;">
       "libavcodec/avcodec.h"
      </span>
     </p>
     <p align="left">
      <span style="color:#a31515;">
       <span style="color:#000000;">
        // 实现在: \ffmpeg\libavcodec\utils.c
       </span>
      </span>
     </p>
     <p align="left">
      <span style="color:#a31515;">
       <span style="color:#000000;">
        // 该函数必须在调用libavcodec里的其它函数前调用,一般在程序启动或模块初始化时调用,如果你调用了多次也无所谓,因为后面的调用不会做任何事情.从函数的实现里你可以发现,代码中对多次调用进行了控制.
       </span>
      </span>
     </p>
     <p align="left">
      <span style="color:#a31515;">
       <span style="color:#000000;">
        // 该函数是非线程安全的
       </span>
      </span>
     </p>
     <p align="left">
     </p>
     <p align="left">
      <span style="font-size:18px;">
       <strong>
        2 av_register_all()
       </strong>
      </span>
     </p>
     <p align="left">
      <span style="color:#008000;">
       /**
      </span>
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * Initialize libavformat and register all the muxers, demuxers and
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * protocols. If you do not call this function, then you can select
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * exactly which formats you want to support.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      *
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @see av_register_input_format()
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @see av_register_output_format()
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @see av_register_protocol()
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      */
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       void
      </span>
      av_register_all(
      <span style="color:#0000FF;">
       void
      </span>
      );
     </p>
     <p align="left">
      // 初始化 libavformat和注册所有的muxers、demuxers和protocols，
     </p>
     <p align="left">
      // 一般在调用avcodec_init后调用该方法
     </p>
     <p align="left">
      // 引入头文件：
      <span style="color:#0000FF;">
       #include
      </span>
      <span style="color:#a31515;">
       "libavformat/avformat.h"
      </span>
     </p>
     <p align="left">
      // 实现在:\ffmpeg\libavformat\allformats.c
     </p>
     <p align="left">
      // 其中会调用avcodec_register_all()注册多种音视频格式的编解码器,并注册各种文件的编解复用器
     </p>
     <p align="left">
      // 当然，你也可以不调用该函数，而通过选择调用特定的方法来提供支持
     </p>
     <p align="left">
     </p>
     <p align="left">
      <span style="font-size:18px;">
       <strong>
        3 avformat_alloc_context()
       </strong>
      </span>
     </p>
     <span style="color:#008000;">
     </span>
     <p align="left">
      <span style="color:#008000;">
       /**
      </span>
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * Allocate an AVFormatContext.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * avformat_free_context() can be used to free the context and everything
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * allocated by the framework within it.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      */
     </p>
     <p align="left">
      AVFormatContext *avformat_alloc_context(
      <span style="color:#0000FF;">
       void
      </span>
      );
     </p>
     <p align="left">
      // 分配一个AVFormatContext结构
     </p>
     <p align="left">
      // 引入头文件：
      <span style="color:#0000FF;">
       #include
      </span>
      <span style="color:#a31515;">
       "libavformat/avformat.h"
      </span>
     </p>
     <p align="left">
      // 实现在:\ffmpeg\libavformat\options.c
     </p>
     <p align="left">
      // 其中负责申请一个AVFormatContext结构的内存,并进行简单初始化
     </p>
     <p align="left">
      // avformat_free_context()可以用来释放该结构里的所有东西以及该结构本身
     </p>
     <p align="left">
      // 也是就说使用 avformat_alloc_context()分配的结构,需要使用avformat_free_context()来释放
     </p>
     <p align="left">
      // 有些版本中函数名可能为: av_alloc_format_context();
     </p>
     <p align="left">
     </p>
     <p align="left">
      <span style="font-size:18px;">
       <strong>
        4 avformat_free_context()
       </strong>
      </span>
     </p>
     <p align="left">
      <span style="color:#008000;">
       /**
      </span>
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * Free an AVFormatContext and all its streams.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @param s context to free
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      */
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       void
      </span>
      avformat_free_context(AVFormatContext *s);
     </p>
     <p align="left">
      // 释放一个AVFormatContext结构
     </p>
     <p align="left">
      // 引入头文件：
      <span style="color:#0000FF;">
       #include
      </span>
      <span style="color:#a31515;">
       "libavformat/avformat.h"
      </span>
     </p>
     <p align="left">
      <span style="color:#a31515;">
       <span style="color:#000000;">
        // 实现在:\ffmpeg\libavformat\utils.c
       </span>
      </span>
     </p>
     <p align="left">
      <span style="color:#a31515;">
       <span style="color:#000000;">
        // 使用 avformat_alloc_context()分配的结构,采用该函数进行释放,除释放AVFormatContext结构本身内存之外,AVFormatContext中指针所指向的内存也会一并释放
       </span>
      </span>
     </p>
     <span style="color:#a31515;">
      <span style="color:#000000;">
      </span>
     </span>
     <p align="left">
      // 有些版本中函数名猜测可能为: av_free_format_context();
     </p>
     <p align="left">
     </p>
     <p align="left">
      <span style="font-size:18px;">
       <strong>
        5 AVFormatContext 结构
       </strong>
      </span>
     </p>
     <p align="left">
      <span style="color:#008000;">
       /**
      </span>
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * Format I/O context.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * New fields can be added to the end with minor version bumps.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * Removal, reordering and changes to existing fields require a major
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * version bump.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * sizeof(AVFormatContext) must not be used outside libav*.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      */
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       typedef
      </span>
      <span style="color:#0000FF;">
       struct
      </span>
      AVFormatContext {
     </p>
     <p align="left">
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       struct
      </span>
      AVInputFormat *iformat;
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       struct
      </span>
      AVOutputFormat *oformat;
     </p>
     <p align="left">
      AVIOContext *pb;
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       unsigned
      </span>
      <span style="color:#0000FF;">
       int
      </span>
      nb_streams;
     </p>
     <p align="left">
      AVStream **streams;
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       char
      </span>
      filename[1024];
      <span style="color:#008000;">
       /**&lt; input or output filename */
      </span>
     </p>
     <p align="left">
      <span>
       ....
      </span>
     </p>
     <p align="left">
      } AVFormatContext;
     </p>
     <p align="left">
      // AVFormatContext在FFMpeg里是一个非常重要的的结构，是其它输入、输出相关信息的一个容器
     </p>
     <p align="left">
      // 引入头文件：
      <span style="color:#0000FF;">
       #include
      </span>
      <span style="color:#a31515;">
       "libavformat/avformat.h"
      </span>
     </p>
     <p align="left">
      // 以上只列出了其中的部分成员
     </p>
     <p align="left">
      // 作为输入容器时
      <span style="color:#0000FF;">
       struct
      </span>
      AVInputFormat *iformat; 不能为空, 其中包含了输入文件的音视频流信息,程序从输入容器从读出音视频包进行解码处理
     </p>
     <p align="left">
      // 作为输出容器时
      <span style="color:#0000FF;">
       struct
      </span>
      AVOutputFormat *oformat; 不能为空, 程序把编码好的音视频包写入到输出容器中
     </p>
     <p align="left">
      // AVIOContext *pb: I/O上下文,通过对该变量赋值可以改变输入源或输出目的
     </p>
     <p align="left">
      //
      <span style="color:#0000FF;">
       unsigned
      </span>
      <span style="color:#0000FF;">
       int
      </span>
      nb_streams; 音视频流数量
     </p>
     <p align="left">
      // AVStream **streams; 音视频流
     </p>
     <p align="left">
     </p>
     <p align="left">
      <strong>
       <span style="font-size:18px;">
        6 AVIOContext 结构
       </span>
      </strong>
     </p>
     <span style="color:#0000FF;">
     </span>
     <p align="left">
      <span style="color:#008000;">
       /**
      </span>
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * Bytestream IO Context.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * New fields can be added to the end with minor version bumps.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * Removal, reordering and changes to existing fields require a major
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * version bump.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * sizeof(AVIOContext) must not be used outside libav*.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      *
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @note None of the function pointers in AVIOContext should be called
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      *       directly, they should only be set by the client application
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      *       when implementing custom I/O. Normally these are set to the
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      *       function pointers specified in avio_alloc_context()
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      */
     </p>
     <p align="left">
      typedef
      <span style="color:#0000FF;">
       struct
      </span>
      {
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       unsigned
      </span>
      <span style="color:#0000FF;">
       char
      </span>
      *buffer;
      <span style="color:#008000;">
       /**&lt; Start of the buffer. */
      </span>
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       int
      </span>
      buffer_size;
      <span style="color:#008000;">
       /**&lt; Maximum buffer size */
      </span>
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       unsigned
      </span>
      <span style="color:#0000FF;">
       char
      </span>
      *buf_ptr;
      <span style="color:#008000;">
       /**&lt; Current position in the buffer */
      </span>
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       unsigned
      </span>
      <span style="color:#0000FF;">
       char
      </span>
      *buf_end;
      <span style="color:#008000;">
       /**&lt; End of the data, may be less than
      </span>
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      buffer+buffer_size if the read function returned
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      less data than requested, e.g. for streams where
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      no more data has been received yet. */
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       void
      </span>
      *opaque;
      <span style="color:#008000;">
       /**&lt; A private pointer, passed to the read/write/seek/...
      </span>
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      functions. */
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       int
      </span>
      (*read_packet)(
      <span style="color:#0000FF;">
       void
      </span>
      *opaque, uint8_t *buf,
      <span style="color:#0000FF;">
       int
      </span>
      buf_size);
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       int
      </span>
      (*write_packet)(
      <span style="color:#0000FF;">
       void
      </span>
      *opaque, uint8_t *buf,
      <span style="color:#0000FF;">
       int
      </span>
      buf_size);
     </p>
     <p align="left">
      int64_t (*seek)(
      <span style="color:#0000FF;">
       void
      </span>
      *opaque, int64_t offset,
      <span style="color:#0000FF;">
       int
      </span>
      whence);
     </p>
     <p align="left">
      int64_t pos;
      <span style="color:#008000;">
       /**&lt; position in the file of the current buffer */
      </span>
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       int
      </span>
      must_flush;
      <span style="color:#008000;">
       /**&lt; true if the next seek should flush */
      </span>
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       int
      </span>
      eof_reached;
      <span style="color:#008000;">
       /**&lt; true if eof reached */
      </span>
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       int
      </span>
      write_flag;
      <span style="color:#008000;">
       /**&lt; true if open for writing */
      </span>
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       #if
      </span>
      FF_API_OLD_AVIO
     </p>
     <p align="left">
      attribute_deprecated
      <span style="color:#0000FF;">
       int
      </span>
      is_streamed;
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       #endif
      </span>
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       int
      </span>
      max_packet_size;
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       unsigned
      </span>
      <span style="color:#0000FF;">
       long
      </span>
      checksum;
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       unsigned
      </span>
      <span style="color:#0000FF;">
       char
      </span>
      *checksum_ptr;
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       unsigned
      </span>
      <span style="color:#0000FF;">
       long
      </span>
      (*update_checksum)(
      <span style="color:#0000FF;">
       unsigned
      </span>
      <span style="color:#0000FF;">
       long
      </span>
      checksum,
      <span style="color:#0000FF;">
       const
      </span>
      uint8_t *buf,
      <span style="color:#0000FF;">
       unsigned
      </span>
      <span style="color:#0000FF;">
       int
      </span>
      size);
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       int
      </span>
      error;
      <span style="color:#008000;">
       /**&lt; contains the error code or 0 if no error happened */
      </span>
     </p>
     <p align="left">
      <span style="color:#008000;">
       /**
      </span>
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * Pause or resume playback for network streaming protocols - e.g. MMS.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      */
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       int
      </span>
      (*read_pause)(
      <span style="color:#0000FF;">
       void
      </span>
      *opaque,
      <span style="color:#0000FF;">
       int
      </span>
      pause);
     </p>
     <p align="left">
      <span style="color:#008000;">
       /**
      </span>
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * Seek to a given timestamp in stream with the specified stream_index.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * Needed for some network streaming protocols which don't support seeking
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * to byte position.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      */
     </p>
     <p align="left">
      int64_t (*read_seek)(
      <span style="color:#0000FF;">
       void
      </span>
      *opaque,
      <span style="color:#0000FF;">
       int
      </span>
      stream_index,
     </p>
     <p align="left">
      int64_t timestamp,
      <span style="color:#0000FF;">
       int
      </span>
      flags);
     </p>
     <p align="left">
      <span style="color:#008000;">
       /**
      </span>
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * A combination of AVIO_SEEKABLE_ flags or 0 when the stream is not seekable.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      */
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       int
      </span>
      seekable;
     </p>
     <p align="left">
      } AVIOContext;
     </p>
     <p align="left">
      // 字节流 I/O 上下文
     </p>
     <p align="left">
      // 在结构的尾部增加变量可以减少版本冲突
     </p>
     <p align="left">
      // 移除、排序和修改已经存在的变量将会导致较大的版本冲突
     </p>
     <p align="left">
      // sizeof(AVIOContext)在libav*.外部不可使用
     </p>
     <p align="left">
      // AVIOContext里的函数指针不能直接调用,通常使用avio_alloc_context()函数来设置其中的函数指针
     </p>
     <p align="left">
      //
      <span style="color:#0000FF;">
       unsigned
      </span>
      <span style="color:#0000FF;">
       char
      </span>
      *buffer: 缓存的起始指针
     </p>
     <p align="left">
      //
      <span style="color:#0000FF;">
       int
      </span>
      buffer_size: 缓存的最大值
     </p>
     <p align="left">
      //
      <span style="color:#0000FF;">
       void
      </span>
      *opaque: 在回调函数中使用的指针
     </p>
     <p align="left">
      //
      <span style="color:#0000FF;">
       int
      </span>
      (*read_packet)(
      <span style="color:#0000FF;">
       void
      </span>
      *opaque, uint8_t *buf,
      <span style="color:#0000FF;">
       int
      </span>
      buf_size): 读文件回调方法
     </p>
     <p align="left">
      //
      <span style="color:#0000FF;">
       int
      </span>
      (*write_packet)(
      <span style="color:#0000FF;">
       void
      </span>
      *opaque, uint8_t *buf,
      <span style="color:#0000FF;">
       int
      </span>
      buf_size): 写文件回调方法
     </p>
     <p align="left">
      // int64_t (*seek)(
      <span style="color:#0000FF;">
       void
      </span>
      *opaque, int64_t offset,
      <span style="color:#0000FF;">
       int
      </span>
      whence): seek文件回调方法
     </p>
     <p align="left">
     </p>
     <p align="left">
      <span style="font-size:18px;">
       <strong>
        7 avio_alloc_context()
       </strong>
      </span>
     </p>
     <p align="left">
      <span style="color:#008000;">
       /**
      </span>
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * Allocate and initialize an AVIOContext for buffered I/O. It must be later
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * freed with av_free().
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      *
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @param buffer Memory block for input/output operations via AVIOContext.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      *        The buffer must be allocated with av_malloc() and friends.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @param buffer_size The buffer size is very important for performance.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      *        For protocols with fixed blocksize it should be set to this blocksize.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      *        For others a typical size is a cache page, e.g. 4kb.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @param write_flag Set to 1 if the buffer should be writable, 0 otherwise.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @param opaque An opaque pointer to user-specific data.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @param read_packet  A function for refilling the buffer, may be NULL.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @param write_packet A function for writing the buffer contents, may be NULL.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @param seek A function for seeking to specified byte position, may be NULL.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      *
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @return Allocated AVIOContext or NULL on failure.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      */
     </p>
     <p align="left">
      AVIOContext *avio_alloc_context(
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       unsigned
      </span>
      <span style="color:#0000FF;">
       char
      </span>
      *buffer,
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       int
      </span>
      buffer_size,
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       int
      </span>
      write_flag,
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       void
      </span>
      *opaque,
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       int
      </span>
      (*read_packet)(
      <span style="color:#0000FF;">
       void
      </span>
      *opaque, uint8_t *buf,
      <span style="color:#0000FF;">
       int
      </span>
      buf_size),
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       int
      </span>
      (*write_packet)(
      <span style="color:#0000FF;">
       void
      </span>
      *opaque, uint8_t *buf,
      <span style="color:#0000FF;">
       int
      </span>
      buf_size),
     </p>
     <p align="left">
      int64_t (*seek)(
      <span style="color:#0000FF;">
       void
      </span>
      *opaque, int64_t offset,
      <span style="color:#0000FF;">
       int
      </span>
      whence));
     </p>
     <p align="left">
      // 为I/0缓存申请并初始化一个AVIOContext结构,结束使用时必须使用av_free()进行释放
     </p>
     <p align="left">
      //
      <span style="color:#0000FF;">
       unsigned
      </span>
      <span style="color:#0000FF;">
       char
      </span>
      *buffer: 输入/输出缓存内存块,必须是使用av_malloc()分配的
     </p>
     <p align="left">
      //
      <span style="color:#0000FF;">
       int
      </span>
      buffer_size: 缓存大小是非常重要的
     </p>
     <p align="left">
      //
      <span style="color:#0000FF;">
       int
      </span>
      write_flag: 如果缓存为可写则设置为1,否则设置为0
     </p>
     <p align="left">
      //
      <span style="color:#0000FF;">
       void
      </span>
      *opaque: 指针,用于回调时使用
     </p>
     <p align="left">
      //
      <span style="color:#0000FF;">
       int
      </span>
      (*read_packet): 读包函数指针
     </p>
     <p align="left">
      //
      <span style="color:#0000FF;">
       int
      </span>
      (*write_packet): 写包函数指针
     </p>
     <p align="left">
      // int64_t (*seek): seek文件函数指针
     </p>
     <p align="left">
      <span style="font-size:18px;">
       <strong>
        8 av_open_input_file()
       </strong>
      </span>
     </p>
     <p align="left">
      <span style="color:#008000;">
       /**
      </span>
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * Open a media file as input. The codecs are not opened. Only the file
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * header (if present) is read.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      *
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @param ic_ptr The opened media file handle is put here.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @param filename filename to open
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @param fmt If non-NULL, force the file format to use.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @param buf_size optional buffer size (zero if default is OK)
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @param ap Additional parameters needed when opening the file
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      *           (NULL if default).
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @return 0 if OK, AVERROR_xxx otherwise
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      *
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @deprecated use avformat_open_input instead.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      */
     </p>
     <p align="left">
      attribute_deprecated
      <span style="color:#0000FF;">
       int
      </span>
      av_open_input_file(AVFormatContext **ic_ptr,
      <span style="color:#0000FF;">
       const
      </span>
      <span style="color:#0000FF;">
       char
      </span>
      *filename,
     </p>
     <p align="left">
      AVInputFormat *fmt,
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       int
      </span>
      buf_size,
     </p>
     <p align="left">
      AVFormatParameters *ap);
     </p>
     <p align="left">
     </p>
     <p align="left">
      // 以输入方式打开一个媒体文件,也即源文件,codecs并没有打开,只读取了文件的头信息.
     </p>
     <p align="left">
      // 引入头文件：
      <span style="color:#0000FF;">
       #include
      </span>
      <span style="color:#a31515;">
       "libavformat/avformat.h"
      </span>
     </p>
     <p align="left">
      <span style="color:#a31515;">
       <span style="color:#000000;">
        // AVFormatContext **ic_ptr 输入文件容器
       </span>
      </span>
     </p>
     <p align="left">
      <span style="color:#a31515;">
       <span style="color:#000000;">
        //
        <span style="color:#0000FF;">
         const
        </span>
        <span style="color:#0000FF;">
         char
        </span>
        *filename 输入文件名,全路径,并且保证文件存在
       </span>
      </span>
     </p>
     <p align="left">
      <span style="color:#a31515;">
       <span style="color:#000000;">
        // AVInputFormat *fmt 输入文件格式,填NULL即可
       </span>
      </span>
     </p>
     <p align="left">
      <span style="color:#a31515;">
       <span style="color:#000000;">
        //
       </span>
      </span>
      int buf_size,缓冲区大小,直接填0即可
     </p>
     <p align="left">
      <span style="color:#a31515;">
       <span style="color:#000000;">
        // AVFormatParameters *ap, 格式参数,添NULL即可
       </span>
      </span>
     </p>
     <p align="left">
      <span style="color:#a31515;">
       <span style="color:#000000;">
        // 成功返回0,其它失败
       </span>
      </span>
     </p>
     <p align="left">
      <span style="color:#a31515;">
       <span style="color:#000000;">
        // 不赞成使用 avformat_open_input 代替
       </span>
      </span>
     </p>
     <p align="left">
     </p>
     <p align="left">
      <span style="color:#a31515;">
       <span style="font-size:18px;color:#000000;">
        <strong>
         9 av_close_input_file()
        </strong>
       </span>
      </span>
     </p>
     <span style="color:#a31515;">
      <span style="color:#000000;">
       <span style="color:#008000;">
       </span>
      </span>
     </span>
     <p align="left">
      <span style="color:#008000;">
       /**
      </span>
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @deprecated use avformat_close_input()
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * Close a media file (but not its codecs).
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @param s media file handle
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      */
     </p>
     <p align="left">
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       void
      </span>
      av_close_input_file(AVFormatContext *s);
     </p>
     <p align="left">
      // 关闭使用avformat_close_input()打开的输入文件容器,但并不关系它的codecs
     </p>
     <p align="left">
      // 引入头文件：
      <span style="color:#0000FF;">
       #include
      </span>
      <span style="color:#a31515;">
       "libavformat/avformat.h"
      </span>
     </p>
     <p align="left">
      <span style="color:#a31515;">
       <span style="color:#000000;">
        // 使用av_open_input_file 打开的文件容器,可以使用该函数关闭
       </span>
      </span>
     </p>
     <p align="left">
      <span style="color:#a31515;">
       <span style="color:#000000;">
        // 使用 av_close_input_file 关闭后,就不再需要使用avformat_free_context 进行释放了
       </span>
      </span>
     </p>
     <p align="left">
     </p>
     <p align="left">
      <span style="color:#a31515;">
       <span style="font-size:18px;color:#000000;">
        <strong>
         10 av_find_stream_info()
        </strong>
       </span>
      </span>
     </p>
     <span style="color:#a31515;">
      <span style="color:#000000;">
      </span>
     </span>
     <p align="left">
      <span style="color:#008000;">
       /**
      </span>
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * Read packets of a media file to get stream information. This
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * is useful for file formats with no headers such as MPEG. This
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * function also computes the real framerate in case of MPEG-2 repeat
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * frame mode.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * The logical file position is not changed by this function;
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * examined packets may be buffered for later processing.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      *
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @param ic media file handle
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @return &gt;=0 if OK, AVERROR_xxx on error
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      * @todo Let the user decide somehow what information is needed so that
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      *       we do not waste time getting stuff the user does not need.
     </p>
     <p align="left">
      <span style="color:#008000;">
      </span>
      */
     </p>
     <p align="left">
      <span style="color:#0000FF;">
       int
      </span>
      av_find_stream_info(AVFormatContext *ic);
     </p>
     <p align="left">
      // 通过读取媒体文件的中的包来获取媒体文件中的流信息,对于没有头信息的文件如(mpeg)是非常有用的,
     </p>
     <p align="left">
      // 该函数通常重算类似mpeg-2帧模式的真实帧率,该函数并未改变逻辑文件的position.
     </p>
     <span style="color:#a31515;">
      <span style="color:#000000;">
      </span>
     </span>
     <p align="left">
      // 引入头文件：
      <span style="color:#0000FF;">
       #include
      </span>
      <span style="color:#a31515;">
       "libavformat/avformat.h"
      </span>
     </p>
     <p align="left">
      <span style="color:#a31515;">
       <span style="color:#000000;">
        // 也就是把媒体文件中的音视频流等信息读出来,保存在容器中,以便解码时使用
       </span>
      </span>
     </p>
     <p align="left">
      <span style="color:#a31515;">
       <span style="color:#000000;">
        // 返回&gt;=0时成功,否则失败
       </span>
      </span>
     </p>
     <p align="left">
      /***********************************************************/
     </p>
     <div>
      <span style="font-size:18px;">
       <strong>
        1 avcodec_find_decoder()
       </strong>
      </span>
     </div>
     <div>
      <p align="left">
       <span style="color:#008000;">
        /**
       </span>
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * Find a registered decoder with a matching codec ID.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param id CodecID of the requested decoder
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @return A decoder if one was found, NULL otherwise.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       */
      </p>
      <p align="left">
       AVCodec *avcodec_find_decoder(
       <span style="color:#0000FF;">
        enum
       </span>
       CodecID id);
      </p>
      <p align="left">
       // 通过code ID查找一个已经注册的音视频解码器
      </p>
      <p align="left">
       // 引入
       <span style="color:#0000FF;">
        #include
       </span>
       <span style="color:#a31515;">
        "libavcodec/avcodec.h"
       </span>
      </p>
      <p align="left">
       // 实现在: \ffmpeg\libavcodec\utils.c
      </p>
      <p align="left">
       // 查找解码器之前,必须先调用av_register_all注册所有支持的解码器
      </p>
      <p align="left">
       // 查找成功返回解码器指针,否则返回NULL
      </p>
      <p align="left">
       // 音视频解码器保存在一个链表中,查找过程中,函数从头到尾遍历链表,通过比较解码器的ID来查找
      </p>
      <p align="left">
      </p>
      <p align="left">
       <strong>
        <span style="font-size:16px;">
         2 avcodec_find_decoder_by_name()
        </span>
       </strong>
      </p>
      <p align="left">
       <span style="color:#008000;">
        /**
       </span>
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * Find a registered decoder with the specified name.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param name name of the requested decoder
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @return A decoder if one was found, NULL otherwise.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       */
      </p>
      <p align="left">
       AVCodec *avcodec_find_decoder_by_name(
       <span style="color:#0000FF;">
        const
       </span>
       <span style="color:#0000FF;">
        char
       </span>
       *name);
      </p>
      <p align="left">
       // 通过一个指定的名称查找一个已经注册的音视频解码器
      </p>
      <p align="left">
       // 引入
       <span style="color:#0000FF;">
        #include
       </span>
       <span style="color:#a31515;">
        "libavcodec/avcodec.h"
       </span>
      </p>
      <p align="left">
       // 实现在: \ffmpeg\libavcodec\utils.c
      </p>
      <p align="left">
       // 查找解码器之前,必须先调用av_register_all注册所有支持的解码器
      </p>
      <p align="left">
       // 查找成功返回解码器指针,否则返回NULL
      </p>
      <p align="left">
       // 音视频解码器保存在一个链表中,查找过程中,函数从头到尾遍历链表,通过比较解码器的name来查找
      </p>
      <p align="left">
      </p>
      <p align="left">
       <span style="font-size:18px;">
        <strong>
         3 avcodec_find_encoder()
        </strong>
       </span>
      </p>
      <p align="left">
       <span style="color:#008000;">
        /**
       </span>
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * Find a registered encoder with a matching codec ID.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param id CodecID of the requested encoder
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @return An encoder if one was found, NULL otherwise.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       */
      </p>
      <p align="left">
       AVCodec *avcodec_find_encoder(
       <span style="color:#0000FF;">
        enum
       </span>
       CodecID id);
      </p>
      <p align="left">
       // 通过code ID查找一个已经注册的音视频编码器
      </p>
      <p align="left">
       // 引入
       <span style="color:#0000FF;">
        #include
       </span>
       <span style="color:#a31515;">
        "libavcodec/avcodec.h"
       </span>
      </p>
     </div>
     <div>
      // 实现在: \ffmpeg\libavcodec\utils.c
     </div>
     <div>
      <p align="left">
       // 查找编码器之前,必须先调用av_register_all注册所有支持的编码器
      </p>
      <p align="left">
       // 查找成功返回编码器指针,否则返回NULL
      </p>
      <p align="left">
       // 音视频编码器保存在一个链表中,查找过程中,函数从头到尾遍历链表,通过比较编码器的ID来查找
      </p>
      <p align="left">
      </p>
     </div>
     <div>
      <strong>
       <span style="font-size:16px;">
        4 avcodec_find_encoder_by_name()
       </span>
      </strong>
     </div>
     <div>
      <p align="left">
       <span style="color:#008000;">
        /**
       </span>
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * Find a registered encoder with the specified name.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param name name of the requested encoder
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @return An encoder if one was found, NULL otherwise.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       */
      </p>
      <p align="left">
       AVCodec *avcodec_find_encoder_by_name(
       <span style="color:#0000FF;">
        const
       </span>
       <span style="color:#0000FF;">
        char
       </span>
       *name);
      </p>
     </div>
     <div>
      <p align="left">
       // 通过一个指定的名称查找一个已经注册的音视频编码器
      </p>
      <p align="left">
       // 引入
       <span style="color:#0000FF;">
        #include
       </span>
       <span style="color:#a31515;">
        "libavcodec/avcodec.h"
       </span>
      </p>
     </div>
     <div>
      // 实现在: \ffmpeg\libavcodec\utils.c
     </div>
     <div>
      <p align="left">
       // 查找编码器之前,必须先调用av_register_all注册所有支持的编码器
      </p>
      <p align="left">
       // 查找成功返回编码器指针,否则返回NULL
      </p>
      <p align="left">
       // 音视频编码器保存在一个链表中,查找过程中,函数从头到尾遍历链表,通过比较编码器的名称来查找
      </p>
      <p align="left">
      </p>
     </div>
     <div>
      <span style="font-size:18px;">
       <strong>
        5 avcodec_open()
       </strong>
      </span>
     </div>
     <div>
      <p align="left">
       <span style="color:#008000;">
        /**
       </span>
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * Initialize the AVCodecContext to use the given AVCodec. Prior to using this
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * function the context has to be allocated.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * retrieving a codec.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @warning This function is not thread safe!
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @code
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * avcodec_register_all();
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * codec = avcodec_find_decoder(CODEC_ID_H264);
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * if (!codec)
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *     exit(1);
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * context = avcodec_alloc_context();
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * if (avcodec_open(context, codec) &lt; 0)
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *     exit(1);
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @endcode
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param avctx The context which will be set up to use the given codec.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param codec The codec to use within the context.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @return zero on success, a negative value on error
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @see avcodec_alloc_context, avcodec_find_decoder, avcodec_find_encoder, avcodec_close
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       */
      </p>
      <p align="left">
       <span style="color:#0000FF;">
        int
       </span>
       avcodec_open(AVCodecContext *avctx, AVCodec *codec);
      </p>
      <p align="left">
       // 使用给定的AVCodec初始化AVCodecContext
      </p>
      <p align="left">
       // 引入
       <span style="color:#0000FF;">
        #include
       </span>
       <span style="color:#a31515;">
        "libavcodec/avcodec.h"
       </span>
      </p>
      <p align="left">
       // 方法: avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(), avcodec_find_decoder() and avcodec_find_encoder() 提供了快速获取一个codec的途径
      </p>
      <p align="left">
       // 该方法在编码和解码时都会用到
      </p>
      <p align="left">
       // 返回0时成功,打开作为输出时,参数设置不对的话,调用会失败
      </p>
     </div>
     <div>
     </div>
     <div>
      <span style="font-size:18px;">
       <strong>
        6 av_guess_format()
       </strong>
      </span>
     </div>
     <div>
      <p align="left">
       <span style="color:#008000;">
        /**
       </span>
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * Return the output format in the list of registered output formats
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * which best matches the provided parameters, or return NULL if
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * there is no match.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param short_name if non-NULL checks if short_name matches with the
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * names of the registered formats
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param filename if non-NULL checks if filename terminates with the
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * extensions of the registered formats
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param mime_type if non-NULL checks if mime_type matches with the
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * MIME type of the registered formats
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       */
      </p>
      <p align="left">
       AVOutputFormat *av_guess_format(
       <span style="color:#0000FF;">
        const
       </span>
       <span style="color:#0000FF;">
        char
       </span>
       *short_name,
      </p>
      <p align="left">
       <span style="color:#0000FF;">
        const
       </span>
       <span style="color:#0000FF;">
        char
       </span>
       *filename,
      </p>
      <p align="left">
       <span style="color:#0000FF;">
        const
       </span>
       <span style="color:#0000FF;">
        char
       </span>
       *mime_type);
      </p>
      <p align="left">
       // 返回一个已经注册的最合适的输出格式
      </p>
      <p align="left">
       // 引入
       <span style="color:#0000FF;">
        #include
       </span>
       <span style="color:#a31515;">
        "libavformat/avformat.h"
       </span>
      </p>
      <p align="left">
       // 可以通过
       <span style="color:#0000FF;">
        const
       </span>
       <span style="color:#0000FF;">
        char
       </span>
       *short_name 获取,如"mpeg"
      </p>
      <p align="left">
       // 也可以通过
       <span style="color:#0000FF;">
        const
       </span>
       <span style="color:#0000FF;">
        char
       </span>
       *filename 获取,如"E:\a.mp4"
      </p>
      <p align="left">
      </p>
      <p align="left">
       <span style="font-size:18px;">
        <strong>
         7 av_new_stream()
        </strong>
       </span>
      </p>
      <p align="left">
       <span style="color:#008000;">
        /**
       </span>
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * Add a new stream to a media file.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * Can only be called in the read_header() function. If the flag
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * AVFMTCTX_NOHEADER is in the format context, then new streams
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * can be added in read_packet too.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param s media file handle
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param id file-format-dependent stream ID
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       */
      </p>
      <p align="left">
       AVStream *av_new_stream(AVFormatContext *s,
       <span style="color:#0000FF;">
        int
       </span>
       id);
      </p>
      <p align="left">
       // 为媒体文件添加一个流,一般为作为输出的媒体文件容器添加音视频流
      </p>
      <p align="left">
       // 引入
       <span style="color:#0000FF;">
        #include
       </span>
       <span style="color:#a31515;">
        "libavformat/avformat.h"
       </span>
      </p>
      <p align="left">
       // 再打开源文件时用户一般不需要直接调用该方法
      </p>
     </div>
     <div>
     </div>
     <div>
      <span style="font-size:18px;">
       <strong>
        8 dump_format()
       </strong>
      </span>
     </div>
     <div>
      <p align="left">
       <span style="color:#0000FF;">
        #if
       </span>
       FF_API_DUMP_FORMAT
      </p>
      <p align="left">
       <span style="color:#008000;">
        /**
       </span>
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @deprecated Deprecated in favor of av_dump_format().
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       */
      </p>
      <p align="left">
       attribute_deprecated
       <span style="color:#0000FF;">
        void
       </span>
       dump_format(AVFormatContext *ic,
      </p>
      <p align="left">
       <span style="color:#0000FF;">
        int
       </span>
       index,
      </p>
      <p align="left">
       <span style="color:#0000FF;">
        const
       </span>
       <span style="color:#0000FF;">
        char
       </span>
       *url,
      </p>
      <p align="left">
       <span style="color:#0000FF;">
        int
       </span>
       is_output);
      </p>
      <p align="left">
       <span style="color:#0000FF;">
        #endif
       </span>
      </p>
     </div>
     <div>
      // 该函数的作用就是检查下初始化过程中设置的参数是否符合规范
     </div>
     <div>
      // 有些版本中为 av_
      <span style="font-family:'新宋体';">
       dump_format
      </span>
     </div>
     <div>
     </div>
     <div>
      <span style="font-family:'新宋体';font-size:18px;">
       <strong>
        9 av_set_parameters()
       </strong>
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
      </span>
      <p align="left">
       <span style="color:#0000FF;">
        #if
       </span>
       FF_API_FORMAT_PARAMETERS
      </p>
      <p align="left">
       <span style="color:#008000;">
        /**
       </span>
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @deprecated pass the options to avformat_write_header directly.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       */
      </p>
      <p align="left">
       attribute_deprecated
       <span style="color:#0000FF;">
        int
       </span>
       av_set_parameters(AVFormatContext *s, AVFormatParameters *ap);
      </p>
      <span style="color:#0000FF;">
       #endif
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
       // 设置初始化参数
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
       // 不赞成跳过该方法,直接调用 avformat_write_header/av_write_header
      </span>
     </div>
     <div>
     </div>
     <div>
      <span style="font-family:'新宋体';font-size:18px;">
       <strong>
        10 av_write_header()
       </strong>
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
      </span>
      <p align="left">
       <span style="color:#0000FF;">
        #if
       </span>
       FF_API_FORMAT_PARAMETERS
      </p>
      <p align="left">
       <span style="color:#008000;">
        /**
       </span>
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * Allocate the stream private data and write the stream header to an
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * output media file.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @note: this sets stream time-bases, if possible to stream-&gt;codec-&gt;time_base
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * but for some formats it might also be some other time base
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param s media file handle
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @return 0 if OK, AVERROR_xxx on error
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @deprecated use avformat_write_header.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       */
      </p>
      <p align="left">
       attribute_deprecated
       <span style="color:#0000FF;">
        int
       </span>
       av_write_header(AVFormatContext *s);
      </p>
      <p align="left">
       <span style="color:#0000FF;">
        #endif
       </span>
      </p>
     </div>
     <div>
      <span style="font-family:'新宋体';">
       // 把流头信息写入到媒体文件中
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
       // 返回0成功
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
      </span>
     </div>
     <p align="left">
      /**********************************************************/
     </p>
     <div>
      <span style="font-size:18px;">
       <strong>
        1 AVPacket
       </strong>
      </span>
     </div>
     <div>
      <p align="left">
       <span style="color:#0000FF;">
        typedef
       </span>
       <span style="color:#0000FF;">
        struct
       </span>
       AVPacket {
      </p>
      <p align="left">
       <span style="color:#008000;">
        /**
       </span>
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * Presentation timestamp in AVStream-&gt;time_base units; the time at which
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * the decompressed packet will be presented to the user.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * Can be AV_NOPTS_VALUE if it is not stored in the file.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * pts MUST be larger or equal to dts as presentation cannot happen before
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * decompression, unless one wants to view hex dumps. Some formats misuse
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * the terms dts and pts/cts to mean something different. Such timestamps
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * must be converted to true pts/dts before they are stored in AVPacket.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       */
      </p>
      <p align="left">
       int64_t pts;
      </p>
      <p align="left">
       <span style="color:#008000;">
        /**
       </span>
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * Decompression timestamp in AVStream-&gt;time_base units; the time at which
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * the packet is decompressed.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * Can be AV_NOPTS_VALUE if it is not stored in the file.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       */
      </p>
      <p align="left">
       int64_t dts;
      </p>
      <p align="left">
       uint8_t *data;
      </p>
      <p align="left">
       <span style="color:#0000FF;">
        int
       </span>
       size;
      </p>
      <p align="left">
       <span style="color:#0000FF;">
        int
       </span>
       stream_index;
      </p>
      <p align="left">
       <span style="color:#0000FF;">
        int
       </span>
       flags;
      </p>
      <p align="left">
      </p>
      <p align="left">
       <span style="color:#0000FF;">
        int
       </span>
       duration;
      </p>
      <p align="left">
       .
      </p>
      <p align="left">
       .
      </p>
      <p align="left">
       .
      </p>
      <p align="left">
       } AVPacket
      </p>
     </div>
     <div>
      //
      <span style="font-family:'新宋体';">
       AVPacket是个很重要的结构,该结构在读媒体源文件和写输出文件时都需要用到
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
       // int64_t pts; 显示时间戳
      </span>
     </div>
     <div>
      //
      <span style="font-family:'新宋体';">
       int64_t dts; 解码时间戳
      </span>
     </div>
     <div>
      //
      <span style="font-family:'新宋体';">
       uint8_t *data; 包数据
      </span>
     </div>
     <div>
      //
      <span style="font-family:'新宋体';">
       <span style="color:#0000FF;">
        int
       </span>
       size; 包数据长度
      </span>
     </div>
     <div>
      //
      <span style="font-family:'新宋体';">
       <span style="color:#0000FF;">
        int
       </span>
       stream_index; 包所属流序号
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
       //
       <span style="color:#0000FF;">
        int
       </span>
       duration; 时长
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
       // 以上信息,如果是在读媒体源文件那么avcodec会初始化,如果是输出文件,用户需要对以上信息赋值
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';font-size:18px;">
       <strong>
        2 av_init_packet()
       </strong>
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
      </span>
      <p align="left">
       <span style="color:#008000;">
        /**
       </span>
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * Initialize optional fields of a packet with default values.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param pkt packet
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       */
      </p>
      <p align="left">
       <span style="color:#0000FF;">
        void
       </span>
       av_init_packet(AVPacket *pkt);
      </p>
     </div>
     <div>
      <span style="font-family:'新宋体';">
       // 使用默认值初始化AVPacket
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
       // 定义AVPacket对象后,请使用av_init_packet进行初始化
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';font-size:18px;">
       <strong>
        3 av_free_packet()
       </strong>
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
      </span>
      <p align="left">
       <span style="color:#008000;">
        /**
       </span>
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * Free a packet.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param pkt packet to free
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       */
      </p>
      <p align="left">
       <span style="color:#0000FF;">
        void
       </span>
       av_free_packet(AVPacket *pkt);
      </p>
     </div>
     <div>
      <span style="font-family:'新宋体';">
       // 释放AVPacket对象
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
       <strong>
        4
        <span style="font-size:18px;">
         av_read_frame()
        </span>
       </strong>
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
      </span>
      <p align="left">
       <span style="color:#008000;">
        /**
       </span>
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * Return the next frame of a stream.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * This function returns what is stored in the file, and does not validate
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * that what is there are valid frames for the decoder. It will split what is
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * stored in the file into frames and return one for each call. It will not
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * omit invalid data between valid frames so as to give the decoder the maximum
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * information possible for decoding.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * The returned packet is valid
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * until the next av_read_frame() or until av_close_input_file() and
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * must be freed with av_free_packet. For video, the packet contains
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * exactly one frame. For audio, it contains an integer number of
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * frames if each frame has a known fixed size (e.g. PCM or ADPCM
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * data). If the audio frames have a variable size (e.g. MPEG audio),
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * then it contains one frame.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * pkt-&gt;pts, pkt-&gt;dts and pkt-&gt;duration are always set to correct
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * values in AVStream.time_base units (and guessed if the format cannot
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * provide them). pkt-&gt;pts can be AV_NOPTS_VALUE if the video format
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * has B-frames, so it is better to rely on pkt-&gt;dts if you do not
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * decompress the payload.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @return 0 if OK, &lt; 0 on error or end of file
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       */
      </p>
      <p align="left">
       <span style="color:#0000FF;">
        int
       </span>
       av_read_frame(AVFormatContext *s, AVPacket *pkt);
      </p>
      <p align="left">
       // 从输入源文件容器中读取一个AVPacket数据包
      </p>
      <p align="left">
       // 该函数读出的包并不每次都是有效的,对于读出的包我们都应该进行相应的解码(视频解码/音频解码),
      </p>
     </div>
     <div>
      <span style="font-family:'新宋体';">
       // 在返回值&gt;=0时,循环调用该函数进行读取,循环调用之前请调用av_free_packet函数清理AVPacket
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
       <strong>
        5
        <span style="font-size:18px;">
         avcodec_decode_video2()
        </span>
       </strong>
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
      </span>
      <p align="left">
       <span style="color:#008000;">
        /**
       </span>
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * Decode the video frame of size avpkt-&gt;size from avpkt-&gt;data into picture.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * Some decoders may support multiple frames in a single AVPacket, such
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * decoders would then just decode the first frame.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @warning The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger than
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * the actual read bytes because some optimized bitstream readers read 32 or 64
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * bits at once and could read over the end.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @warning The end of the input buffer buf should be set to 0 to ensure that
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * no overreading happens for damaged MPEG streams.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @note You might have to align the input buffer avpkt-&gt;data.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * The alignment requirements depend on the CPU: on some CPUs it isn't
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * necessary at all, on others it won't work at all if not aligned and on others
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * it will work but it will have an impact on performance.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * In practice, avpkt-&gt;data should have 4 byte alignment at minimum.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @note Some codecs have a delay between input and output, these need to be
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * fed with avpkt-&gt;data=NULL, avpkt-&gt;size=0 at the end to return the remaining frames.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param avctx the codec context
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param[out] picture The AVFrame in which the decoded video frame will be stored.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *             Use avcodec_alloc_frame to get an AVFrame, the codec will
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *             allocate memory for the actual bitmap.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *             with default get/release_buffer(), the decoder frees/reuses the bitmap as it sees fit.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *             with overridden get/release_buffer() (needs CODEC_CAP_DR1) the user decides into what buffer the decoder
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *                   decodes and the decoder tells the user once it does not need the data anymore,
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *                   the user app can at this point free/reuse/keep the memory as it sees fit.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param[in] avpkt The input AVpacket containing the input buffer.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *            You can create such packet with av_init_packet() and by then setting
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *            data and size, some decoders might in addition need other fields like
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *            flags&amp;AV_PKT_FLAG_KEY. All decoders are designed to use the least
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *            fields possible.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @return On error a negative value is returned, otherwise the number of bytes
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * used or zero if no frame could be decompressed.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       */
      </p>
      <p align="left">
       <span style="color:#0000FF;">
        int
       </span>
       avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,
      </p>
      <p align="left">
       <span style="color:#0000FF;">
        int
       </span>
       *got_picture_ptr,
      </p>
      <p align="left">
       AVPacket *avpkt);
      </p>
     </div>
     <div>
      <span style="font-family:'新宋体';">
       // 解码视频流AVPacket
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
       // 使用av_read_frame读取媒体流后需要进行判断,如果为视频流则调用该函数解码
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
       // 返回结果&lt;0时失败,此时程序应该退出检查原因
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
       // 返回&gt;=0时正常,假设 读取包为:AVPacket vPacket 返回值为 int vLen; 每次解码正常时,对vPacket做
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
       // 如下处理:
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
       //
      </span>
      <span style="font-family:'新宋体';">
       vPacket.size -= vLen;
       <br/>
       //   vPacket.data += vLen;
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
       // 如果 vPacket.size==0,则继续读下一流包,否则继续调度该方法进行解码,直到vPacket.size==0
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
       // 返回 got_picture_ptr &gt; 0 时,表示解码到了AVFrame *picture,其后可以对picture进程处理
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';font-size:18px;">
       6
       <strong>
        avcodec_decode_audio3()
       </strong>
      </span>
     </div>
     <div>
      <span style="font-family:'新宋体';">
      </span>
      <p align="left">
       <span style="color:#008000;">
        /**
       </span>
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * Decode the audio frame of size avpkt-&gt;size from avpkt-&gt;data into samples.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * Some decoders may support multiple frames in a single AVPacket, such
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * decoders would then just decode the first frame. In this case,
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * avcodec_decode_audio3 has to be called again with an AVPacket that contains
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * the remaining data in order to decode the second frame etc.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * If no frame
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * could be outputted, frame_size_ptr is zero. Otherwise, it is the
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * decompressed frame size in bytes.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @warning You must set frame_size_ptr to the allocated size of the
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * output buffer before calling avcodec_decode_audio3().
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @warning The input buffer must be FF_INPUT_BUFFER_PADDING_SIZE larger than
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * the actual read bytes because some optimized bitstream readers read 32 or 64
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * bits at once and could read over the end.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @warning The end of the input buffer avpkt-&gt;data should be set to 0 to ensure that
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * no overreading happens for damaged MPEG streams.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @note You might have to align the input buffer avpkt-&gt;data and output buffer
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * samples. The alignment requirements depend on the CPU: On some CPUs it isn't
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * necessary at all, on others it won't work at all if not aligned and on others
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * it will work but it will have an impact on performance.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * In practice, avpkt-&gt;data should have 4 byte alignment at minimum and
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * samples should be 16 byte aligned unless the CPU doesn't need it
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * (AltiVec and SSE do).
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param avctx the codec context
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param[out] samples the output buffer, sample type in avctx-&gt;sample_fmt
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param[in,out] frame_size_ptr the output buffer size in bytes
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @param[in] avpkt The input AVPacket containing the input buffer.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *            You can create such packet with av_init_packet() and by then setting
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *            data and size, some decoders might in addition need other fields.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       *            All decoders are designed to use the least fields possible though.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * @return On error a negative value is returned, otherwise the number of bytes
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       * used or zero if no frame data was decompressed (used) from the input AVPacket.
      </p>
      <p align="left">
       <span style="color:#008000;">
       </span>
       */
      </p>
      <p align="left">
       <span style="color:#0000FF;">
        int
       </span>
       avcodec_decode_audio3(AVCodecContext *avctx, int16_t *samples,
      </p>
      <p align="left">
       <span style="color:#0000FF;">
        int
       </span>
       *frame_size_ptr,
      </p>
      <p align="left">
       AVPacket *avpkt);
      </p>
     </div>
     <div>
      <span style="font-family:'新宋体';">
      </span>
      <div>
       <span style="font-family:'新宋体';">
        // 解码音频流AVPacket
       </span>
      </div>
      <div>
       <span style="font-family:'新宋体';">
        // 使用av_read_frame读取媒体流后需要进行判断,如果为音频流则调用该函数解码
       </span>
      </div>
      <div>
       <span style="font-family:'新宋体';">
        // 返回结果&lt;0时失败,此时程序应该退出检查原因
       </span>
      </div>
      <div>
       <span style="font-family:'新宋体';">
        // 返回&gt;=0时正常,假设 读取包为:AVPacket vPacket 返回值为 int vLen; 每次解码正常时,对vPacket做
       </span>
      </div>
      <div>
       <span style="font-family:'新宋体';">
        // 如下处理:
       </span>
      </div>
      <div>
       <span style="font-family:'新宋体';">
        //
       </span>
       <span style="font-family:'新宋体';">
        vPacket.size -= vLen;
        <br/>
        //   vPacket.data += vLen;
       </span>
      </div>
      <div>
       <span style="font-family:'新宋体';">
        // 如果 vPacket.size==0,则继续读下一流包,否则继续调度该方法进行解码,直到vPacket.size==0
       </span>
      </div>
      <div>
       <span style="font-family:'新宋体';">
       </span>
      </div>
      <div>
       <span style="font-family:'新宋体';">
        转自：
        <a href="http://blog.chinaunix.net/uid/20718335/frmd/153034.html">
         http://blog.chinaunix.net/uid/20718335/frmd/153034.html
        </a>
       </span>
      </div>
     </div>
    </div>
    <br/>
   </div>
  </div>
  <div style="display:none;" class="hide-article-box text-center csdn-tracking-statistics tracking-click" data-mod="popu_376">
   <a class="btn btn-red-hollow" id="btn-readmore">
    阅读更多
   </a>
  </div>
 </article>
 <div class="article-bar-bottom">
  <div class="tags-box artic-tag-box">
   <span class="label">
    文章标签：
   </span>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=ffmpeg&amp;t=blog" target="_blank">
    ffmpeg
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=函数&amp;t=blog" target="_blank">
    函数
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=介绍&amp;t=blog" target="_blank">
    介绍
   </a>
  </div>
  <div class="tags-box">
   <span class="label">
    个人分类：
   </span>
   <a class="tag-link" href="https://blog.csdn.net/leixiaohua1020/article/category/1360795" target="_blank">
    FFMPEG
   </a>
  </div>
  <div class="tags-box">
   <span class="label">
    所属专栏：
   </span>
   <a class="tag-link" href="https://blog.csdn.net/column/details/ffmpeg-devel.html" target="_blank">
    FFmpeg
   </a>
  </div>
 </div>
 <!-- !empty($pre_next_article[0]) -->
</div>
<div class="recommend-box">
                            <div style="background: #fff; border: dashed 1px #666; padding-left: 1em; padding-top: 1em; padding-bottom: 1em;">
                                <span style="font-size: 0.8em; font-weight: bold;">
                                    此PDF由<a style="color:#0000ff" href="http://www.github.com/spygg"  target="_blank">spygg</a>生成,请尊重原作者版权!!!
                                    <br/>
                                    我的邮箱:liushidc@163.com
                                </span>
                                </div> 
                        </div>
                    </main>
      
                </div>

            <script>
                var recommendCount = 0;
                var articleTit = "";
                var articleId = "";
                var commentscount = 0;

                //1禁止评论，2正常
                var commentAuth = 1;
                //百度搜索
                var baiduKey = "";
                var needInsertBaidu = "";
            </script>
            <script src="https://csdnimg.cn/release/phoenix/template/js/detail-effe72036e.min.js"></script>
            </body>
        </html>