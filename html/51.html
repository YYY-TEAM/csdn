
            <!DOCTYPE html>
            <html lang="zh-CN">
                <head>
                    <meta charset="UTF-8">
                    <title>
 FFmpeg的HEVC解码器源代码简单分析：解析器（Parser）部分 - CSDN博客
</title>

                <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-60a2c245da.min.css">
                <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-88717cedf2.min.css">

                <script type="text/javascript">
                var username = "";
                </script>

                <script src="https://csdnimg.cn/public/common/libs/jquery/jquery-1.9.1.min.js" type="text/javascript"></script>

                <!-- 新版上报 -->
                <!-- 新版上报end -->
                <link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.3/css/sandalstrap.min.css"> 
                </head>
                <body>    
        
                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
                    <div class="container clearfix pt0" id="mainBox">
        <main style="width: 100%;"><div class="blog-content-box">
 <div class="article-title-box" id="article_anchors_51">
  <span class="article-type type-1 float-left">
   原
  </span>
  <h1 class="title-article">
   FFmpeg的HEVC解码器源代码简单分析：解析器（Parser）部分
  </h1>
 </div>
 <div class="article-info-box">
  <div class="article-bar-top d-flex">
   <span class="time">
    2015年06月09日 23:19:48
   </span>
   <div ">
    <span class="read-count">
     阅读数：13199
    </span>
   </div>
  </div>
 </div>
 <article>
  <div class="article_content clearfix csdn-tracking-statistics" data-dsm="post" data-mod="popu_307" data-pid="blog" id="article_content">
   <link href="https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css" rel="stylesheet"/>
   <div class="htmledit_views">
    <p>
     <span style="white-space:pre;">
     </span>
    </p>
    <p>
     =====================================================
    </p>
    <p>
     HEVC源代码分析文章列表：
    </p>
    <p>
     【解码 -libavcodec HEVC 解码器】
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/46412023">
      FFmpeg的HEVC解码器源代码简单分析：概述
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/46412607">
      FFmpeg的HEVC解码器源代码简单分析：解析器（Parser）部分
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/46412897">
      FFmpeg的HEVC解码器源代码简单分析：解码器主干部分
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/46414483">
      FFmpeg的HEVC解码器源代码简单分析：CTU解码（CTU Decode）部分-PU
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/46451119">
      FFmpeg的HEVC解码器源代码简单分析：CTU解码（CTU Decode）部分-TU
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/46483721">
      FFmpeg的HEVC解码器源代码简单分析：环路滤波（LoopFilter）
     </a>
    </p>
    <p>
     =====================================================
    </p>
    <br/>
    <p>
     <span style="white-space:pre;">
     </span>
     上篇文章概述了FFmpeg的libavcodec中HEVC（H.265）解码器的结构；从这篇文章开始，具体研究HEVC解码器的源代码。本文分析HEVC解码器中解析器（Parser）部分的源代码。这部分的代码用于分割HEVC的NALU，并且解析SPS、PPS、SEI等信息。解析HEVC码流（对应AVCodecParser结构体中的函数）和解码HEVC码流（对应AVCodec结构体中的函数）的时候都会调用该部分的代码完成相应的功能。
    </p>
    <p>
     <br/>
    </p>
    <h2>
     函数调用关系图
    </h2>
    <p>
     FFmpeg HEVC解析器（Parser）部分在整个HEVC解码器中的位置如下图所示。
    </p>
    <p style="text-align:center;">
     <a href="http://img.my.csdn.net/uploads/201506/08/1433745138_2962.png">
      <img alt="" src="https://img-blog.csdn.net/20150608145347835"/>
     </a>
     <br/>
    </p>
    <div style="text-align:center;">
     <a href="https://my.csdn.net/leixiaohua1020/album/detail/1809621">
      单击查看更清晰的大图
     </a>
    </div>
    <br/>
    <p>
     HEVC解析器（Parser）部分的源代码的调用关系如下图所示。
    </p>
    <p style="text-align:center;">
     <a href="http://img.my.csdn.net/uploads/201506/08/1433746581_8304.png">
      <img alt="" src="https://img-blog.csdn.net/20150608145301041"/>
     </a>
     <br/>
    </p>
    <div style="text-align:center;">
     <a href="https://my.csdn.net/leixiaohua1020/album/detail/1809623">
      单击查看更清晰的大图
     </a>
    </div>
    <p>
     <br/>
    </p>
    从图中可以看出，HEVC解析器调用了parse_nal_units()，HEVC解码器调用了decode_nal_units()，而上述两个函数都调用了下面几个解析函数：
    <br/>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
     ff_hevc_decode_nal_vps()：解析VPS。
     <br/>
     ff_hevc_decode_nal_sps()：解析SPS。
     <br/>
     ff_hevc_decode_nal_pps()：解析PPS。
     <br/>
     ff_hevc_decode_nal_sei()：解析SEI。
    </blockquote>
    下文将会分别这几个函数。
    <br/>
    <br/>
    <h2>
     ff_hevc_decoder
    </h2>
    ff_hevc_decoder是HEVC解码器对应的AVCodec结构体。该结构体的定义位于libavcodec\hevc.c，如下所示。
    <br/>
    <pre class="cpp">AVCodec ff_hevc_decoder = {
    .name                  = "hevc",
    .long_name             = NULL_IF_CONFIG_SMALL("HEVC (High Efficiency Video Coding)"),
    .type                  = AVMEDIA_TYPE_VIDEO,
    .id                    = AV_CODEC_ID_HEVC,
    .priv_data_size        = sizeof(HEVCContext),
    .priv_class            = &amp;hevc_decoder_class,
    .init                  = hevc_decode_init,
    .close                 = hevc_decode_free,
    .decode                = hevc_decode_frame,
    .flush                 = hevc_decode_flush,
    .update_thread_context = hevc_update_thread_context,
    .init_thread_copy      = hevc_init_thread_copy,
    .capabilities          = CODEC_CAP_DR1 | CODEC_CAP_DELAY |
                             CODEC_CAP_SLICE_THREADS | CODEC_CAP_FRAME_THREADS,
    .profiles              = NULL_IF_CONFIG_SMALL(profiles),
};</pre>
    从源代码中可以看出，HEVC解码器的解码函数是hevc_decode_frame()。由于本文主要分析HEVC解析器，所以不对解码函数进行分析。在这里只需要知道hevc_decode_frame()调用了decode_nal_units()，而decode_nal_units()最终调用了ff_hevc_decode_nal_sps()等解析函数即可。
    <br/>
    <br/>
    <h2>
     ff_hevc_parser
    </h2>
    ff_hevc_parser是HEVC解析器对应的AVCodecParser结构体。该结构体的定义位于libavcodec\hevc_parser.c，如下所示。
    <br/>
    <pre class="cpp">AVCodecParser ff_hevc_parser = {
    .codec_ids      = { AV_CODEC_ID_HEVC },
    .priv_data_size = sizeof(HEVCParseContext),
    .parser_init    = hevc_init,
    .parser_parse   = hevc_parse,
    .parser_close   = hevc_close,
    .split          = hevc_split,
};</pre>
    从源代码可以看出，HEVC解析器的初始化函数是hevc_init()，解析函数是hevc_parse()，关闭函数是hevc_close()。
    <br/>
    <br/>
    <h2>
     hevc_init()
    </h2>
    hevc_init()是HEVC解析器的初始化函数，该函数的定义如下所示。
    <br/>
    <pre class="cpp">static int hevc_init(AVCodecParserContext *s)
{
    HEVCContext  *h  = &amp;((HEVCParseContext *)s-&gt;priv_data)-&gt;h;
    h-&gt;HEVClc = av_mallocz(sizeof(HEVCLocalContext));
    h-&gt;skipped_bytes_pos_size = INT_MAX;

    return 0;
}</pre>
    可以看出hevc_init()简单地给内部成员变量分配了内存。
    <br/>
    <br/>
    <h2>
     hevc_close()
    </h2>
    hevc_close()是HEVC解析器的关闭函数，该函数的定义如下所示。
    <br/>
    <pre class="cpp">static void hevc_close(AVCodecParserContext *s)
{
    int i;
    HEVCContext  *h  = &amp;((HEVCParseContext *)s-&gt;priv_data)-&gt;h;
    ParseContext *pc = &amp;((HEVCParseContext *)s-&gt;priv_data)-&gt;pc;

    av_freep(&amp;h-&gt;skipped_bytes_pos);
    av_freep(&amp;h-&gt;HEVClc);
    av_freep(&amp;pc-&gt;buffer);

    for (i = 0; i &lt; FF_ARRAY_ELEMS(h-&gt;vps_list); i++)
        av_buffer_unref(&amp;h-&gt;vps_list[i]);
    for (i = 0; i &lt; FF_ARRAY_ELEMS(h-&gt;sps_list); i++)
        av_buffer_unref(&amp;h-&gt;sps_list[i]);
    for (i = 0; i &lt; FF_ARRAY_ELEMS(h-&gt;pps_list); i++)
        av_buffer_unref(&amp;h-&gt;pps_list[i]);

    av_buffer_unref(&amp;h-&gt;current_sps);
    h-&gt;sps = NULL;

    for (i = 0; i &lt; h-&gt;nals_allocated; i++)
        av_freep(&amp;h-&gt;nals[i].rbsp_buffer);
    av_freep(&amp;h-&gt;nals);
    h-&gt;nals_allocated = 0;
}</pre>
    可以看出hevc_close()释放了内部成员变量的内存。
    <br/>
    <br/>
    <h2>
     hevc_parse()
    </h2>
    hevc_parse()是HEVC解析器中最关键的解析函数。该函数的定义如下所示。
    <br/>
    <pre class="cpp">/*
 * 解析码流
 *
 * 注释：雷霄骅
 * leixiaohua1020@126.com
 * http://blog.csdn.net/leixiaohua1020
 */
static int hevc_parse(AVCodecParserContext *s,
                      AVCodecContext *avctx,
                      const uint8_t **poutbuf, int *poutbuf_size,
                      const uint8_t *buf, int buf_size)
{
    int next;
    ParseContext *pc = &amp;((HEVCParseContext *)s-&gt;priv_data)-&gt;pc;
    //PARSER_FLAG_COMPLETE_FRAMES为1的时候说明传入的就是完整的1帧数据
    //这时候不用再分割NALU
    //PARSER_FLAG_COMPLETE_FRAMES为0的时候说明传入的是任意一段数据
    //需要先分离出完整的NALU
    if (s-&gt;flags &amp; PARSER_FLAG_COMPLETE_FRAMES) {
        next = buf_size;
    } else {
    	//分割NALU
    	//通过查找起始码0x000001的方法
        next = hevc_find_frame_end(s, buf, buf_size);
        //合并
        if (ff_combine_frame(pc, next, &amp;buf, &amp;buf_size) &lt; 0) {
            *poutbuf      = NULL;
            *poutbuf_size = 0;
            return buf_size;
        }
    }
    //解析NALU内容（不解码）
    parse_nal_units(s, avctx, buf, buf_size);

    *poutbuf      = buf;
    *poutbuf_size = buf_size;
    return next;
}
</pre>
    <br/>
    从源代码可以看出，hevc_parse()主要做了两步工作：
    <br/>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
     （1）判断传入的flags 中是否包含PARSER_FLAG_COMPLETE_FRAMES。如果包含，则说明传入的是完整的一帧数据，不作任何处理；如果不包含，则说明传入的不是完整的一帧数据而是任意一段HEVC数据，则需要调用hevc_find_frame_end()通过查找“起始码”（0x00000001或者0x000001）的方法，分离出完整的一帧数据。
     <br/>
     （2）调用parse_nal_units()完成了NALU的解析工作。
    </blockquote>
    下面分别看一下这两步中的两个函数。
    <br/>
    <br/>
    <h2>
     hevc_find_frame_end()
    </h2>
    hevc_find_frame_end()用于从HEVC码流中分离出完整的NALU。该函数的定义位于libavcodec\hevc_parser.c，如下所示。
    <br/>
    <pre class="cpp">/**
 * Find the end of the current frame in the bitstream.
 * @return the position of the first byte of the next frame, or END_NOT_FOUND
 */
//分割NALU
static int hevc_find_frame_end(AVCodecParserContext *s, const uint8_t *buf,
                               int buf_size)
{
    int i;
    ParseContext *pc = &amp;((HEVCParseContext *)s-&gt;priv_data)-&gt;pc;
    //一个一个字节进行处理
    for (i = 0; i &lt; buf_size; i++) {
        int nut;
        //state64可以存8个字节
        //buf[i]存入state64
        pc-&gt;state64 = (pc-&gt;state64 &lt;&lt; 8) | buf[i];

        //起始码定义#define START_CODE 0x000001
        //state64右移24bit之后，再对比是否为起始码0x000001
        if (((pc-&gt;state64 &gt;&gt; 3 * 8) &amp; 0xFFFFFF) != START_CODE)
            continue;
        //找到起始码之后
        /*
         * 此时state64内容如下：
         *               |      Start Code    | NALU Header |
         * |------|------|------|------|------|------|------|------|
         *
         *               |  buf |  buf |  buf |  buf |  buf | buf  |
         *               | [t-5]| [t-4]| [t-3]| [t-2]| [t-1]|  [t] |
         *
         * Start Code:
         * 0x000001
         *
         * NALU Header:
         * forbidden_zero_bit: 1bit。取值0。
         * nal_unit_type: 6 bit。NALU类型。
         * nuh_layer_id: 6 bit。目前取值为0（保留以后使用）.
         * nuh_temporal_id_plus1: 3 bit。减1后为NALU时域层标识号TemporalID。
         *
         */
        //state64右移16bit之后，state64最低字节为起始码后面的1Byte。即为NALU Header的前一个字节
        //NALU Header的前一个字节中，第1bit为forbidden_zero_bit，取值为0；
        //2-7bit为nal_unit_type；第8bit为nuh_layer_id，取值为0。

        //在这里state64右移(16+1)bit，然后相与0x3F(00111111)
        //即得到了nal_unit_type
        nut = (pc-&gt;state64 &gt;&gt; 2 * 8 + 1) &amp; 0x3F;

        // Beginning of access unit
        if ((nut &gt;= NAL_VPS &amp;&amp; nut &lt;= NAL_AUD) || nut == NAL_SEI_PREFIX ||
            (nut &gt;= 41 &amp;&amp; nut &lt;= 44) || (nut &gt;= 48 &amp;&amp; nut &lt;= 55)) {
            if (pc-&gt;frame_start_found) {
                pc-&gt;frame_start_found = 0;
                //返回起始码开始位置
                return i - 5;
            }
        } else if (nut &lt;= NAL_RASL_R ||
                   (nut &gt;= NAL_BLA_W_LP &amp;&amp; nut &lt;= NAL_CRA_NUT)) {
            int first_slice_segment_in_pic_flag = buf[i] &gt;&gt; 7;
            if (first_slice_segment_in_pic_flag) {
                if (!pc-&gt;frame_start_found) {
                    pc-&gt;frame_start_found = 1;
                } else { // First slice of next frame found
                    pc-&gt;frame_start_found = 0;
                    //返回起始码开始位置
                    return i - 5;
                }
            }
        }
    }

    return END_NOT_FOUND;
}
</pre>
    <br/>
    从源代码可以看出，hevc_find_frame_end()使用ParseContext中的state64临时缓存读取的字节。state64是一个uint64_t类型的变量，一共可以存储8Byte的数据。函数体的for()循环一次读取一个字节，读取完成后将该字节放入state64变量中；接着与起始码“0x000001”进行比较，如果不相等则继续读取，如果相等的话则提取NALU Header中nal_unit_type信息做相应处理后返回起始码开始的位置。
    <br/>
    <br/>
    <h2>
     parse_nal_units()
    </h2>
    parse_nal_units()用于解析一些NALU（VPS、SPS、PPS）的信息。该函数的定义位于libavcodec\hevc_parser.c，如下所示。
    <br/>
    <pre class="cpp">/**
 * Parse NAL units of found picture and decode some basic information.
 *
 * @param s parser context.
 * @param avctx codec context.
 * @param buf buffer with field/frame data.
 * @param buf_size size of the buffer.
 *
 * 解析NALU内容（不解码）
 * 注释：雷霄骅
 * leixiaohua1020@126.com
 * http://blog.csdn.net/leixiaohua1020
 *
 */
static inline int parse_nal_units(AVCodecParserContext *s, AVCodecContext *avctx,
                      const uint8_t *buf, int buf_size)
{
    HEVCContext   *h  = &amp;((HEVCParseContext *)s-&gt;priv_data)-&gt;h;
    GetBitContext *gb = &amp;h-&gt;HEVClc-&gt;gb;
    SliceHeader   *sh = &amp;h-&gt;sh;
    const uint8_t *buf_end = buf + buf_size;
    int state = -1, i;
    HEVCNAL *nal;

    /* set some sane default values */
    s-&gt;pict_type         = AV_PICTURE_TYPE_I;
    s-&gt;key_frame         = 0;
    s-&gt;picture_structure = AV_PICTURE_STRUCTURE_UNKNOWN;

    h-&gt;avctx = avctx;

    if (!buf_size)
        return 0;

    if (h-&gt;nals_allocated &lt; 1) {
        HEVCNAL *tmp = av_realloc_array(h-&gt;nals, 1, sizeof(*tmp));
        if (!tmp)
            return AVERROR(ENOMEM);
        h-&gt;nals = tmp;
        memset(h-&gt;nals, 0, sizeof(*tmp));
        h-&gt;nals_allocated = 1;
    }

    nal = &amp;h-&gt;nals[0];

    for (;;) {
        int src_length, consumed;
        buf = avpriv_find_start_code(buf, buf_end, &amp;state);
        if (--buf + 2 &gt;= buf_end)
            break;
        src_length = buf_end - buf;

        h-&gt;nal_unit_type = (*buf &gt;&gt; 1) &amp; 0x3f;
        h-&gt;temporal_id   = (*(buf + 1) &amp; 0x07) - 1;
        if (h-&gt;nal_unit_type &lt;= NAL_CRA_NUT) {
            // Do not walk the whole buffer just to decode slice segment header
            if (src_length &gt; 20)
                src_length = 20;
        }
        //类似于H.264解析器中的ff_h264_decode_nal()
        consumed = ff_hevc_extract_rbsp(h, buf, src_length, nal);
        if (consumed &lt; 0)
            return consumed;

        init_get_bits8(gb, nal-&gt;data + 2, nal-&gt;size);
        /*
         * 几种NALU之间的关系
         *                           +--SS1
         *                           |
         *                 +--PPS1&lt;--+
         *                 |         |
         *       +--SPS1&lt;--+         +--SS2
         *       |         |
         * VPS&lt;--+         +--PPS2
         *       |
         *       +--SPS2
         *
         */
        //解析不同种类的NALU
        switch (h-&gt;nal_unit_type) {
        case NAL_VPS:
        	//解析VPS
        	//VPS主要传输视频分级信息，有利于兼容可分级视频编码以及多视点视频编码
            ff_hevc_decode_nal_vps(h);
            break;
        case NAL_SPS:
        	//解析SPS
            ff_hevc_decode_nal_sps(h);
            break;
        case NAL_PPS:
        	//解析PPS
            ff_hevc_decode_nal_pps(h);
            break;
        case NAL_SEI_PREFIX:
        case NAL_SEI_SUFFIX:
        	//解析SEI
            ff_hevc_decode_nal_sei(h);
            break;
        case NAL_TRAIL_N:
        case NAL_TRAIL_R:
        case NAL_TSA_N:
        case NAL_TSA_R:
        case NAL_STSA_N:
        case NAL_STSA_R:
        case NAL_RADL_N:
        case NAL_RADL_R:
        case NAL_RASL_N:
        case NAL_RASL_R:
        case NAL_BLA_W_LP:
        case NAL_BLA_W_RADL:
        case NAL_BLA_N_LP:
        case NAL_IDR_W_RADL:
        case NAL_IDR_N_LP:
        case NAL_CRA_NUT:

        	//解析 SS Header

        	//按照解码顺序，当前SS是否为第1个SS（Slice Segment）
            sh-&gt;first_slice_in_pic_flag = get_bits1(gb);
            s-&gt;picture_structure = h-&gt;picture_struct;
            s-&gt;field_order = h-&gt;picture_struct;

            //IRAP, Intra Random Access Point, 随机介入点
            //包括 IDR, CRA, BLA
            if (IS_IRAP(h)) {
            	//设置关键帧
                s-&gt;key_frame = 1;
                sh-&gt;no_output_of_prior_pics_flag = get_bits1(gb);
            }
            //当前Slice引用的PPS的ID号
            sh-&gt;pps_id = get_ue_golomb(gb);
            if (sh-&gt;pps_id &gt;= MAX_PPS_COUNT || !h-&gt;pps_list[sh-&gt;pps_id]) {
                av_log(h-&gt;avctx, AV_LOG_ERROR, "PPS id out of range: %d\n", sh-&gt;pps_id);
                return AVERROR_INVALIDDATA;
            }
            h-&gt;pps = (HEVCPPS*)h-&gt;pps_list[sh-&gt;pps_id]-&gt;data;

            if (h-&gt;pps-&gt;sps_id &gt;= MAX_SPS_COUNT || !h-&gt;sps_list[h-&gt;pps-&gt;sps_id]) {
                av_log(h-&gt;avctx, AV_LOG_ERROR, "SPS id out of range: %d\n", h-&gt;pps-&gt;sps_id);
                return AVERROR_INVALIDDATA;
            }
            if (h-&gt;sps != (HEVCSPS*)h-&gt;sps_list[h-&gt;pps-&gt;sps_id]-&gt;data) {
                h-&gt;sps = (HEVCSPS*)h-&gt;sps_list[h-&gt;pps-&gt;sps_id]-&gt;data;
                h-&gt;vps = (HEVCVPS*)h-&gt;vps_list[h-&gt;sps-&gt;vps_id]-&gt;data;
            }
            //当前Slice不是第一个SS
            if (!sh-&gt;first_slice_in_pic_flag) {
                int slice_address_length;
                //当前SS是否依赖SS
                if (h-&gt;pps-&gt;dependent_slice_segments_enabled_flag)
                    sh-&gt;dependent_slice_segment_flag = get_bits1(gb);
                else
                    sh-&gt;dependent_slice_segment_flag = 0;

                slice_address_length = av_ceil_log2_c(h-&gt;sps-&gt;ctb_width *
                                                      h-&gt;sps-&gt;ctb_height);
                //当前SS中第一个CTU的地址
                sh-&gt;slice_segment_addr = get_bits(gb, slice_address_length);
                if (sh-&gt;slice_segment_addr &gt;= h-&gt;sps-&gt;ctb_width * h-&gt;sps-&gt;ctb_height) {
                    av_log(h-&gt;avctx, AV_LOG_ERROR, "Invalid slice segment address: %u.\n",
                           sh-&gt;slice_segment_addr);
                    return AVERROR_INVALIDDATA;
                }
            } else
                sh-&gt;dependent_slice_segment_flag = 0;//独立SS

            if (sh-&gt;dependent_slice_segment_flag)//依赖SS
                break;

            for (i = 0; i &lt; h-&gt;pps-&gt;num_extra_slice_header_bits; i++)
                skip_bits(gb, 1); // slice_reserved_undetermined_flag[]

            //slice type定义：
            //  0: B Slice
            //  1: P Slice
            //  2: I Slice
            sh-&gt;slice_type = get_ue_golomb(gb);//
            if (!(sh-&gt;slice_type == I_SLICE || sh-&gt;slice_type == P_SLICE ||
                  sh-&gt;slice_type == B_SLICE)) {
                av_log(h-&gt;avctx, AV_LOG_ERROR, "Unknown slice type: %d.\n",
                       sh-&gt;slice_type);
                return AVERROR_INVALIDDATA;
            }
            s-&gt;pict_type = sh-&gt;slice_type == B_SLICE ? AV_PICTURE_TYPE_B :
                           sh-&gt;slice_type == P_SLICE ? AV_PICTURE_TYPE_P :
                                                       AV_PICTURE_TYPE_I;

            if (h-&gt;pps-&gt;output_flag_present_flag)
                sh-&gt;pic_output_flag = get_bits1(gb);

            if (h-&gt;sps-&gt;separate_colour_plane_flag)
                sh-&gt;colour_plane_id = get_bits(gb, 2);

            if (!IS_IDR(h)) {
            	//不是IDR，则计算POC
                sh-&gt;pic_order_cnt_lsb = get_bits(gb, h-&gt;sps-&gt;log2_max_poc_lsb);
                s-&gt;output_picture_number = h-&gt;poc = ff_hevc_compute_poc(h, sh-&gt;pic_order_cnt_lsb);
            } else
                s-&gt;output_picture_number = h-&gt;poc = 0;

            if (h-&gt;temporal_id == 0 &amp;&amp;
                h-&gt;nal_unit_type != NAL_TRAIL_N &amp;&amp;
                h-&gt;nal_unit_type != NAL_TSA_N &amp;&amp;
                h-&gt;nal_unit_type != NAL_STSA_N &amp;&amp;
                h-&gt;nal_unit_type != NAL_RADL_N &amp;&amp;
                h-&gt;nal_unit_type != NAL_RASL_N &amp;&amp;
                h-&gt;nal_unit_type != NAL_RADL_R &amp;&amp;
                h-&gt;nal_unit_type != NAL_RASL_R)
                h-&gt;pocTid0 = h-&gt;poc;

            return 0; /* no need to evaluate the rest */
        }
        buf += consumed;
    }
    /* didn't find a picture! */
    av_log(h-&gt;avctx, AV_LOG_ERROR, "missing picture in access unit\n");
    return -1;
}
</pre>
    <br/>
    从源代码可以看出，parse_nal_units()根据nal_unit_type的不同，调用不同的解析函数进行处理。例如：
    <br/>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
     a)解析VPS的时候调用ff_hevc_decode_nal_vps()
     <br/>
     b)解析SPS的时候调用ff_hevc_decode_nal_sps()
     <br/>
     c)解析PPS的时候调用ff_hevc_decode_nal_pps()
     <br/>
     d)解析SEI的时候调用ff_hevc_decode_nal_sei()
     <br/>
     e)解析SS Header的一部分信息。
    </blockquote>
    下文简单分析这几种NALU的解析函数。
    <br/>
    <br/>
    <h2>
     ff_hevc_decode_nal_vps()
    </h2>
    目前还没有研究过VPS，所以没有分析该函数。
    <br/>
    <br/>
    <br/>
    <h2>
     ff_hevc_decode_nal_sps()
    </h2>
    ff_hevc_decode_nal_sps()用于解析HEVC码流中的SPS。该函数的定义位于libavcodec\hevc_ps.c，如下所示。
    <br/>
    <pre class="cpp">//解析SPS
int ff_hevc_decode_nal_sps(HEVCContext *s)
{
    const AVPixFmtDescriptor *desc;
    GetBitContext *gb = &amp;s-&gt;HEVClc-&gt;gb;
    int ret = 0;
    unsigned int sps_id = 0;
    int log2_diff_max_min_transform_block_size;
    int bit_depth_chroma, start, vui_present, sublayer_ordering_info;
    int i;

    HEVCSPS *sps;
    AVBufferRef *sps_buf = av_buffer_allocz(sizeof(*sps));

    if (!sps_buf)
        return AVERROR(ENOMEM);
    sps = (HEVCSPS*)sps_buf-&gt;data;

    av_log(s-&gt;avctx, AV_LOG_DEBUG, "Decoding SPS\n");

    // Coded parameters
    // 当前引用的VPS的ID
    sps-&gt;vps_id = get_bits(gb, 4);
    if (sps-&gt;vps_id &gt;= MAX_VPS_COUNT) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "VPS id out of range: %d\n", sps-&gt;vps_id);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }

    if (!s-&gt;vps_list[sps-&gt;vps_id]) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "VPS %d does not exist\n",
               sps-&gt;vps_id);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }
    //时域子层的最大数目
    sps-&gt;max_sub_layers = get_bits(gb, 3) + 1;
    if (sps-&gt;max_sub_layers &gt; MAX_SUB_LAYERS) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "sps_max_sub_layers out of range: %d\n",
               sps-&gt;max_sub_layers);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }

    skip_bits1(gb); // temporal_id_nesting_flag

    if (parse_ptl(s, &amp;sps-&gt;ptl, sps-&gt;max_sub_layers) &lt; 0)
        goto err;
    //当前SPS的ID
    sps_id = get_ue_golomb_long(gb);
    if (sps_id &gt;= MAX_SPS_COUNT) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "SPS id out of range: %d\n", sps_id);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }
    /*
	 * chroma_format_idc色度取样格式
	 * 0: Y
	 * 1: YUV420P
	 * 2: YUV422P
	 * 3: YUV444P
	 */
    sps-&gt;chroma_format_idc = get_ue_golomb_long(gb);
    if (!(sps-&gt;chroma_format_idc == 1 || sps-&gt;chroma_format_idc == 2 || sps-&gt;chroma_format_idc == 3)) {
        avpriv_report_missing_feature(s-&gt;avctx, "chroma_format_idc != {1, 2, 3}\n");
        ret = AVERROR_PATCHWELCOME;
        goto err;
    }
    //YUV444的时候，标记是否对3个分量单独编码
    if (sps-&gt;chroma_format_idc == 3)
        sps-&gt;separate_colour_plane_flag = get_bits1(gb);

    if (sps-&gt;separate_colour_plane_flag)
        sps-&gt;chroma_format_idc = 0;
    //宽和高
    sps-&gt;width  = get_ue_golomb_long(gb);
    sps-&gt;height = get_ue_golomb_long(gb);
    if ((ret = av_image_check_size(sps-&gt;width,
                                   sps-&gt;height, 0, s-&gt;avctx)) &lt; 0)
        goto err;
    //裁剪相关
    if (get_bits1(gb)) { // pic_conformance_flag
        //TODO: * 2 is only valid for 420
        sps-&gt;pic_conf_win.left_offset   = get_ue_golomb_long(gb) * 2;
        sps-&gt;pic_conf_win.right_offset  = get_ue_golomb_long(gb) * 2;
        sps-&gt;pic_conf_win.top_offset    = get_ue_golomb_long(gb) * 2;
        sps-&gt;pic_conf_win.bottom_offset = get_ue_golomb_long(gb) * 2;

        if (s-&gt;avctx-&gt;flags2 &amp; CODEC_FLAG2_IGNORE_CROP) {
            av_log(s-&gt;avctx, AV_LOG_DEBUG,
                   "discarding sps conformance window, "
                   "original values are l:%u r:%u t:%u b:%u\n",
                   sps-&gt;pic_conf_win.left_offset,
                   sps-&gt;pic_conf_win.right_offset,
                   sps-&gt;pic_conf_win.top_offset,
                   sps-&gt;pic_conf_win.bottom_offset);

            sps-&gt;pic_conf_win.left_offset   =
            sps-&gt;pic_conf_win.right_offset  =
            sps-&gt;pic_conf_win.top_offset    =
            sps-&gt;pic_conf_win.bottom_offset = 0;
        }
        sps-&gt;output_window = sps-&gt;pic_conf_win;
    }
    //亮度像素的颜色位深
    sps-&gt;bit_depth   = get_ue_golomb_long(gb) + 8;
    //色度像素的颜色位深
    bit_depth_chroma = get_ue_golomb_long(gb) + 8;
    if (bit_depth_chroma != sps-&gt;bit_depth) {
        av_log(s-&gt;avctx, AV_LOG_ERROR,
               "Luma bit depth (%d) is different from chroma bit depth (%d), "
               "this is unsupported.\n",
               sps-&gt;bit_depth, bit_depth_chroma);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }
    //根据颜色位深和色度采样格式设定pix_fmt
    switch (sps-&gt;bit_depth) {
    case 8:
        if (sps-&gt;chroma_format_idc == 1) sps-&gt;pix_fmt = AV_PIX_FMT_YUV420P;
        if (sps-&gt;chroma_format_idc == 2) sps-&gt;pix_fmt = AV_PIX_FMT_YUV422P;
        if (sps-&gt;chroma_format_idc == 3) sps-&gt;pix_fmt = AV_PIX_FMT_YUV444P;
       break;
    case 9:
        if (sps-&gt;chroma_format_idc == 1) sps-&gt;pix_fmt = AV_PIX_FMT_YUV420P9;
        if (sps-&gt;chroma_format_idc == 2) sps-&gt;pix_fmt = AV_PIX_FMT_YUV422P9;
        if (sps-&gt;chroma_format_idc == 3) sps-&gt;pix_fmt = AV_PIX_FMT_YUV444P9;
        break;
    case 10:
        if (sps-&gt;chroma_format_idc == 1) sps-&gt;pix_fmt = AV_PIX_FMT_YUV420P10;
        if (sps-&gt;chroma_format_idc == 2) sps-&gt;pix_fmt = AV_PIX_FMT_YUV422P10;
        if (sps-&gt;chroma_format_idc == 3) sps-&gt;pix_fmt = AV_PIX_FMT_YUV444P10;
        break;
    case 12:
        if (sps-&gt;chroma_format_idc == 1) sps-&gt;pix_fmt = AV_PIX_FMT_YUV420P12;
        if (sps-&gt;chroma_format_idc == 2) sps-&gt;pix_fmt = AV_PIX_FMT_YUV422P12;
        if (sps-&gt;chroma_format_idc == 3) sps-&gt;pix_fmt = AV_PIX_FMT_YUV444P12;
        break;
    default:
        av_log(s-&gt;avctx, AV_LOG_ERROR,
               "4:2:0, 4:2:2, 4:4:4 supports are currently specified for 8, 10 and 12 bits.\n");
        ret = AVERROR_PATCHWELCOME;
        goto err;
    }

    desc = av_pix_fmt_desc_get(sps-&gt;pix_fmt);
    if (!desc) {
        ret = AVERROR(EINVAL);
        goto err;
    }

    sps-&gt;hshift[0] = sps-&gt;vshift[0] = 0;
    sps-&gt;hshift[2] = sps-&gt;hshift[1] = desc-&gt;log2_chroma_w;
    sps-&gt;vshift[2] = sps-&gt;vshift[1] = desc-&gt;log2_chroma_h;

    sps-&gt;pixel_shift = sps-&gt;bit_depth &gt; 8;

    //用于计算POC
    sps-&gt;log2_max_poc_lsb = get_ue_golomb_long(gb) + 4;
    if (sps-&gt;log2_max_poc_lsb &gt; 16) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "log2_max_pic_order_cnt_lsb_minus4 out range: %d\n",
               sps-&gt;log2_max_poc_lsb - 4);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }

    sublayer_ordering_info = get_bits1(gb);
    start = sublayer_ordering_info ? 0 : sps-&gt;max_sub_layers - 1;
    for (i = start; i &lt; sps-&gt;max_sub_layers; i++) {
        sps-&gt;temporal_layer[i].max_dec_pic_buffering = get_ue_golomb_long(gb) + 1;
        sps-&gt;temporal_layer[i].num_reorder_pics      = get_ue_golomb_long(gb);
        sps-&gt;temporal_layer[i].max_latency_increase  = get_ue_golomb_long(gb) - 1;
        if (sps-&gt;temporal_layer[i].max_dec_pic_buffering &gt; MAX_DPB_SIZE) {
            av_log(s-&gt;avctx, AV_LOG_ERROR, "sps_max_dec_pic_buffering_minus1 out of range: %d\n",
                   sps-&gt;temporal_layer[i].max_dec_pic_buffering - 1);
            ret = AVERROR_INVALIDDATA;
            goto err;
        }
        if (sps-&gt;temporal_layer[i].num_reorder_pics &gt; sps-&gt;temporal_layer[i].max_dec_pic_buffering - 1) {
            av_log(s-&gt;avctx, AV_LOG_WARNING, "sps_max_num_reorder_pics out of range: %d\n",
                   sps-&gt;temporal_layer[i].num_reorder_pics);
            if (s-&gt;avctx-&gt;err_recognition &amp; AV_EF_EXPLODE ||
                sps-&gt;temporal_layer[i].num_reorder_pics &gt; MAX_DPB_SIZE - 1) {
                ret = AVERROR_INVALIDDATA;
                goto err;
            }
            sps-&gt;temporal_layer[i].max_dec_pic_buffering = sps-&gt;temporal_layer[i].num_reorder_pics + 1;
        }
    }

    if (!sublayer_ordering_info) {
        for (i = 0; i &lt; start; i++) {
            sps-&gt;temporal_layer[i].max_dec_pic_buffering = sps-&gt;temporal_layer[start].max_dec_pic_buffering;
            sps-&gt;temporal_layer[i].num_reorder_pics      = sps-&gt;temporal_layer[start].num_reorder_pics;
            sps-&gt;temporal_layer[i].max_latency_increase  = sps-&gt;temporal_layer[start].max_latency_increase;
        }
    }
    //亮度编码块-最小尺寸
    sps-&gt;log2_min_cb_size                    = get_ue_golomb_long(gb) + 3;
    //亮度编码块-最大尺寸和最小尺寸插值
    sps-&gt;log2_diff_max_min_coding_block_size = get_ue_golomb_long(gb);
    //亮度变换块-最小尺寸
    sps-&gt;log2_min_tb_size                    = get_ue_golomb_long(gb) + 2;
    //亮度变换块-最大尺寸和最小尺寸插值
    log2_diff_max_min_transform_block_size   = get_ue_golomb_long(gb);
    sps-&gt;log2_max_trafo_size                 = log2_diff_max_min_transform_block_size +
                                               sps-&gt;log2_min_tb_size;

    if (sps-&gt;log2_min_tb_size &gt;= sps-&gt;log2_min_cb_size) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "Invalid value for log2_min_tb_size");
        ret = AVERROR_INVALIDDATA;
        goto err;
    }
    //帧间预测变换块-最大划分深度
    sps-&gt;max_transform_hierarchy_depth_inter = get_ue_golomb_long(gb);
    //帧内预测变换块-最大划分深度
    sps-&gt;max_transform_hierarchy_depth_intra = get_ue_golomb_long(gb);
    //是否使用量化矩阵
    sps-&gt;scaling_list_enable_flag = get_bits1(gb);
    if (sps-&gt;scaling_list_enable_flag) {
        set_default_scaling_list_data(&amp;sps-&gt;scaling_list);

        if (get_bits1(gb)) {
            ret = scaling_list_data(s, &amp;sps-&gt;scaling_list, sps);
            if (ret &lt; 0)
                goto err;
        }
    }
    //是否使用非对称划分模式
    sps-&gt;amp_enabled_flag = get_bits1(gb);
    //是否在去块效应滤波过程中使用样点自适应补偿SAO
    sps-&gt;sao_enabled      = get_bits1(gb);
    //允许PCM编码
    sps-&gt;pcm_enabled_flag = get_bits1(gb);
    //有关PCM编码的参数
    if (sps-&gt;pcm_enabled_flag) {
        sps-&gt;pcm.bit_depth   = get_bits(gb, 4) + 1;
        sps-&gt;pcm.bit_depth_chroma = get_bits(gb, 4) + 1;
        sps-&gt;pcm.log2_min_pcm_cb_size = get_ue_golomb_long(gb) + 3;
        sps-&gt;pcm.log2_max_pcm_cb_size = sps-&gt;pcm.log2_min_pcm_cb_size +
                                        get_ue_golomb_long(gb);
        if (sps-&gt;pcm.bit_depth &gt; sps-&gt;bit_depth) {
            av_log(s-&gt;avctx, AV_LOG_ERROR,
                   "PCM bit depth (%d) is greater than normal bit depth (%d)\n",
                   sps-&gt;pcm.bit_depth, sps-&gt;bit_depth);
            ret = AVERROR_INVALIDDATA;
            goto err;
        }

        sps-&gt;pcm.loop_filter_disable_flag = get_bits1(gb);
    }
    //短期参考num_short_term_ref_pic_set
    sps-&gt;nb_st_rps = get_ue_golomb_long(gb);
    if (sps-&gt;nb_st_rps &gt; MAX_SHORT_TERM_RPS_COUNT) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "Too many short term RPS: %d.\n",
               sps-&gt;nb_st_rps);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }
    for (i = 0; i &lt; sps-&gt;nb_st_rps; i++) {
        if ((ret = ff_hevc_decode_short_term_rps(s, &amp;sps-&gt;st_rps[i],
                                                 sps, 0)) &lt; 0)
            goto err;
    }
    //长期参考num_long_term_ref_pic_set
    sps-&gt;long_term_ref_pics_present_flag = get_bits1(gb);
    if (sps-&gt;long_term_ref_pics_present_flag) {
        sps-&gt;num_long_term_ref_pics_sps = get_ue_golomb_long(gb);
        if (sps-&gt;num_long_term_ref_pics_sps &gt; 31U) {
            av_log(0, AV_LOG_ERROR, "num_long_term_ref_pics_sps %d is out of range.\n",
                   sps-&gt;num_long_term_ref_pics_sps);
            goto err;
        }
        for (i = 0; i &lt; sps-&gt;num_long_term_ref_pics_sps; i++) {
            sps-&gt;lt_ref_pic_poc_lsb_sps[i]       = get_bits(gb, sps-&gt;log2_max_poc_lsb);
            sps-&gt;used_by_curr_pic_lt_sps_flag[i] = get_bits1(gb);
        }
    }
    //是否使用时域MV预测
    sps-&gt;sps_temporal_mvp_enabled_flag          = get_bits1(gb);
    //滤波过程是否使用双线性插值
    sps-&gt;sps_strong_intra_smoothing_enable_flag = get_bits1(gb);
    sps-&gt;vui.sar = (AVRational){0, 1};
    vui_present = get_bits1(gb);
    if (vui_present)
        decode_vui(s, sps);

    if (get_bits1(gb)) { // sps_extension_flag
        int sps_extension_flag[1];
        for (i = 0; i &lt; 1; i++)
            sps_extension_flag[i] = get_bits1(gb);
        skip_bits(gb, 7); //sps_extension_7bits = get_bits(gb, 7);
        if (sps_extension_flag[0]) {
            int extended_precision_processing_flag;
            int high_precision_offsets_enabled_flag;
            int cabac_bypass_alignment_enabled_flag;

            sps-&gt;transform_skip_rotation_enabled_flag = get_bits1(gb);
            sps-&gt;transform_skip_context_enabled_flag  = get_bits1(gb);
            sps-&gt;implicit_rdpcm_enabled_flag = get_bits1(gb);

            sps-&gt;explicit_rdpcm_enabled_flag = get_bits1(gb);

            extended_precision_processing_flag = get_bits1(gb);
            if (extended_precision_processing_flag)
                av_log(s-&gt;avctx, AV_LOG_WARNING,
                   "extended_precision_processing_flag not yet implemented\n");

            sps-&gt;intra_smoothing_disabled_flag       = get_bits1(gb);
            high_precision_offsets_enabled_flag  = get_bits1(gb);
            if (high_precision_offsets_enabled_flag)
                av_log(s-&gt;avctx, AV_LOG_WARNING,
                   "high_precision_offsets_enabled_flag not yet implemented\n");

            sps-&gt;persistent_rice_adaptation_enabled_flag = get_bits1(gb);

            cabac_bypass_alignment_enabled_flag  = get_bits1(gb);
            if (cabac_bypass_alignment_enabled_flag)
                av_log(s-&gt;avctx, AV_LOG_WARNING,
                   "cabac_bypass_alignment_enabled_flag not yet implemented\n");
        }
    }
    if (s-&gt;apply_defdispwin) {
        sps-&gt;output_window.left_offset   += sps-&gt;vui.def_disp_win.left_offset;
        sps-&gt;output_window.right_offset  += sps-&gt;vui.def_disp_win.right_offset;
        sps-&gt;output_window.top_offset    += sps-&gt;vui.def_disp_win.top_offset;
        sps-&gt;output_window.bottom_offset += sps-&gt;vui.def_disp_win.bottom_offset;
    }
    if (sps-&gt;output_window.left_offset &amp; (0x1F &gt;&gt; (sps-&gt;pixel_shift)) &amp;&amp;
        !(s-&gt;avctx-&gt;flags &amp; CODEC_FLAG_UNALIGNED)) {
        sps-&gt;output_window.left_offset &amp;= ~(0x1F &gt;&gt; (sps-&gt;pixel_shift));
        av_log(s-&gt;avctx, AV_LOG_WARNING, "Reducing left output window to %d "
               "chroma samples to preserve alignment.\n",
               sps-&gt;output_window.left_offset);
    }
    sps-&gt;output_width  = sps-&gt;width -
                         (sps-&gt;output_window.left_offset + sps-&gt;output_window.right_offset);
    sps-&gt;output_height = sps-&gt;height -
                         (sps-&gt;output_window.top_offset + sps-&gt;output_window.bottom_offset);
    if (sps-&gt;output_width &lt;= 0 || sps-&gt;output_height &lt;= 0) {
        av_log(s-&gt;avctx, AV_LOG_WARNING, "Invalid visible frame dimensions: %dx%d.\n",
               sps-&gt;output_width, sps-&gt;output_height);
        if (s-&gt;avctx-&gt;err_recognition &amp; AV_EF_EXPLODE) {
            ret = AVERROR_INVALIDDATA;
            goto err;
        }
        av_log(s-&gt;avctx, AV_LOG_WARNING,
               "Displaying the whole video surface.\n");
        memset(&amp;sps-&gt;pic_conf_win, 0, sizeof(sps-&gt;pic_conf_win));
        memset(&amp;sps-&gt;output_window, 0, sizeof(sps-&gt;output_window));
        sps-&gt;output_width               = sps-&gt;width;
        sps-&gt;output_height              = sps-&gt;height;
    }

    // Inferred parameters
    // 推算出来的参数
    sps-&gt;log2_ctb_size = sps-&gt;log2_min_cb_size +
                         sps-&gt;log2_diff_max_min_coding_block_size;
    sps-&gt;log2_min_pu_size = sps-&gt;log2_min_cb_size - 1;

    sps-&gt;ctb_width  = (sps-&gt;width  + (1 &lt;&lt; sps-&gt;log2_ctb_size) - 1) &gt;&gt; sps-&gt;log2_ctb_size;
    sps-&gt;ctb_height = (sps-&gt;height + (1 &lt;&lt; sps-&gt;log2_ctb_size) - 1) &gt;&gt; sps-&gt;log2_ctb_size;
    sps-&gt;ctb_size   = sps-&gt;ctb_width * sps-&gt;ctb_height;

    sps-&gt;min_cb_width  = sps-&gt;width  &gt;&gt; sps-&gt;log2_min_cb_size;
    sps-&gt;min_cb_height = sps-&gt;height &gt;&gt; sps-&gt;log2_min_cb_size;
    sps-&gt;min_tb_width  = sps-&gt;width  &gt;&gt; sps-&gt;log2_min_tb_size;
    sps-&gt;min_tb_height = sps-&gt;height &gt;&gt; sps-&gt;log2_min_tb_size;
    sps-&gt;min_pu_width  = sps-&gt;width  &gt;&gt; sps-&gt;log2_min_pu_size;
    sps-&gt;min_pu_height = sps-&gt;height &gt;&gt; sps-&gt;log2_min_pu_size;
    sps-&gt;tb_mask       = (1 &lt;&lt; (sps-&gt;log2_ctb_size - sps-&gt;log2_min_tb_size)) - 1;

    sps-&gt;qp_bd_offset = 6 * (sps-&gt;bit_depth - 8);

    if (sps-&gt;width  &amp; ((1 &lt;&lt; sps-&gt;log2_min_cb_size) - 1) ||
        sps-&gt;height &amp; ((1 &lt;&lt; sps-&gt;log2_min_cb_size) - 1)) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "Invalid coded frame dimensions.\n");
        goto err;
    }

    if (sps-&gt;log2_ctb_size &gt; MAX_LOG2_CTB_SIZE) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "CTB size out of range: 2^%d\n", sps-&gt;log2_ctb_size);
        goto err;
    }
    if (sps-&gt;max_transform_hierarchy_depth_inter &gt; sps-&gt;log2_ctb_size - sps-&gt;log2_min_tb_size) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "max_transform_hierarchy_depth_inter out of range: %d\n",
               sps-&gt;max_transform_hierarchy_depth_inter);
        goto err;
    }
    if (sps-&gt;max_transform_hierarchy_depth_intra &gt; sps-&gt;log2_ctb_size - sps-&gt;log2_min_tb_size) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "max_transform_hierarchy_depth_intra out of range: %d\n",
               sps-&gt;max_transform_hierarchy_depth_intra);
        goto err;
    }
    if (sps-&gt;log2_max_trafo_size &gt; FFMIN(sps-&gt;log2_ctb_size, 5)) {
        av_log(s-&gt;avctx, AV_LOG_ERROR,
               "max transform block size out of range: %d\n",
               sps-&gt;log2_max_trafo_size);
        goto err;
    }

    if (get_bits_left(gb) &lt; 0) {
        av_log(s-&gt;avctx, AV_LOG_ERROR,
               "Overread SPS by %d bits\n", -get_bits_left(gb));
        goto err;
    }

    if (s-&gt;avctx-&gt;debug &amp; FF_DEBUG_BITSTREAM) {
        av_log(s-&gt;avctx, AV_LOG_DEBUG,
               "Parsed SPS: id %d; coded wxh: %dx%d; "
               "cropped wxh: %dx%d; pix_fmt: %s.\n",
               sps_id, sps-&gt;width, sps-&gt;height,
               sps-&gt;output_width, sps-&gt;output_height,
               av_get_pix_fmt_name(sps-&gt;pix_fmt));
    }

    /* check if this is a repeat of an already parsed SPS, then keep the
     * original one.
     * otherwise drop all PPSes that depend on it */
    if (s-&gt;sps_list[sps_id] &amp;&amp;
        !memcmp(s-&gt;sps_list[sps_id]-&gt;data, sps_buf-&gt;data, sps_buf-&gt;size)) {
        av_buffer_unref(&amp;sps_buf);
    } else {
        for (i = 0; i &lt; FF_ARRAY_ELEMS(s-&gt;pps_list); i++) {
            if (s-&gt;pps_list[i] &amp;&amp; ((HEVCPPS*)s-&gt;pps_list[i]-&gt;data)-&gt;sps_id == sps_id)
                av_buffer_unref(&amp;s-&gt;pps_list[i]);
        }
        if (s-&gt;sps_list[sps_id] &amp;&amp; s-&gt;sps == (HEVCSPS*)s-&gt;sps_list[sps_id]-&gt;data) {
            av_buffer_unref(&amp;s-&gt;current_sps);
            s-&gt;current_sps = av_buffer_ref(s-&gt;sps_list[sps_id]);
            if (!s-&gt;current_sps)
                s-&gt;sps = NULL;
        }
        av_buffer_unref(&amp;s-&gt;sps_list[sps_id]);
        s-&gt;sps_list[sps_id] = sps_buf;
    }

    return 0;

err:
    av_buffer_unref(&amp;sps_buf);
    return ret;
}
</pre>
    <br/>
    解析SPS源代码并不是很有“技术含量”。只要参考ITU-T的《HEVC标准》就可以理解了，不再做过多详细的分析。
    <br/>
    <br/>
    <h2>
     ff_hevc_decode_nal_pps()
    </h2>
    ff_hevc_decode_nal_pps()用于解析HEVC码流中的PPS。该函数的定义位于libavcodec\hevc_ps.c，如下所示。
    <br/>
    <pre class="cpp">//解析PPS
int ff_hevc_decode_nal_pps(HEVCContext *s)
{
    GetBitContext *gb = &amp;s-&gt;HEVClc-&gt;gb;
    HEVCSPS      *sps = NULL;
    int pic_area_in_ctbs;
    int log2_diff_ctb_min_tb_size;
    int i, j, x, y, ctb_addr_rs, tile_id;
    int ret = 0;
    unsigned int pps_id = 0;

    AVBufferRef *pps_buf;
    HEVCPPS *pps = av_mallocz(sizeof(*pps));

    if (!pps)
        return AVERROR(ENOMEM);

    pps_buf = av_buffer_create((uint8_t *)pps, sizeof(*pps),
                               hevc_pps_free, NULL, 0);
    if (!pps_buf) {
        av_freep(&amp;pps);
        return AVERROR(ENOMEM);
    }

    av_log(s-&gt;avctx, AV_LOG_DEBUG, "Decoding PPS\n");

    // Default values
    // 默认值
    pps-&gt;loop_filter_across_tiles_enabled_flag = 1;
    pps-&gt;num_tile_columns                      = 1;
    pps-&gt;num_tile_rows                         = 1;
    pps-&gt;uniform_spacing_flag                  = 1;
    pps-&gt;disable_dbf                           = 0;
    pps-&gt;beta_offset                           = 0;
    pps-&gt;tc_offset                             = 0;
    pps-&gt;log2_max_transform_skip_block_size    = 2;

    // Coded parameters
    //当前PPS的ID
    pps_id = get_ue_golomb_long(gb);
    if (pps_id &gt;= MAX_PPS_COUNT) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "PPS id out of range: %d\n", pps_id);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }
    //引用的SPS的ID
    pps-&gt;sps_id = get_ue_golomb_long(gb);
    if (pps-&gt;sps_id &gt;= MAX_SPS_COUNT) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "SPS id out of range: %d\n", pps-&gt;sps_id);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }
    if (!s-&gt;sps_list[pps-&gt;sps_id]) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "SPS %u does not exist.\n", pps-&gt;sps_id);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }
    sps = (HEVCSPS *)s-&gt;sps_list[pps-&gt;sps_id]-&gt;data;
    //判断当前Slice是否包含依赖片
    pps-&gt;dependent_slice_segments_enabled_flag = get_bits1(gb);
    pps-&gt;output_flag_present_flag              = get_bits1(gb);
    pps-&gt;num_extra_slice_header_bits           = get_bits(gb, 3);

    pps-&gt;sign_data_hiding_flag = get_bits1(gb);
    //在CABAC中用何种方式确定上下文变量的初始值
    pps-&gt;cabac_init_present_flag = get_bits1(gb);
    //list0中参考图像数目的默认最大值
    pps-&gt;num_ref_idx_l0_default_active = get_ue_golomb_long(gb) + 1;
    //list1中参考图像数目的默认最大值
    pps-&gt;num_ref_idx_l1_default_active = get_ue_golomb_long(gb) + 1;
    //亮度分量QP的初始值
    pps-&gt;pic_init_qp_minus26 = get_se_golomb(gb);

    pps-&gt;constrained_intra_pred_flag = get_bits1(gb);
    pps-&gt;transform_skip_enabled_flag = get_bits1(gb);

    pps-&gt;cu_qp_delta_enabled_flag = get_bits1(gb);
    pps-&gt;diff_cu_qp_delta_depth   = 0;
    if (pps-&gt;cu_qp_delta_enabled_flag)
        pps-&gt;diff_cu_qp_delta_depth = get_ue_golomb_long(gb);

    if (pps-&gt;diff_cu_qp_delta_depth &lt; 0 ||
        pps-&gt;diff_cu_qp_delta_depth &gt; sps-&gt;log2_diff_max_min_coding_block_size) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "diff_cu_qp_delta_depth %d is invalid\n",
               pps-&gt;diff_cu_qp_delta_depth);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }

    pps-&gt;cb_qp_offset = get_se_golomb(gb);
    if (pps-&gt;cb_qp_offset &lt; -12 || pps-&gt;cb_qp_offset &gt; 12) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "pps_cb_qp_offset out of range: %d\n",
               pps-&gt;cb_qp_offset);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }
    pps-&gt;cr_qp_offset = get_se_golomb(gb);
    if (pps-&gt;cr_qp_offset &lt; -12 || pps-&gt;cr_qp_offset &gt; 12) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "pps_cr_qp_offset out of range: %d\n",
               pps-&gt;cr_qp_offset);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }
    pps-&gt;pic_slice_level_chroma_qp_offsets_present_flag = get_bits1(gb);
    //P Slice是否使用加权预测
    pps-&gt;weighted_pred_flag   = get_bits1(gb);
    //B Slice是否使用加权预测
    pps-&gt;weighted_bipred_flag = get_bits1(gb);

    pps-&gt;transquant_bypass_enable_flag    = get_bits1(gb);
    //是否使用tile
    pps-&gt;tiles_enabled_flag               = get_bits1(gb);
    pps-&gt;entropy_coding_sync_enabled_flag = get_bits1(gb);

    if (pps-&gt;tiles_enabled_flag) {
    	//Tile的列数
        pps-&gt;num_tile_columns = get_ue_golomb_long(gb) + 1;
        //Tile的行数
        pps-&gt;num_tile_rows    = get_ue_golomb_long(gb) + 1;
        if (pps-&gt;num_tile_columns == 0 ||
            pps-&gt;num_tile_columns &gt;= sps-&gt;width) {
            av_log(s-&gt;avctx, AV_LOG_ERROR, "num_tile_columns_minus1 out of range: %d\n",
                   pps-&gt;num_tile_columns - 1);
            ret = AVERROR_INVALIDDATA;
            goto err;
        }
        if (pps-&gt;num_tile_rows == 0 ||
            pps-&gt;num_tile_rows &gt;= sps-&gt;height) {
            av_log(s-&gt;avctx, AV_LOG_ERROR, "num_tile_rows_minus1 out of range: %d\n",
                   pps-&gt;num_tile_rows - 1);
            ret = AVERROR_INVALIDDATA;
            goto err;
        }

        pps-&gt;column_width = av_malloc_array(pps-&gt;num_tile_columns, sizeof(*pps-&gt;column_width));
        pps-&gt;row_height   = av_malloc_array(pps-&gt;num_tile_rows,    sizeof(*pps-&gt;row_height));
        if (!pps-&gt;column_width || !pps-&gt;row_height) {
            ret = AVERROR(ENOMEM);
            goto err;
        }

        pps-&gt;uniform_spacing_flag = get_bits1(gb);
        if (!pps-&gt;uniform_spacing_flag) {
            uint64_t sum = 0;
            //每个Tile的宽度和高度
            for (i = 0; i &lt; pps-&gt;num_tile_columns - 1; i++) {
                pps-&gt;column_width[i] = get_ue_golomb_long(gb) + 1;
                sum                 += pps-&gt;column_width[i];
            }
            if (sum &gt;= sps-&gt;ctb_width) {
                av_log(s-&gt;avctx, AV_LOG_ERROR, "Invalid tile widths.\n");
                ret = AVERROR_INVALIDDATA;
                goto err;
            }
            pps-&gt;column_width[pps-&gt;num_tile_columns - 1] = sps-&gt;ctb_width - sum;

            sum = 0;
            for (i = 0; i &lt; pps-&gt;num_tile_rows - 1; i++) {
                pps-&gt;row_height[i] = get_ue_golomb_long(gb) + 1;
                sum               += pps-&gt;row_height[i];
            }
            if (sum &gt;= sps-&gt;ctb_height) {
                av_log(s-&gt;avctx, AV_LOG_ERROR, "Invalid tile heights.\n");
                ret = AVERROR_INVALIDDATA;
                goto err;
            }
            pps-&gt;row_height[pps-&gt;num_tile_rows - 1] = sps-&gt;ctb_height - sum;
        }
        pps-&gt;loop_filter_across_tiles_enabled_flag = get_bits1(gb);
    }

    pps-&gt;seq_loop_filter_across_slices_enabled_flag = get_bits1(gb);
    //是否存在去方块滤波的控制信息
    pps-&gt;deblocking_filter_control_present_flag = get_bits1(gb);
    if (pps-&gt;deblocking_filter_control_present_flag) {
        pps-&gt;deblocking_filter_override_enabled_flag = get_bits1(gb);
        //是否使用去方块滤波
        pps-&gt;disable_dbf                             = get_bits1(gb);
        if (!pps-&gt;disable_dbf) {
            pps-&gt;beta_offset = get_se_golomb(gb) * 2;
            pps-&gt;tc_offset = get_se_golomb(gb) * 2;
            if (pps-&gt;beta_offset/2 &lt; -6 || pps-&gt;beta_offset/2 &gt; 6) {
                av_log(s-&gt;avctx, AV_LOG_ERROR, "pps_beta_offset_div2 out of range: %d\n",
                       pps-&gt;beta_offset/2);
                ret = AVERROR_INVALIDDATA;
                goto err;
            }
            if (pps-&gt;tc_offset/2 &lt; -6 || pps-&gt;tc_offset/2 &gt; 6) {
                av_log(s-&gt;avctx, AV_LOG_ERROR, "pps_tc_offset_div2 out of range: %d\n",
                       pps-&gt;tc_offset/2);
                ret = AVERROR_INVALIDDATA;
                goto err;
            }
        }
    }

    pps-&gt;scaling_list_data_present_flag = get_bits1(gb);
    if (pps-&gt;scaling_list_data_present_flag) {
        set_default_scaling_list_data(&amp;pps-&gt;scaling_list);
        ret = scaling_list_data(s, &amp;pps-&gt;scaling_list, sps);
        if (ret &lt; 0)
            goto err;
    }
    pps-&gt;lists_modification_present_flag = get_bits1(gb);
    pps-&gt;log2_parallel_merge_level       = get_ue_golomb_long(gb) + 2;
    if (pps-&gt;log2_parallel_merge_level &gt; sps-&gt;log2_ctb_size) {
        av_log(s-&gt;avctx, AV_LOG_ERROR, "log2_parallel_merge_level_minus2 out of range: %d\n",
               pps-&gt;log2_parallel_merge_level - 2);
        ret = AVERROR_INVALIDDATA;
        goto err;
    }

    pps-&gt;slice_header_extension_present_flag = get_bits1(gb);

    if (get_bits1(gb)) { // pps_extension_present_flag
        int pps_range_extensions_flag = get_bits1(gb);
        /* int pps_extension_7bits = */ get_bits(gb, 7);
        if (sps-&gt;ptl.general_ptl.profile_idc == FF_PROFILE_HEVC_REXT &amp;&amp; pps_range_extensions_flag) {
            if ((ret = pps_range_extensions(s, pps, sps)) &lt; 0)
                goto err;
        }
    }

    // Inferred parameters
    pps-&gt;col_bd   = av_malloc_array(pps-&gt;num_tile_columns + 1, sizeof(*pps-&gt;col_bd));
    pps-&gt;row_bd   = av_malloc_array(pps-&gt;num_tile_rows + 1,    sizeof(*pps-&gt;row_bd));
    pps-&gt;col_idxX = av_malloc_array(sps-&gt;ctb_width,    sizeof(*pps-&gt;col_idxX));
    if (!pps-&gt;col_bd || !pps-&gt;row_bd || !pps-&gt;col_idxX) {
        ret = AVERROR(ENOMEM);
        goto err;
    }

    if (pps-&gt;uniform_spacing_flag) {
        if (!pps-&gt;column_width) {
            pps-&gt;column_width = av_malloc_array(pps-&gt;num_tile_columns, sizeof(*pps-&gt;column_width));
            pps-&gt;row_height   = av_malloc_array(pps-&gt;num_tile_rows,    sizeof(*pps-&gt;row_height));
        }
        if (!pps-&gt;column_width || !pps-&gt;row_height) {
            ret = AVERROR(ENOMEM);
            goto err;
        }

        for (i = 0; i &lt; pps-&gt;num_tile_columns; i++) {
            pps-&gt;column_width[i] = ((i + 1) * sps-&gt;ctb_width) / pps-&gt;num_tile_columns -
                                   (i * sps-&gt;ctb_width) / pps-&gt;num_tile_columns;
        }

        for (i = 0; i &lt; pps-&gt;num_tile_rows; i++) {
            pps-&gt;row_height[i] = ((i + 1) * sps-&gt;ctb_height) / pps-&gt;num_tile_rows -
                                 (i * sps-&gt;ctb_height) / pps-&gt;num_tile_rows;
        }
    }

    pps-&gt;col_bd[0] = 0;
    for (i = 0; i &lt; pps-&gt;num_tile_columns; i++)
        pps-&gt;col_bd[i + 1] = pps-&gt;col_bd[i] + pps-&gt;column_width[i];

    pps-&gt;row_bd[0] = 0;
    for (i = 0; i &lt; pps-&gt;num_tile_rows; i++)
        pps-&gt;row_bd[i + 1] = pps-&gt;row_bd[i] + pps-&gt;row_height[i];

    for (i = 0, j = 0; i &lt; sps-&gt;ctb_width; i++) {
        if (i &gt; pps-&gt;col_bd[j])
            j++;
        pps-&gt;col_idxX[i] = j;
    }

    /**
     * 6.5
     */
    pic_area_in_ctbs     = sps-&gt;ctb_width    * sps-&gt;ctb_height;

    pps-&gt;ctb_addr_rs_to_ts = av_malloc_array(pic_area_in_ctbs,    sizeof(*pps-&gt;ctb_addr_rs_to_ts));
    pps-&gt;ctb_addr_ts_to_rs = av_malloc_array(pic_area_in_ctbs,    sizeof(*pps-&gt;ctb_addr_ts_to_rs));
    pps-&gt;tile_id           = av_malloc_array(pic_area_in_ctbs,    sizeof(*pps-&gt;tile_id));
    pps-&gt;min_tb_addr_zs_tab = av_malloc_array((sps-&gt;tb_mask+2) * (sps-&gt;tb_mask+2), sizeof(*pps-&gt;min_tb_addr_zs_tab));
    if (!pps-&gt;ctb_addr_rs_to_ts || !pps-&gt;ctb_addr_ts_to_rs ||
        !pps-&gt;tile_id || !pps-&gt;min_tb_addr_zs_tab) {
        ret = AVERROR(ENOMEM);
        goto err;
    }

    for (ctb_addr_rs = 0; ctb_addr_rs &lt; pic_area_in_ctbs; ctb_addr_rs++) {
        int tb_x   = ctb_addr_rs % sps-&gt;ctb_width;
        int tb_y   = ctb_addr_rs / sps-&gt;ctb_width;
        int tile_x = 0;
        int tile_y = 0;
        int val    = 0;

        for (i = 0; i &lt; pps-&gt;num_tile_columns; i++) {
            if (tb_x &lt; pps-&gt;col_bd[i + 1]) {
                tile_x = i;
                break;
            }
        }

        for (i = 0; i &lt; pps-&gt;num_tile_rows; i++) {
            if (tb_y &lt; pps-&gt;row_bd[i + 1]) {
                tile_y = i;
                break;
            }
        }

        for (i = 0; i &lt; tile_x; i++)
            val += pps-&gt;row_height[tile_y] * pps-&gt;column_width[i];
        for (i = 0; i &lt; tile_y; i++)
            val += sps-&gt;ctb_width * pps-&gt;row_height[i];

        val += (tb_y - pps-&gt;row_bd[tile_y]) * pps-&gt;column_width[tile_x] +
               tb_x - pps-&gt;col_bd[tile_x];

        pps-&gt;ctb_addr_rs_to_ts[ctb_addr_rs] = val;
        pps-&gt;ctb_addr_ts_to_rs[val]         = ctb_addr_rs;
    }

    for (j = 0, tile_id = 0; j &lt; pps-&gt;num_tile_rows; j++)
        for (i = 0; i &lt; pps-&gt;num_tile_columns; i++, tile_id++)
            for (y = pps-&gt;row_bd[j]; y &lt; pps-&gt;row_bd[j + 1]; y++)
                for (x = pps-&gt;col_bd[i]; x &lt; pps-&gt;col_bd[i + 1]; x++)
                    pps-&gt;tile_id[pps-&gt;ctb_addr_rs_to_ts[y * sps-&gt;ctb_width + x]] = tile_id;

    pps-&gt;tile_pos_rs = av_malloc_array(tile_id, sizeof(*pps-&gt;tile_pos_rs));
    if (!pps-&gt;tile_pos_rs) {
        ret = AVERROR(ENOMEM);
        goto err;
    }

    for (j = 0; j &lt; pps-&gt;num_tile_rows; j++)
        for (i = 0; i &lt; pps-&gt;num_tile_columns; i++)
            pps-&gt;tile_pos_rs[j * pps-&gt;num_tile_columns + i] = pps-&gt;row_bd[j] * sps-&gt;ctb_width + pps-&gt;col_bd[i];

    log2_diff_ctb_min_tb_size = sps-&gt;log2_ctb_size - sps-&gt;log2_min_tb_size;
    pps-&gt;min_tb_addr_zs = &amp;pps-&gt;min_tb_addr_zs_tab[1*(sps-&gt;tb_mask+2)+1];
    for (y = 0; y &lt; sps-&gt;tb_mask+2; y++) {
        pps-&gt;min_tb_addr_zs_tab[y*(sps-&gt;tb_mask+2)] = -1;
        pps-&gt;min_tb_addr_zs_tab[y]    = -1;
    }
    for (y = 0; y &lt; sps-&gt;tb_mask+1; y++) {
        for (x = 0; x &lt; sps-&gt;tb_mask+1; x++) {
            int tb_x        = x &gt;&gt; log2_diff_ctb_min_tb_size;
            int tb_y        = y &gt;&gt; log2_diff_ctb_min_tb_size;
            int ctb_addr_rs = sps-&gt;ctb_width * tb_y + tb_x;
            int val         = pps-&gt;ctb_addr_rs_to_ts[ctb_addr_rs] &lt;&lt;
                              (log2_diff_ctb_min_tb_size * 2);
            for (i = 0; i &lt; log2_diff_ctb_min_tb_size; i++) {
                int m = 1 &lt;&lt; i;
                val += (m &amp; x ? m * m : 0) + (m &amp; y ? 2 * m * m : 0);
            }
            pps-&gt;min_tb_addr_zs[y * (sps-&gt;tb_mask+2) + x] = val;
        }
    }

    if (get_bits_left(gb) &lt; 0) {
        av_log(s-&gt;avctx, AV_LOG_ERROR,
               "Overread PPS by %d bits\n", -get_bits_left(gb));
        goto err;
    }

    av_buffer_unref(&amp;s-&gt;pps_list[pps_id]);
    s-&gt;pps_list[pps_id] = pps_buf;

    return 0;

err:
    av_buffer_unref(&amp;pps_buf);
    return ret;
}
</pre>
    <br/>
    与解析SPS类似，解析PPS源代码并不是很有“技术含量”。只要参考ITU-T的《H.264标准》就可以理解了，不再做过多详细的分析。
    <br/>
    <br/>
    <h2>
     ff_hevc_decode_nal_sei()
    </h2>
    ff_hevc_decode_nal_sei()用于解析HEVC码流中的SEI。该函数的定义位于libavcodec\hevc_sei.c，如下所示。
    <br/>
    <pre class="cpp">//解析SEI
int ff_hevc_decode_nal_sei(HEVCContext *s)
{
    int ret;

    do {
    	//解析SEI信息
        ret = decode_nal_sei_message(s);
        if (ret &lt; 0)
            return(AVERROR(ENOMEM));
    } while (more_rbsp_data(&amp;s-&gt;HEVClc-&gt;gb));
    return 1;
}
</pre>
    <br/>
    <p>
     从源代码可以看出，ff_hevc_decode_nal_sei()在一个do while循环中调用了另外一个函数decode_nal_sei_message()解析SEI信息。
    </p>
    <p>
     <br/>
    </p>
    <h3>
     decode_nal_sei_message()
    </h3>
    decode_nal_sei_message()用于解析SEI信息，它的定义如下。
    <br/>
    <pre class="cpp">//解析SEI信息
static int decode_nal_sei_message(HEVCContext *s)
{
    GetBitContext *gb = &amp;s-&gt;HEVClc-&gt;gb;

    int payload_type = 0;
    int payload_size = 0;
    int byte = 0xFF;
    av_log(s-&gt;avctx, AV_LOG_DEBUG, "Decoding SEI\n");

    while (byte == 0xFF) {
        byte          = get_bits(gb, 8);
        payload_type += byte;
    }
    byte = 0xFF;
    while (byte == 0xFF) {
        byte          = get_bits(gb, 8);
        payload_size += byte;
    }
    if (s-&gt;nal_unit_type == NAL_SEI_PREFIX) {
        if (payload_type == 256 /*&amp;&amp; s-&gt;decode_checksum_sei*/) {
            decode_nal_sei_decoded_picture_hash(s);
        } else if (payload_type == 45) {
            decode_nal_sei_frame_packing_arrangement(s);
        } else if (payload_type == 47) {
            decode_nal_sei_display_orientation(s);
        } else if (payload_type == 1){
            int ret = decode_pic_timing(s);
            av_log(s-&gt;avctx, AV_LOG_DEBUG, "Skipped PREFIX SEI %d\n", payload_type);
            skip_bits(gb, 8 * payload_size);
            return ret;
        } else if (payload_type == 129){
            active_parameter_sets(s);
            av_log(s-&gt;avctx, AV_LOG_DEBUG, "Skipped PREFIX SEI %d\n", payload_type);
        } else {
            av_log(s-&gt;avctx, AV_LOG_DEBUG, "Skipped PREFIX SEI %d\n", payload_type);
            skip_bits(gb, 8*payload_size);
        }
    } else { /* nal_unit_type == NAL_SEI_SUFFIX */
        if (payload_type == 132 /* &amp;&amp; s-&gt;decode_checksum_sei */)
            decode_nal_sei_decoded_picture_hash(s);
        else {
            av_log(s-&gt;avctx, AV_LOG_DEBUG, "Skipped SUFFIX SEI %d\n", payload_type);
            skip_bits(gb, 8 * payload_size);
        }
    }
    return 1;
}
</pre>
    <br/>
    从源代码可以看出，decode_nal_sei_message()根据不同的payload_type调用不同的函数进行处理，例如调用decode_nal_sei_decoded_picture_hash()，decode_nal_sei_frame_packing_arrangement()，decode_nal_sei_display_orientation()等等。
    <br/>
    <br/>
    <br/>
    <br/>
    <br/>
    <strong>
     <span style="color:#990000;">
      雷霄骅
      <br/>
      leixiaohua1020@126.com
      <br/>
      http://blog.csdn.net/leixiaohua1020
      <br/>
     </span>
    </strong>
    <br/>
   </div>
  </div>
  <div style="display:none;" class="hide-article-box text-center csdn-tracking-statistics tracking-click" data-mod="popu_376">
   <a class="btn btn-red-hollow" id="btn-readmore">
    阅读更多
   </a>
  </div>
 </article>
 <div class="article-bar-bottom">
  <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。			https://blog.csdn.net/leixiaohua1020/article/details/46412607
  </div>
  <div class="tags-box artic-tag-box">
   <span class="label">
    文章标签：
   </span>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=FFmpeg&amp;t=blog" target="_blank">
    FFmpeg
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=解析&amp;t=blog" target="_blank">
    解析
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=VPS&amp;t=blog" target="_blank">
    VPS
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=SPS&amp;t=blog" target="_blank">
    SPS
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=PPS&amp;t=blog" target="_blank">
    PPS
   </a>
  </div>
  <div class="tags-box">
   <span class="label">
    个人分类：
   </span>
   <a class="tag-link" href="https://blog.csdn.net/leixiaohua1020/article/category/1360795" target="_blank">
    FFMPEG
   </a>
  </div>
  <div class="tags-box">
   <span class="label">
    所属专栏：
   </span>
   <a class="tag-link" href="https://blog.csdn.net/column/details/ffmpeg-devel.html" target="_blank">
    FFmpeg
   </a>
  </div>
 </div>
 <!-- !empty($pre_next_article[0]) -->
</div>
<div class="recommend-box">
                            <div style="background: #fff; border: dashed 1px #666; padding-left: 1em; padding-top: 1em; padding-bottom: 1em;">
                                <span style="font-size: 0.8em; font-weight: bold;">
                                    此PDF由<a style="color:#0000ff" href="http://www.github.com/spygg"  target="_blank">spygg</a>生成,请尊重原作者版权!!!
                                    <br/>
                                    我的邮箱:liushidc@163.com
                                </span>
                                </div> 
                        </div>
                    </main>
      
                </div>

            <script>
                var recommendCount = 0;
                var articleTit = "";
                var articleId = "";
                var commentscount = 0;

                //1禁止评论，2正常
                var commentAuth = 1;
                //百度搜索
                var baiduKey = "";
                var needInsertBaidu = "";
            </script>
            <script src="https://csdnimg.cn/release/phoenix/template/js/detail-effe72036e.min.js"></script>
            </body>
        </html>