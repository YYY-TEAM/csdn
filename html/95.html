
            <!DOCTYPE html>
            <html lang="zh-CN">
                <head>
                    <meta charset="UTF-8">
                    <title>
 FFmpeg源代码简单分析：常见结构体的初始化和销毁（AVFormatContext，AVFrame等） - CSDN博客
</title>

                <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-60a2c245da.min.css">
                <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-88717cedf2.min.css">

                <script type="text/javascript">
                var username = "";
                </script>

                <script src="https://csdnimg.cn/public/common/libs/jquery/jquery-1.9.1.min.js" type="text/javascript"></script>

                <!-- 新版上报 -->
                <!-- 新版上报end -->
                <link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.3/css/sandalstrap.min.css"> 
                </head>
                <body>    
        
                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
                    <div class="container clearfix pt0" id="mainBox">
        <main style="width: 100%;"><div class="blog-content-box">
 <div class="article-title-box" id="article_anchors_95">
  <span class="article-type type-1 float-left">
   原
  </span>
  <h1 class="title-article">
   FFmpeg源代码简单分析：常见结构体的初始化和销毁（AVFormatContext，AVFrame等）
  </h1>
 </div>
 <div class="article-info-box">
  <div class="article-bar-top d-flex">
   <span class="time">
    2015年03月03日 16:25:13
   </span>
   <div ">
    <span class="read-count">
     阅读数：41683
    </span>
   </div>
  </div>
 </div>
 <article>
  <div class="article_content clearfix csdn-tracking-statistics" data-dsm="post" data-mod="popu_307" data-pid="blog" id="article_content">
   <link href="https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css" rel="stylesheet"/>
   <div class="htmledit_views">
    <p>
    </p>
    <p align="left">
     =====================================================
    </p>
    <p align="left">
     FFmpeg的库函数源代码分析文章列表：
    </p>
    <p align="left">
     【架构图】
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44220151">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码结构图 -
      </span>
      <span style="color:#0000FF;">
       解码
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44226355">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码结构图 -
      </span>
      <span style="color:#0000FF;">
       编码
      </span>
     </a>
    </p>
    <p align="left">
     【通用】
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/12677129">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       av_register_all()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/12677265">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avcodec_register_all()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/41176777">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：内存的分配和释放（
      </span>
      <span style="color:#0000FF;">
       av_malloc()
      </span>
      <span style="color:#0000FF;">
       、
      </span>
      <span style="color:#0000FF;">
       av_free()
      </span>
      <span style="color:#0000FF;">
       等）
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/41181155">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：常见结构体的初始化和销毁（
      </span>
      <span style="color:#0000FF;">
       AVFormatContext
      </span>
      <span style="color:#0000FF;">
       ，
      </span>
      <span style="color:#0000FF;">
       AVFrame
      </span>
      <span style="color:#0000FF;">
       等）
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/41199947">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avio_open2()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44084557">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       av_find_decoder()
      </span>
      <span style="color:#0000FF;">
       和
      </span>
      <span style="color:#0000FF;">
       av_find_encoder()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44117891">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avcodec_open2()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44206699">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avcodec_close()
      </span>
     </a>
    </p>
    <p align="left">
     【解码】
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/8661601">
      <span style="color:#0000FF;">
       图解
      </span>
      <span style="color:#0000FF;">
       FFMPEG
      </span>
      <span style="color:#0000FF;">
       打开媒体的函数
      </span>
      <span style="color:#0000FF;">
       avformat_open_input
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44064715">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avformat_open_input()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44084321">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avformat_find_stream_info()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/12678577">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       av_read_frame()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/12679719">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avcodec_decode_video2()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44110683">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avformat_close_input()
      </span>
     </a>
    </p>
    <p align="left">
     【编码】
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/41198929">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avformat_alloc_output_context2()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44116215">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avformat_write_header()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44206485">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avcodec_encode_video()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44199673">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       av_write_frame()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44201645">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       av_write_trailer()
      </span>
     </a>
    </p>
    <p align="left">
     【其它】
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44243155">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：日志输出系统（
      </span>
      <span style="color:#0000FF;">
       av_log()
      </span>
      <span style="color:#0000FF;">
       等）
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44268323">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：结构体成员管理系统
      </span>
      <span style="color:#0000FF;">
       -AVClass
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44279329">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：结构体成员管理系统
      </span>
      <span style="color:#0000FF;">
       -AVOption
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44305697">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       libswscale
      </span>
      <span style="color:#0000FF;">
       的
      </span>
      <span style="color:#0000FF;">
       sws_getContext()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44346687">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       libswscale
      </span>
      <span style="color:#0000FF;">
       的
      </span>
      <span style="color:#0000FF;">
       sws_scale()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/41211121">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       libavdevice
      </span>
      <span style="color:#0000FF;">
       的
      </span>
      <span style="color:#0000FF;">
       avdevice_register_all()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44597955">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       libavdevice
      </span>
      <span style="color:#0000FF;">
       的
      </span>
      <span style="color:#0000FF;">
       gdigrab
      </span>
     </a>
    </p>
    <p align="left">
     【脚本】
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44556525">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       makefile
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44587465">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       configure
      </span>
     </a>
    </p>
    <p align="left">
     【H.264】
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44864509">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       的
      </span>
      <span style="color:#0000FF;">
       H.264
      </span>
      <span style="color:#0000FF;">
       解码器源代码简单分析：概述
      </span>
     </a>
    </p>
    <p align="left">
     =====================================================
    </p>
    <br/>
    <p>
     本文简单分析FFmpeg常见结构体的初始化和销毁函数的源代码。常见的结构体在文章：
    </p>
    <p>
     《
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/11693997">
      FFMPEG中最关键的结构体之间的关系
     </a>
     》中已经有过叙述，包括：
    </p>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
     <p>
      AVFormatContext：统领全局的基本结构体。主要用于处理封装格式（FLV/MKV/RMVB等）。
     </p>
     <p>
      AVIOContext：输入输出对应的结构体，用于输入输出（读写文件，RTMP协议等）。
     </p>
     <p>
      AVStream，AVCodecContext：视音频流对应的结构体，用于视音频编解码。
     </p>
     <p>
      AVFrame：存储非压缩的数据（视频对应RGB/YUV像素数据，音频对应PCM采样数据）
     </p>
     <p>
      AVPacket：存储压缩数据（视频对应H.264等码流数据，音频对应AAC/MP3等码流数据）
     </p>
    </blockquote>
    <p>
     他们之间的关系如下图所示（详细信息可以参考上文提到的文章）。
    </p>
    <p style="text-align:center;">
     <img alt="" src="https://img-blog.csdn.net/20150303154557805"/>
     <br/>
    </p>
    <p style="text-align:center;">
     <br/>
    </p>
    <p>
     下文简单分析一下上述几个结构体的初始化和销毁函数。这些函数列表如下。
    </p>
    <p>
     <br/>
    </p>
    <table align="center" border="1" cellpadding="0" cellspacing="0" width="500">
     <tbody>
      <tr>
       <td valign="top">
        <p>
         结构体
        </p>
       </td>
       <td valign="top">
        <p>
         初始化
        </p>
       </td>
       <td valign="top">
        <p>
         销毁
        </p>
       </td>
      </tr>
      <tr>
       <td valign="top">
        <p>
         AVFormatContext
        </p>
       </td>
       <td valign="top">
        <p>
         avformat_alloc_context()
        </p>
       </td>
       <td valign="top">
        <p>
         avformat_free_context()
        </p>
       </td>
      </tr>
      <tr>
       <td valign="top">
        <p>
         AVIOContext
        </p>
       </td>
       <td valign="top">
        <p>
         avio_alloc_context()
        </p>
       </td>
       <td valign="top">
        <p>
        </p>
       </td>
      </tr>
      <tr>
       <td valign="top">
        <p>
         AVStream
        </p>
       </td>
       <td valign="top">
        <p>
         avformat_new_stream()
        </p>
       </td>
       <td valign="top">
        <p>
        </p>
       </td>
      </tr>
      <tr>
       <td valign="top">
        <p>
         AVCodecContext
        </p>
       </td>
       <td valign="top">
        <p>
         avcodec_alloc_context3()
        </p>
       </td>
       <td valign="top">
        <p>
        </p>
       </td>
      </tr>
      <tr>
       <td valign="top">
        <p>
         AVFrame
        </p>
       </td>
       <td valign="top">
        <p>
         av_frame_alloc();
        </p>
        <p>
         av_image_fill_arrays()
        </p>
       </td>
       <td valign="top">
        <p>
         av_frame_free()
        </p>
       </td>
      </tr>
      <tr>
       <td valign="top">
        <p>
         AVPacket
        </p>
       </td>
       <td valign="top">
        <p>
         av_init_packet();
        </p>
        <p>
         av_new_packet()
        </p>
       </td>
       <td valign="top">
        <p>
         av_free_packet()
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <br/>
    <p>
     <br/>
    </p>
    <p>
     下面进入正文。
    </p>
    <br/>
    <h2>
     AVFormatContext
    </h2>
    AVFormatContext的初始化函数是avformat_alloc_context()，销毁函数是avformat_free_context()。
    <br/>
    <br/>
    <h3>
     avformat_alloc_context()
    </h3>
    <p>
    </p>
    <p>
     avformat_alloc_context()的声明位于libavformat\avformat.h，如下所示。
    </p>
    <div>
     <p>
     </p>
     <pre class="cpp">/**
 * Allocate an AVFormatContext.
 * avformat_free_context() can be used to freethe context and everything
 * allocated by the framework within it.
 */
AVFormatContext*avformat_alloc_context(void);</pre>
     <p>
     </p>
    </div>
    <p>
     avformat_alloc_context()的定义位于libavformat\options.c。代码如下所示。
    </p>
    <pre class="cpp">AVFormatContext *avformat_alloc_context(void)
{
    AVFormatContext *ic;
    ic = av_malloc(sizeof(AVFormatContext));
    if (!ic) return ic;
    avformat_get_context_defaults(ic);


    ic-&gt;internal = av_mallocz(sizeof(*ic-&gt;internal));
    if (!ic-&gt;internal) {
        avformat_free_context(ic);
        return NULL;
    }


    return ic;
}</pre>
    <br/>
    从代码中可以看出，avformat_alloc_context()调用av_malloc()为AVFormatContext结构体分配了内存，而且同时也给AVFormatContext中的internal字段分配内存（这个字段是FFmpeg内部使用的，先不分析）。此外调用了一个avformat_get_context_defaults()函数。该函数用于设置AVFormatContext的字段的默认值。它的定义也位于libavformat\options.c，确切的说就位于avformat_alloc_context()上面。我们看一下该函数的定义。
    <br/>
    <pre class="cpp">static void avformat_get_context_defaults(AVFormatContext *s)
{
    memset(s, 0, sizeof(AVFormatContext));


    s-&gt;av_class = &amp;av_format_context_class;


    av_opt_set_defaults(s);
}</pre>
    <br/>
    从代码可以看出，avformat_get_context_defaults()首先调用memset()将AVFormatContext的所有字段置0。而后调用了一个函数av_opt_set_defaults()。av_opt_set_defaults()用于给字段设置默认值。
    <br/>
    avformat_alloc_context()代码的函数调用关系如下图所示。
    <br/>
    <div style="text-align:center;">
     <img alt="" src="https://img-blog.csdn.net/20150303154603565"/>
     <br/>
    </div>
    <br/>
    <h3>
     avformat_free_context()
    </h3>
    <p>
     avformat_free_context()的声明位于libavformat\avformat.h，如下所示。
     <br/>
    </p>
    <p>
    </p>
    <pre class="cpp">/**
 * Free an AVFormatContext and all its streams.
 * @param s context to free
 */
void avformat_free_context(AVFormatContext *s);</pre>
    <p>
    </p>
    <p>
     avformat_free_context()的定义位于libavformat\options.c。代码如下所示。
    </p>
    <pre class="cpp">void avformat_free_context(AVFormatContext *s)
{
    int i;


    if (!s)
        return;


    av_opt_free(s);
    if (s-&gt;iformat &amp;&amp; s-&gt;iformat-&gt;priv_class &amp;&amp; s-&gt;priv_data)
        av_opt_free(s-&gt;priv_data);
    if (s-&gt;oformat &amp;&amp; s-&gt;oformat-&gt;priv_class &amp;&amp; s-&gt;priv_data)
        av_opt_free(s-&gt;priv_data);


    for (i = s-&gt;nb_streams - 1; i &gt;= 0; i--) {
        ff_free_stream(s, s-&gt;streams[i]);
    }
    for (i = s-&gt;nb_programs - 1; i &gt;= 0; i--) {
        av_dict_free(&amp;s-&gt;programs[i]-&gt;metadata);
        av_freep(&amp;s-&gt;programs[i]-&gt;stream_index);
        av_freep(&amp;s-&gt;programs[i]);
    }
    av_freep(&amp;s-&gt;programs);
    av_freep(&amp;s-&gt;priv_data);
    while (s-&gt;nb_chapters--) {
        av_dict_free(&amp;s-&gt;chapters[s-&gt;nb_chapters]-&gt;metadata);
        av_freep(&amp;s-&gt;chapters[s-&gt;nb_chapters]);
    }
    av_freep(&amp;s-&gt;chapters);
    av_dict_free(&amp;s-&gt;metadata);
    av_freep(&amp;s-&gt;streams);
    av_freep(&amp;s-&gt;internal);
    flush_packet_queue(s);
    av_free(s);
}</pre>
    <br/>
    从代码中可以看出，avformat_free_context()调用了各式各样的销毁函数：av_opt_free()，av_freep()，av_dict_free()。这些函数分别用于释放不同种类的变量，在这里不再详细讨论。在这里看一个释放AVStream的函数ff_free_stream()。该函数的定义位于libavformat\options.c（其实就在avformat_free_context()上方）。
    <br/>
    <pre class="cpp">void ff_free_stream(AVFormatContext *s, AVStream *st) {
    int j;
    av_assert0(s-&gt;nb_streams&gt;0);
    av_assert0(s-&gt;streams[ s-&gt;nb_streams - 1 ] == st);


    for (j = 0; j &lt; st-&gt;nb_side_data; j++)
        av_freep(&amp;st-&gt;side_data[j].data);
    av_freep(&amp;st-&gt;side_data);
    st-&gt;nb_side_data = 0;


    if (st-&gt;parser) {
        av_parser_close(st-&gt;parser);
    }
    if (st-&gt;attached_pic.data)
        av_free_packet(&amp;st-&gt;attached_pic);
    av_dict_free(&amp;st-&gt;metadata);
    av_freep(&amp;st-&gt;probe_data.buf);
    av_freep(&amp;st-&gt;index_entries);
    av_freep(&amp;st-&gt;codec-&gt;extradata);
    av_freep(&amp;st-&gt;codec-&gt;subtitle_header);
    av_freep(&amp;st-&gt;codec);
    av_freep(&amp;st-&gt;priv_data);
    if (st-&gt;info)
        av_freep(&amp;st-&gt;info-&gt;duration_error);
    av_freep(&amp;st-&gt;info);
    av_freep(&amp;s-&gt;streams[ --s-&gt;nb_streams ]);
}</pre>
    <br/>
    从代码中可以看出，与释放AVFormatContext类似，释放AVStream的时候，也是调用了av_freep()，av_dict_free()这些函数释放有关的字段。如果使用了parser的话，会调用av_parser_close()关闭该parser。
    <br/>
    <br/>
    <h2>
     AVIOContext
    </h2>
    <h3>
     avio_alloc_context()
    </h3>
    <p>
     AVIOContext的初始化函数是avio_alloc_context()，销毁的时候使用av_free()释放掉其中的缓存即可。它的声明位于libavformat\avio.h中，如下所示。
     <br/>
    </p>
    <p>
    </p>
    <pre class="cpp">/**
 * Allocate and initialize an AVIOContext for buffered I/O. It must be later
 * freed with av_free().
 *
 * @param buffer Memory block for input/output operations via AVIOContext.
 *        The buffer must be allocated with av_malloc() and friends.
 * @param buffer_size The buffer size is very important for performance.
 *        For protocols with fixed blocksize it should be set to this blocksize.
 *        For others a typical size is a cache page, e.g. 4kb.
 * @param write_flag Set to 1 if the buffer should be writable, 0 otherwise.
 * @param opaque An opaque pointer to user-specific data.
 * @param read_packet  A function for refilling the buffer, may be NULL.
 * @param write_packet A function for writing the buffer contents, may be NULL.
 *        The function may not change the input buffers content.
 * @param seek A function for seeking to specified byte position, may be NULL.
 *
 * @return Allocated AVIOContext or NULL on failure.
 */
AVIOContext *avio_alloc_context(
                  unsigned char *buffer,
                  int buffer_size,
                  int write_flag,
                  void *opaque,
                  int (*read_packet)(void *opaque, uint8_t *buf, int buf_size),
                  int (*write_packet)(void *opaque, uint8_t *buf, int buf_size),
                  int64_t (*seek)(void *opaque, int64_t offset, int whence));
</pre>
    <br/>
    <p>
    </p>
    <p>
     avio_alloc_context()定义位于libavformat\aviobuf.c中，如下所示。
    </p>
    <pre class="cpp">AVIOContext *avio_alloc_context(
                  unsigned char *buffer,
                  int buffer_size,
                  int write_flag,
                  void *opaque,
                  int (*read_packet)(void *opaque, uint8_t *buf, int buf_size),
                  int (*write_packet)(void *opaque, uint8_t *buf, int buf_size),
                  int64_t (*seek)(void *opaque, int64_t offset, int whence))
{
    AVIOContext *s = av_mallocz(sizeof(AVIOContext));
    if (!s)
        return NULL;
    ffio_init_context(s, buffer, buffer_size, write_flag, opaque,
                  read_packet, write_packet, seek);
    return s;
}</pre>
    <br/>
    从代码中可以看出，avio_alloc_context()首先调用av_mallocz()为AVIOContext分配内存。而后调用了一个函数ffio_init_context()。该函数完成了真正的初始化工作。我们看一下ffio_init_context()函数的定义。
    <br/>
    <pre class="cpp">int ffio_init_context(AVIOContext *s,
                  unsigned char *buffer,
                  int buffer_size,
                  int write_flag,
                  void *opaque,
                  int (*read_packet)(void *opaque, uint8_t *buf, int buf_size),
                  int (*write_packet)(void *opaque, uint8_t *buf, int buf_size),
                  int64_t (*seek)(void *opaque, int64_t offset, int whence))
{
    s-&gt;buffer      = buffer;
    s-&gt;orig_buffer_size =
    s-&gt;buffer_size = buffer_size;
    s-&gt;buf_ptr     = buffer;
    s-&gt;opaque      = opaque;
    s-&gt;direct      = 0;


    url_resetbuf(s, write_flag ? AVIO_FLAG_WRITE : AVIO_FLAG_READ);


    s-&gt;write_packet    = write_packet;
    s-&gt;read_packet     = read_packet;
    s-&gt;seek            = seek;
    s-&gt;pos             = 0;
    s-&gt;must_flush      = 0;
    s-&gt;eof_reached     = 0;
    s-&gt;error           = 0;
    s-&gt;seekable        = seek ? AVIO_SEEKABLE_NORMAL : 0;
    s-&gt;max_packet_size = 0;
    s-&gt;update_checksum = NULL;


    if (!read_packet &amp;&amp; !write_flag) {
        s-&gt;pos     = buffer_size;
        s-&gt;buf_end = s-&gt;buffer + buffer_size;
    }
    s-&gt;read_pause = NULL;
    s-&gt;read_seek  = NULL;


    return 0;
}</pre>
    <br/>
    从函数的代码可以看出，ffio_init_context()对AVIOContext中的缓存，函数指针等等进行了赋值。
    <br/>
    <br/>
    <br/>
    <h2>
     AVStream，AVCodecContext
    </h2>
    <p>
     AVStream的初始化函数是avformat_new_stream()，销毁函数使用销毁AVFormatContext的avformat_free_context()就可以了。
    </p>
    <p>
     <br/>
    </p>
    <h3>
     avformat_new_stream()
    </h3>
    <p>
     avformat_new_stream()的声明位于libavformat\avformat.h中，如下所示。
     <br/>
    </p>
    <p>
    </p>
    <pre class="cpp">/**
 * Add a new stream to a media file.
 *
 * When demuxing, it is called by the demuxer in read_header(). If the
 * flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also
 * be called in read_packet().
 *
 * When muxing, should be called by the user before avformat_write_header().
 *
 * User is required to call avcodec_close() and avformat_free_context() to
 * clean up the allocation by avformat_new_stream().
 *
 * @param s media file handle
 * @param c If non-NULL, the AVCodecContext corresponding to the new stream
 * will be initialized to use this codec. This is needed for e.g. codec-specific
 * defaults to be set, so codec should be provided if it is known.
 *
 * @return newly created stream or NULL on error.
 */
AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c);</pre>
    <p>
    </p>
    <p>
     avformat_new_stream()的定义位于libavformat\utils.c中，如下所示。
    </p>
    <pre class="cpp">AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c)
{
    AVStream *st;
    int i;
    AVStream **streams;


    if (s-&gt;nb_streams &gt;= INT_MAX/sizeof(*streams))
        return NULL;
    streams = av_realloc_array(s-&gt;streams, s-&gt;nb_streams + 1, sizeof(*streams));
    if (!streams)
        return NULL;
    s-&gt;streams = streams;


    st = av_mallocz(sizeof(AVStream));
    if (!st)
        return NULL;
    if (!(st-&gt;info = av_mallocz(sizeof(*st-&gt;info)))) {
        av_free(st);
        return NULL;
    }
    st-&gt;info-&gt;last_dts = AV_NOPTS_VALUE;


    st-&gt;codec = avcodec_alloc_context3(c);
    if (s-&gt;iformat) {
        /* no default bitrate if decoding */
        st-&gt;codec-&gt;bit_rate = 0;


        /* default pts setting is MPEG-like */
        avpriv_set_pts_info(st, 33, 1, 90000);
    }


    st-&gt;index      = s-&gt;nb_streams;
    st-&gt;start_time = AV_NOPTS_VALUE;
    st-&gt;duration   = AV_NOPTS_VALUE;
    /* we set the current DTS to 0 so that formats without any timestamps
     * but durations get some timestamps, formats with some unknown
     * timestamps have their first few packets buffered and the
     * timestamps corrected before they are returned to the user */
    st-&gt;cur_dts       = s-&gt;iformat ? RELATIVE_TS_BASE : 0;
    st-&gt;first_dts     = AV_NOPTS_VALUE;
    st-&gt;probe_packets = MAX_PROBE_PACKETS;
    st-&gt;pts_wrap_reference = AV_NOPTS_VALUE;
    st-&gt;pts_wrap_behavior = AV_PTS_WRAP_IGNORE;


    st-&gt;last_IP_pts = AV_NOPTS_VALUE;
    st-&gt;last_dts_for_order_check = AV_NOPTS_VALUE;
    for (i = 0; i &lt; MAX_REORDER_DELAY + 1; i++)
        st-&gt;pts_buffer[i] = AV_NOPTS_VALUE;


    st-&gt;sample_aspect_ratio = (AVRational) { 0, 1 };


#if FF_API_R_FRAME_RATE
    st-&gt;info-&gt;last_dts      = AV_NOPTS_VALUE;
#endif
    st-&gt;info-&gt;fps_first_dts = AV_NOPTS_VALUE;
    st-&gt;info-&gt;fps_last_dts  = AV_NOPTS_VALUE;


    st-&gt;inject_global_side_data = s-&gt;internal-&gt;inject_global_side_data;


    s-&gt;streams[s-&gt;nb_streams++] = st;
    return st;
}</pre>
    <br/>
    <p>
     从代码中可以看出，avformat_new_stream()首先调用av_mallocz()为AVStream分配内存。接着给新分配的AVStream的各个字段赋上默认值。然后调用了另一个函数avcodec_alloc_context3()初始化AVStream中的AVCodecContext。
    </p>
    <p>
     <br/>
    </p>
    <h3>
     avcodec_alloc_context3()
    </h3>
    <p>
     avcodec_alloc_context3()的声明位于libavcodec\avcodec.h中，如下所示。
     <br/>
    </p>
    <p>
    </p>
    <pre class="cpp">/**
 * Allocate an AVCodecContext and set its fields to default values. The
 * resulting struct should be freed with avcodec_free_context().
 *
 * @param codec if non-NULL, allocate private data and initialize defaults
 *              for the given codec. It is illegal to then call avcodec_open2()
 *              with a different codec.
 *              If NULL, then the codec-specific defaults won't be initialized,
 *              which may result in suboptimal default settings (this is
 *              important mainly for encoders, e.g. libx264).
 *
 * @return An AVCodecContext filled with default values or NULL on failure.
 * @see avcodec_get_context_defaults
 */
AVCodecContext *avcodec_alloc_context3(const AVCodec *codec);
</pre>
    <p>
     <br/>
    </p>
    <p>
     下面我们看一下avcodec_alloc_context3()的定义。下面我们看一下avcodec_alloc_context3()的定义。avcodec_alloc_context3()的定义位于libavcodec\options.c中。
    </p>
    <pre class="cpp">AVCodecContext *avcodec_alloc_context3(const AVCodec *codec)
{
    AVCodecContext *avctx= av_malloc(sizeof(AVCodecContext));


    if (!avctx)
        return NULL;


    if(avcodec_get_context_defaults3(avctx, codec) &lt; 0){
        av_free(avctx);
        return NULL;
    }


    return avctx;
}</pre>
    <br/>
    <p>
     从代码中可以看出，avcodec_alloc_context3()首先调用av_malloc()为AVCodecContext分配存储空间，然后调用了一个函数avcodec_get_context_defaults3()用于设置该AVCodecContext的默认值。avcodec_get_context_defaults3()的定义如下。
    </p>
    <p>
    </p>
    <pre class="cpp">int avcodec_get_context_defaults3(AVCodecContext *s, const AVCodec *codec)
{
    int flags=0;
    memset(s, 0, sizeof(AVCodecContext));


    s-&gt;av_class = &amp;av_codec_context_class;


    s-&gt;codec_type = codec ? codec-&gt;type : AVMEDIA_TYPE_UNKNOWN;
    if (codec)
        s-&gt;codec_id = codec-&gt;id;


    if(s-&gt;codec_type == AVMEDIA_TYPE_AUDIO)
        flags= AV_OPT_FLAG_AUDIO_PARAM;
    else if(s-&gt;codec_type == AVMEDIA_TYPE_VIDEO)
        flags= AV_OPT_FLAG_VIDEO_PARAM;
    else if(s-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE)
        flags= AV_OPT_FLAG_SUBTITLE_PARAM;
    av_opt_set_defaults2(s, flags, flags);


    s-&gt;time_base           = (AVRational){0,1};
    s-&gt;get_buffer2         = avcodec_default_get_buffer2;
    s-&gt;get_format          = avcodec_default_get_format;
    s-&gt;execute             = avcodec_default_execute;
    s-&gt;execute2            = avcodec_default_execute2;
    s-&gt;sample_aspect_ratio = (AVRational){0,1};
    s-&gt;pix_fmt             = AV_PIX_FMT_NONE;
    s-&gt;sample_fmt          = AV_SAMPLE_FMT_NONE;
    s-&gt;timecode_frame_start = -1;


    s-&gt;reordered_opaque    = AV_NOPTS_VALUE;
    if(codec &amp;&amp; codec-&gt;priv_data_size){
        if(!s-&gt;priv_data){
            s-&gt;priv_data= av_mallocz(codec-&gt;priv_data_size);
            if (!s-&gt;priv_data) {
                return AVERROR(ENOMEM);
            }
        }
        if(codec-&gt;priv_class){
            *(const AVClass**)s-&gt;priv_data = codec-&gt;priv_class;
            av_opt_set_defaults(s-&gt;priv_data);
        }
    }
    if (codec &amp;&amp; codec-&gt;defaults) {
        int ret;
        const AVCodecDefault *d = codec-&gt;defaults;
        while (d-&gt;key) {
            ret = av_opt_set(s, d-&gt;key, d-&gt;value, 0);
            av_assert0(ret &gt;= 0);
            d++;
        }
    }
    return 0;
}</pre>
    <br/>
    <p>
    </p>
    avformat_new_stream()函数的调用结构如下所示。
    <br/>
    <div style="text-align:center;">
     <img alt="" src="https://img-blog.csdn.net/20150303154628119"/>
    </div>
    <br/>
    <h2>
     AVFrame
    </h2>
    AVFrame的初始化函数是av_frame_alloc()，销毁函数是av_frame_free()。在这里有一点需要注意，旧版的FFmpeg都是使用avcodec_alloc_frame()初始化AVFrame的，但是我在写这篇文章的时候，avcodec_alloc_frame()已经被标记为“过时的”了，为了保证与时俱进，决定分析新的API——av_frame_alloc()。
    <br/>
    <br/>
    <h3>
     av_frame_alloc()
    </h3>
    <p>
     av_frame_alloc()的声明位于libavutil\frame.h，如下所示。
     <br/>
    </p>
    <p>
    </p>
    <pre class="cpp">/**
 * Allocate an AVFrame and set its fields to default values.  The resulting
 * struct must be freed using av_frame_free().
 *
 * @return An AVFrame filled with default values or NULL on failure.
 *
 * @note this only allocates the AVFrame itself, not the data buffers. Those
 * must be allocated through other means, e.g. with av_frame_get_buffer() or
 * manually.
 */
AVFrame *av_frame_alloc(void);</pre>
    <p>
    </p>
    <p>
     av_frame_alloc()的定义位于libavutil\frame.c。代码如下所示。
    </p>
    <pre class="cpp">AVFrame *av_frame_alloc(void)
{
    AVFrame *frame = av_mallocz(sizeof(*frame));


    if (!frame)
        return NULL;


    frame-&gt;extended_data = NULL;
    get_frame_defaults(frame);


    return frame;
}</pre>
    <br/>
    从代码可以看出，av_frame_alloc()首先调用av_mallocz()为AVFrame结构体分配内存。而后调用了一个函数get_frame_defaults()用于设置一些默认参数。get_frame_defaults()定义如下。
    <br/>
    <pre class="cpp">static void get_frame_defaults(AVFrame *frame)
{
    if (frame-&gt;extended_data != frame-&gt;data)
        av_freep(&amp;frame-&gt;extended_data);


    memset(frame, 0, sizeof(*frame));


    frame-&gt;pts                   =
    frame-&gt;pkt_dts               =
    frame-&gt;pkt_pts               = AV_NOPTS_VALUE;
    av_frame_set_best_effort_timestamp(frame, AV_NOPTS_VALUE);
    av_frame_set_pkt_duration         (frame, 0);
    av_frame_set_pkt_pos              (frame, -1);
    av_frame_set_pkt_size             (frame, -1);
    frame-&gt;key_frame           = 1;
    frame-&gt;sample_aspect_ratio = (AVRational){ 0, 1 };
    frame-&gt;format              = -1; /* unknown */
    frame-&gt;extended_data       = frame-&gt;data;
    frame-&gt;color_primaries     = AVCOL_PRI_UNSPECIFIED;
    frame-&gt;color_trc           = AVCOL_TRC_UNSPECIFIED;
    frame-&gt;colorspace          = AVCOL_SPC_UNSPECIFIED;
    frame-&gt;color_range         = AVCOL_RANGE_UNSPECIFIED;
    frame-&gt;chroma_location     = AVCHROMA_LOC_UNSPECIFIED;
}</pre>
    <br/>
    <p>
     从av_frame_alloc()的代码我们可以看出，该函数并没有为AVFrame的像素数据分配空间。因此AVFrame中的像素数据的空间需要自行分配空间，例如使用avpicture_fill()，av_image_fill_arrays()等函数。
    </p>
    <p>
     av_frame_alloc()函数的调用结构如下所示。
     <br/>
    </p>
    <p style="text-align:center;">
     <img alt="" src="https://img-blog.csdn.net/20150303155013415?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
     <br/>
    </p>
    <p style="text-align:left;">
     <br/>
    </p>
    <h3>
     avpicture_fill()
    </h3>
    <p>
     avpicture_fill()的声明位于libavcodec\avcodec.h，如下所示。
     <br/>
    </p>
    <p>
    </p>
    <pre class="cpp">/**
 * Setup the picture fields based on the specified image parameters
 * and the provided image data buffer.
 *
 * The picture fields are filled in by using the image data buffer
 * pointed to by ptr.
 *
 * If ptr is NULL, the function will fill only the picture linesize
 * array and return the required size for the image buffer.
 *
 * To allocate an image buffer and fill the picture data in one call,
 * use avpicture_alloc().
 *
 * @param picture       the picture to be filled in
 * @param ptr           buffer where the image data is stored, or NULL
 * @param pix_fmt       the pixel format of the image
 * @param width         the width of the image in pixels
 * @param height        the height of the image in pixels
 * @return the size in bytes required for src, a negative error code
 * in case of failure
 *
 * @see av_image_fill_arrays()
 */
int avpicture_fill(AVPicture *picture, const uint8_t *ptr,
                   enum AVPixelFormat pix_fmt, int width, int height);
</pre>
    <br/>
    <p>
    </p>
    <p>
     avpicture_fill()的定义位于libavcodec\avpicture.c，如下所示。
    </p>
    <span style="font-family:'KaiTi_GB2312';">
     PS：目测这个函数未来也有可能成为“过时的”函数，因为通过观察这一年FFmpeg代码的变化，发现FFmpeg组织似乎想把AVFrame相关的函数（原先定义在AVCodec的头文件中）从AVCodec的代码中分离出来，形成一套单独的API。所以很多和AVFrame相关的名称为avcodec_XXX()的函数都被标记上了“过时的”标记。当然，上述推测也是我自己猜测的。
    </span>
    <br/>
    <pre class="cpp">int avpicture_fill(AVPicture *picture, const uint8_t *ptr,
                   enum AVPixelFormat pix_fmt, int width, int height)
{
    return av_image_fill_arrays(picture-&gt;data, picture-&gt;linesize,
                                ptr, pix_fmt, width, height, 1);
}</pre>
    <br/>
    <p>
     从代码中可以看出，avpicture_fill()仅仅是简单调用了一下av_image_fill_arrays()。也就是说这两个函数实际上是等同的。
    </p>
    <p>
     <br/>
    </p>
    <h3>
     av_image_fill_arrays()
    </h3>
    <p>
     av_image_fill_arrays()的声明位于libavutil\imgutils.h中，如下所示。
     <br/>
    </p>
    <p>
    </p>
    <pre class="cpp">/**
 * Setup the data pointers and linesizes based on the specified image
 * parameters and the provided array.
 *
 * The fields of the given image are filled in by using the src
 * address which points to the image data buffer. Depending on the
 * specified pixel format, one or multiple image data pointers and
 * line sizes will be set.  If a planar format is specified, several
 * pointers will be set pointing to the different picture planes and
 * the line sizes of the different planes will be stored in the
 * lines_sizes array. Call with !src to get the required
 * size for the src buffer.
 *
 * To allocate the buffer and fill in the dst_data and dst_linesize in
 * one call, use av_image_alloc().
 *
 * @param dst_data      data pointers to be filled in
 * @param dst_linesizes linesizes for the image in dst_data to be filled in
 * @param src           buffer which will contain or contains the actual image data, can be NULL
 * @param pix_fmt       the pixel format of the image
 * @param width         the width of the image in pixels
 * @param height        the height of the image in pixels
 * @param align         the value used in src for linesize alignment
 * @return the size in bytes required for src, a negative error code
 * in case of failure
 */
int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4],
                         const uint8_t *src,
                         enum AVPixelFormat pix_fmt, int width, int height, int align);
</pre>
    <br/>
    <p>
    </p>
    <p>
     av_image_fill_arrays()的定义位于libavutil\imgutils.c中。
    </p>
    <pre class="cpp">int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4],
                         const uint8_t *src,
                         enum AVPixelFormat pix_fmt, int width, int height, int align)
{
    int ret, i;


    if ((ret = av_image_check_size(width, height, 0, NULL)) &lt; 0)
        return ret;


    if ((ret = av_image_fill_linesizes(dst_linesize, pix_fmt, width)) &lt; 0)
        return ret;


    for (i = 0; i &lt; 4; i++)
        dst_linesize[i] = FFALIGN(dst_linesize[i], align);


    if ((ret = av_image_fill_pointers(dst_data, pix_fmt, width, NULL, dst_linesize)) &lt; 0)
        return ret;


    return av_image_fill_pointers(dst_data, pix_fmt, height, (uint8_t *)src, dst_linesize);
}</pre>
    <br/>
    av_image_fill_arrays()函数中包含3个函数：av_image_check_size()，av_image_fill_linesizes()，av_image_fill_pointers()。av_image_check_size()用于检查输入的宽高参数是否合理，即不能太大或者为负数。av_image_fill_linesizes()用于填充dst_linesize。av_image_fill_pointers()则用于填充dst_data。它们的定义相对比较简单，不再详细分析。
    <br/>
    av_image_check_size()代码如下所示。
    <br/>
    <pre class="cpp">int av_image_check_size(unsigned int w, unsigned int h, int log_offset, void *log_ctx)
{
    ImgUtils imgutils = { &amp;imgutils_class, log_offset, log_ctx };


    if ((int)w&gt;0 &amp;&amp; (int)h&gt;0 &amp;&amp; (w+128)*(uint64_t)(h+128) &lt; INT_MAX/8)
        return 0;


    av_log(&amp;imgutils, AV_LOG_ERROR, "Picture size %ux%u is invalid\n", w, h);
    return AVERROR(EINVAL);
}</pre>
    <br/>
    av_image_fill_linesizes()代码如下所示。
    <br/>
    <pre class="cpp">int av_image_fill_linesizes(int linesizes[4], enum AVPixelFormat pix_fmt, int width)
{
    int i, ret;
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);
    int max_step     [4];       /* max pixel step for each plane */
    int max_step_comp[4];       /* the component for each plane which has the max pixel step */


    memset(linesizes, 0, 4*sizeof(linesizes[0]));


    if (!desc || desc-&gt;flags &amp; AV_PIX_FMT_FLAG_HWACCEL)
        return AVERROR(EINVAL);


    av_image_fill_max_pixsteps(max_step, max_step_comp, desc);
    for (i = 0; i &lt; 4; i++) {
        if ((ret = image_get_linesize(width, i, max_step[i], max_step_comp[i], desc)) &lt; 0)
            return ret;
        linesizes[i] = ret;
    }


    return 0;
}</pre>
    <br/>
    av_image_fill_pointers()代码如下所示。
    <br/>
    <pre class="cpp">int av_image_fill_pointers(uint8_t *data[4], enum AVPixelFormat pix_fmt, int height,
                           uint8_t *ptr, const int linesizes[4])
{
    int i, total_size, size[4] = { 0 }, has_plane[4] = { 0 };


    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);
    memset(data     , 0, sizeof(data[0])*4);


    if (!desc || desc-&gt;flags &amp; AV_PIX_FMT_FLAG_HWACCEL)
        return AVERROR(EINVAL);


    data[0] = ptr;
    if (linesizes[0] &gt; (INT_MAX - 1024) / height)
        return AVERROR(EINVAL);
    size[0] = linesizes[0] * height;


    if (desc-&gt;flags &amp; AV_PIX_FMT_FLAG_PAL ||
        desc-&gt;flags &amp; AV_PIX_FMT_FLAG_PSEUDOPAL) {
        size[0] = (size[0] + 3) &amp; ~3;
        data[1] = ptr + size[0]; /* palette is stored here as 256 32 bits words */
        return size[0] + 256 * 4;
    }


    for (i = 0; i &lt; 4; i++)
        has_plane[desc-&gt;comp[i].plane] = 1;


    total_size = size[0];
    for (i = 1; i &lt; 4 &amp;&amp; has_plane[i]; i++) {
        int h, s = (i == 1 || i == 2) ? desc-&gt;log2_chroma_h : 0;
        data[i] = data[i-1] + size[i-1];
        h = (height + (1 &lt;&lt; s) - 1) &gt;&gt; s;
        if (linesizes[i] &gt; INT_MAX / h)
            return AVERROR(EINVAL);
        size[i] = h * linesizes[i];
        if (total_size &gt; INT_MAX - size[i])
            return AVERROR(EINVAL);
        total_size += size[i];
    }


    return total_size;
}</pre>
    <br/>
    avpicture_fill()函数调用关系如下图所示。
    <br/>
    <div style="text-align:center;">
     <img alt="" src="https://img-blog.csdn.net/20150303154911639"/>
    </div>
    <br/>
    <h3>
     av_frame_free()
    </h3>
    <p>
     av_frame_free ()的声明位于libavutil\frame.h，如下所示。
    </p>
    <p>
    </p>
    <pre class="cpp">/**
 * Free the frame and any dynamically allocated objects in it,
 * e.g. extended_data. If the frame is reference counted, it will be
 * unreferenced first.
 *
 * @param frame frame to be freed. The pointer will be set to NULL.
 */
void av_frame_free(AVFrame **frame);</pre>
    <p>
    </p>
    <p>
     av_frame_free ()的定义位于libavutil\frame.c。代码如下所示。
    </p>
    <pre class="cpp">void av_frame_free(AVFrame **frame)
{
    if (!frame || !*frame)
        return;


    av_frame_unref(*frame);
    av_freep(frame);
}</pre>
    <br/>
    在释放AVFrame结构体之前，首先调用了一个函数av_frame_unref()。av_frame_unref()也是一个FFmpeg的API，它的作用是释放AVFrame中参考的缓存（还没完全弄懂），并且重置AVFrame中的字段。调用这个函数的目的应该是为了确保AVFrame可以被正常释放。代码如下。
    <br/>
    <pre class="cpp">void av_frame_unref(AVFrame *frame)
{
    int i;


    for (i = 0; i &lt; frame-&gt;nb_side_data; i++) {
        free_side_data(&amp;frame-&gt;side_data[i]);
    }
    av_freep(&amp;frame-&gt;side_data);


    for (i = 0; i &lt; FF_ARRAY_ELEMS(frame-&gt;buf); i++)
        av_buffer_unref(&amp;frame-&gt;buf[i]);
    for (i = 0; i &lt; frame-&gt;nb_extended_buf; i++)
        av_buffer_unref(&amp;frame-&gt;extended_buf[i]);
    av_freep(&amp;frame-&gt;extended_buf);
    av_dict_free(&amp;frame-&gt;metadata);
    av_buffer_unref(&amp;frame-&gt;qp_table_buf);


    get_frame_defaults(frame);
}</pre>
    <br/>
    <h2>
     AVPacket
    </h2>
    <p>
     AVPacket的初始化函数有两个：av_init_packet()，av_new_packet()。销毁函数是av_free_packet()。在初始化函数中av_init_packet()比较简单，初始化一些字段；而av_new_packet()相对“高级”一些，除了包含av_init_packet()的功能之外，还包含了AVPacket内部内存的分配。下面分别看看这些函数。
    </p>
    <p>
     <br/>
    </p>
    <h3>
     av_init_packet()
    </h3>
    <p>
     av_init_packet()的声明位于libavcodec\avcodec.h，如下所示。
     <br/>
    </p>
    <p>
    </p>
    <pre class="cpp">/**
 * Initialize optional fields of a packet with default values.
 *
 * Note, this does not touch the data and size members, which have to be
 * initialized separately.
 *
 * @param pkt packet
 */
void av_init_packet(AVPacket *pkt);</pre>
    <p>
    </p>
    <p>
     av_init_packet()的定义位于libavcodec\avpacket.c。如下所示。
    </p>
    <pre class="cpp">void av_init_packet(AVPacket *pkt)
{
    pkt-&gt;pts                  = AV_NOPTS_VALUE;
    pkt-&gt;dts                  = AV_NOPTS_VALUE;
    pkt-&gt;pos                  = -1;
    pkt-&gt;duration             = 0;
    pkt-&gt;convergence_duration = 0;
    pkt-&gt;flags                = 0;
    pkt-&gt;stream_index         = 0;
#if FF_API_DESTRUCT_PACKET
FF_DISABLE_DEPRECATION_WARNINGS
    pkt-&gt;destruct             = NULL;
FF_ENABLE_DEPRECATION_WARNINGS
#endif
    pkt-&gt;buf                  = NULL;
    pkt-&gt;side_data            = NULL;
    pkt-&gt;side_data_elems      = 0;
}</pre>
    <br/>
    <h3>
     av_new_packet()
    </h3>
    <p>
     av_new_packet()的声明位于libavcodec\avcodec.h。如下所示。
     <br/>
    </p>
    <p>
    </p>
    <pre class="cpp">/**
 * Allocate the payload of a packet and initialize its fields with
 * default values.
 *
 * @param pkt packet
 * @param size wanted payload size
 * @return 0 if OK, AVERROR_xxx otherwise
 */
int av_new_packet(AVPacket *pkt, int size);</pre>
    <p>
    </p>
    <p>
     av_new_packet()的定义位于libavcodec\avpacket.c。如下所示。
    </p>
    <pre class="cpp">int av_new_packet(AVPacket *pkt, int size)
{
    AVBufferRef *buf = NULL;
    int ret = packet_alloc(&amp;buf, size);
    if (ret &lt; 0)
        return ret;


    av_init_packet(pkt);
    pkt-&gt;buf      = buf;
    pkt-&gt;data     = buf-&gt;data;
    pkt-&gt;size     = size;
#if FF_API_DESTRUCT_PACKET
FF_DISABLE_DEPRECATION_WARNINGS
    pkt-&gt;destruct = dummy_destruct_packet;
FF_ENABLE_DEPRECATION_WARNINGS
#endif


    return 0;
}</pre>
    <br/>
    从代码可以看出，av_new_packet()调用了av_init_packet(pkt)。此外还调用了一个函数packet_alloc()。packet_alloc()函数的定义如下。
    <br/>
    <pre class="cpp">static int packet_alloc(AVBufferRef **buf, int size)
{
    int ret;
    if ((unsigned)size &gt;= (unsigned)size + FF_INPUT_BUFFER_PADDING_SIZE)
        return AVERROR(EINVAL);


    ret = av_buffer_realloc(buf, size + FF_INPUT_BUFFER_PADDING_SIZE);
    if (ret &lt; 0)
        return ret;


    memset((*buf)-&gt;data + size, 0, FF_INPUT_BUFFER_PADDING_SIZE);


    return 0;
}</pre>
    <br/>
    packet_alloc()中调用av_buffer_realloc()为AVPacket分配内存。然后调用memset()将分配的内存置0。
    <br/>
    <span style="font-family:'FangSong_GB2312';">
     PS：发现AVPacket的结构随着FFmpeg的发展越发复杂了。原先AVPacket中的数据仅仅存在一个uint8_t类型的数组里，而现在已经使用一个专门的结构体AVBufferRef存储数据。
    </span>
    <br/>
    av_new_packet()代码的函数调用关系如下图所示。
    <br/>
    <div style="text-align:center;">
     <img alt="" src="https://img-blog.csdn.net/20150303155101056"/>
    </div>
    <br/>
    <h3>
     av_free_packet()
    </h3>
    <p>
     av_free_packet()的声明位于libavcodec\avcodec.h，如下所示。
     <br/>
    </p>
    <p>
    </p>
    <pre class="cpp">/**
 * Free a packet.
 *
 * @param pkt packet to free
 */
void av_free_packet(AVPacket *pkt);</pre>
    <p>
    </p>
    <p>
     av_free_packet()的定义位于libavcodec\avpacket.c。如下所示。
    </p>
    <pre class="cpp">void av_free_packet(AVPacket *pkt)
{
    if (pkt) {
FF_DISABLE_DEPRECATION_WARNINGS
        if (pkt-&gt;buf)
            av_buffer_unref(&amp;pkt-&gt;buf);
#if FF_API_DESTRUCT_PACKET
        else if (pkt-&gt;destruct)
            pkt-&gt;destruct(pkt);
        pkt-&gt;destruct = NULL;
#endif
FF_ENABLE_DEPRECATION_WARNINGS
        pkt-&gt;data            = NULL;
        pkt-&gt;size            = 0;


        av_packet_free_side_data(pkt);
    }
}</pre>
    <br/>
    从代码可以看出，av_free_packet()调用av_buffer_unref()释放AVPacket中的数据，而后还调用了av_packet_free_side_data()释放了side_data（存储封装格式可以提供的额外的数据）。
    <br/>
    <p>
     <br/>
    </p>
    <p>
     <strong>
      <span style="color:#660000;">
       雷霄骅 (Lei Xiaohua)
       <br/>
       leixiaohua1020@126.com
       <br/>
       http://blog.csdn.net/leixiaohua1020
      </span>
     </strong>
     <br/>
    </p>
    <p>
     <br/>
    </p>
   </div>
  </div>
  <div style="display:none;" class="hide-article-box text-center csdn-tracking-statistics tracking-click" data-mod="popu_376">
   <a class="btn btn-red-hollow" id="btn-readmore">
    阅读更多
   </a>
  </div>
 </article>
 <div class="article-bar-bottom">
  <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。			https://blog.csdn.net/leixiaohua1020/article/details/41181155
  </div>
  <div class="tags-box artic-tag-box">
   <span class="label">
    文章标签：
   </span>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=ffmpeg&amp;t=blog" target="_blank">
    ffmpeg
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=avformatcontext&amp;t=blog" target="_blank">
    avformatcontext
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=avstream&amp;t=blog" target="_blank">
    avstream
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=avcodeccontext&amp;t=blog" target="_blank">
    avcodeccontext
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=avpacket&amp;t=blog" target="_blank">
    avpacket
   </a>
  </div>
  <div class="tags-box">
   <span class="label">
    个人分类：
   </span>
   <a class="tag-link" href="https://blog.csdn.net/leixiaohua1020/article/category/1360795" target="_blank">
    FFMPEG
   </a>
  </div>
  <div class="tags-box">
   <span class="label">
    所属专栏：
   </span>
   <a class="tag-link" href="https://blog.csdn.net/column/details/ffmpeg-devel.html" target="_blank">
    FFmpeg
   </a>
  </div>
 </div>
 <!-- !empty($pre_next_article[0]) -->
</div>
<div class="recommend-box">
                            <div style="background: #fff; border: dashed 1px #666; padding-left: 1em; padding-top: 1em; padding-bottom: 1em;">
                                <span style="font-size: 0.8em; font-weight: bold;">
                                    此PDF由<a style="color:#0000ff" href="http://www.github.com/spygg"  target="_blank">spygg</a>生成,请尊重原作者版权!!!
                                    <br/>
                                    我的邮箱:liushidc@163.com
                                </span>
                                </div> 
                        </div>
                    </main>
      
                </div>

            <script>
                var recommendCount = 0;
                var articleTit = "";
                var articleId = "";
                var commentscount = 0;

                //1禁止评论，2正常
                var commentAuth = 1;
                //百度搜索
                var baiduKey = "";
                var needInsertBaidu = "";
            </script>
            <script src="https://csdnimg.cn/release/phoenix/template/js/detail-effe72036e.min.js"></script>
            </body>
        </html>