
            <!DOCTYPE html>
            <html lang="zh-CN">
                <head>
                    <meta charset="UTF-8">
                    <title>
 FFmpeg与libx264接口源代码简单分析 - CSDN博客
</title>

                <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-60a2c245da.min.css">
                <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-88717cedf2.min.css">

                <script type="text/javascript">
                var username = "";
                </script>

                <script src="https://csdnimg.cn/public/common/libs/jquery/jquery-1.9.1.min.js" type="text/javascript"></script>

                <!-- 新版上报 -->
                <!-- 新版上报end -->
                <link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.3/css/sandalstrap.min.css"> 
                </head>
                <body>    
        
                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
                    <div class="container clearfix pt0" id="mainBox">
        <main style="width: 100%;"><div class="blog-content-box">
 <div class="article-title-box" id="article_anchors_54">
  <span class="article-type type-1 float-left">
   原
  </span>
  <h1 class="title-article">
   FFmpeg与libx264接口源代码简单分析
  </h1>
 </div>
 <div class="article-info-box">
  <div class="article-bar-top d-flex">
   <span class="time">
    2015年05月25日 01:48:07
   </span>
   <div ">
    <span class="read-count">
     阅读数：17416
    </span>
   </div>
  </div>
 </div>
 <article>
  <div class="article_content clearfix csdn-tracking-statistics" data-dsm="post" data-mod="popu_307" data-pid="blog" id="article_content">
   <link href="https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css" rel="stylesheet"/>
   <div class="htmledit_views">
    <p>
    </p>
    <p>
     =====================================================
    </p>
    <p>
     H.264源代码分析文章列表：
    </p>
    <p>
     【编码 - x264】
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/45536607">
      x264源代码简单分析：概述
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/45583217">
      x264源代码简单分析：x264命令行工具（x264.exe）
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/45644367">
      x264源代码简单分析：编码器主干部分-1
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/45719905">
      x264源代码简单分析：编码器主干部分-2
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/45790195">
      x264源代码简单分析：x264_slice_write()
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/45870269">
      x264源代码简单分析：滤波（Filter）部分
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/45917757">
      x264源代码简单分析：宏块分析（Analysis）部分-帧内宏块（Intra）
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/45936267">
      x264源代码简单分析：宏块分析（Analysis）部分-帧间宏块（Inter）
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/45938927">
      x264源代码简单分析：宏块编码（Encode）部分
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/45944811">
      x264源代码简单分析：熵编码（Entropy Encoding）部分
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/45960409">
      FFmpeg与libx264接口源代码简单分析
     </a>
    </p>
    <p>
     【解码 - libavcodec H.264 解码器】
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44864509">
      FFmpeg的H.264解码器源代码简单分析：概述
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/45001033">
      FFmpeg的H.264解码器源代码简单分析：解析器（Parser）部分
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/45042755">
      FFmpeg的H.264解码器源代码简单分析：解码器主干部分
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/45114453">
      FFmpeg的H.264解码器源代码简单分析：熵解码（EntropyDecoding）部分
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/45143075">
      FFmpeg的H.264解码器源代码简单分析：宏块解码（Decode）部分-帧内宏块（Intra）
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/45195291">
      FFmpeg的H.264解码器源代码简单分析：宏块解码（Decode）部分-帧间宏块（Inter）
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/45224579">
      FFmpeg的H.264解码器源代码简单分析：环路滤波（Loop Filter）部分
     </a>
    </p>
    <p>
     =====================================================
    </p>
    <br/>
    <p>
     本文简单记录一下FFmpeg的libavcodec中与libx264接口部分的源代码。该部分源代码位于“libavcodec/libx264.c”中。正是有了这部分代码，使得FFmpeg可以调用libx264编码H.264视频。
    </p>
    <p>
     <br/>
    </p>
    <h2>
     函数调用关系图
    </h2>
    <p>
     FFmpeg的libavcodec中的libx264.c的函数调用关系如下图所示。
    </p>
    <p style="text-align:center;">
     <img alt="" src="https://img-blog.csdn.net/20150525015021891"/>
     <br/>
    </p>
    <p>
     从图中可以看出，libx264对应的AVCodec结构体ff_libx264_encoder中设定编码器初始化函数是X264_init()，编码一帧数据的函数是X264_frame()，编码器关闭函数是X264_close()。
    </p>
    X264_init()调用了如下函数：
    <br/>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
     [libx264 API] x264_param_default()：设置默认参数。
     <br/>
     [libx264 API] x264_param_default_preset()：设置默认preset。
     <br/>
     convert_pix_fmt()：将FFmpeg像素格式转换为libx264像素格式。
     <br/>
     [libx264 API] x264_param_apply_profile()：设置Profile。
     <br/>
     [libx264 API] x264_encoder_open()：打开编码器。
     <br/>
     [libx264 API] x264_encoder_headers()：需要全局头的时候，输出头信息。
    </blockquote>
    X264_frame()调用了如下函数：
    <br/>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
     [libx264 API] x264_encoder_encode()：编码一帧数据。
     <br/>
     [libx264 API] x264_encoder_delayed_frames()：输出编码器中缓存的数据。
     <br/>
     encode_nals()：将编码后得到的x264_nal_t转换为AVPacket。
    </blockquote>
    X264_close()调用了如下函数：
    <br/>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
     [libx264 API] x264_encoder_close()：关闭编码器。
    </blockquote>
    <br/>
    下文将会分别分析X264_init()，X264_frame()和X264_close()这三个函数。
    <br/>
    <br/>
    <h2>
     ff_libx264_encoder
    </h2>
    ff_libx264_encoder是libx264对应的AVCodec结构体，定义如下所示。
    <br/>
    <pre class="cpp">//libx264对应的AVCodec结构体
AVCodec ff_libx264_encoder = {
    .name             = "libx264",
    .long_name        = NULL_IF_CONFIG_SMALL("libx264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10"),
    .type             = AVMEDIA_TYPE_VIDEO,
    .id               = AV_CODEC_ID_H264,
    .priv_data_size   = sizeof(X264Context),
    .init             = X264_init,
    .encode2          = X264_frame,
    .close            = X264_close,
    .capabilities     = CODEC_CAP_DELAY | CODEC_CAP_AUTO_THREADS,
    .priv_class       = &amp;x264_class,
    .defaults         = x264_defaults,
    .init_static_data = X264_init_static,
};</pre>
    <br/>
    从ff_libx264_encoder定义中可以看出：init()指向X264_init()，encode2()指向 X264_frame()， close()指向 X264_close()。此外priv_class指向一个x264_class静态结构体，该结构体是libx264对应的AVClass，定义如下。
    <br/>
    <pre class="cpp">static const AVClass x264_class = {
    .class_name = "libx264",
    .item_name  = av_default_item_name,
    .option     = options,//选项
    .version    = LIBAVUTIL_VERSION_INT,
};</pre>
    <br/>
    x264_class中的option指向一个options[]静态数组，其中包含了libx264支持的AVOption选项，如下所示。
    <br/>
    <pre class="cpp">//FFmpeg针对libx264提供的可以通过AVOption设置的选项
#define OFFSET(x) offsetof(X264Context, x)
#define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
static const AVOption options[] = {
    { "preset",        "Set the encoding preset (cf. x264 --fullhelp)",   OFFSET(preset),        AV_OPT_TYPE_STRING, { .str = "medium" }, 0, 0, VE},
    { "tune",          "Tune the encoding params (cf. x264 --fullhelp)",  OFFSET(tune),          AV_OPT_TYPE_STRING, { 0 }, 0, 0, VE},
    { "profile",       "Set profile restrictions (cf. x264 --fullhelp) ", OFFSET(profile),       AV_OPT_TYPE_STRING, { 0 }, 0, 0, VE},
    { "fastfirstpass", "Use fast settings when encoding first pass",      OFFSET(fastfirstpass), AV_OPT_TYPE_INT,    { .i64 = 1 }, 0, 1, VE},
    {"level", "Specify level (as defined by Annex A)", OFFSET(level), AV_OPT_TYPE_STRING, {.str=NULL}, 0, 0, VE},
    {"passlogfile", "Filename for 2 pass stats", OFFSET(stats), AV_OPT_TYPE_STRING, {.str=NULL}, 0, 0, VE},
    {"wpredp", "Weighted prediction for P-frames", OFFSET(wpredp), AV_OPT_TYPE_STRING, {.str=NULL}, 0, 0, VE},
    {"x264opts", "x264 options", OFFSET(x264opts), AV_OPT_TYPE_STRING, {.str=NULL}, 0, 0, VE},
    { "crf",           "Select the quality for constant quality mode",    OFFSET(crf),           AV_OPT_TYPE_FLOAT,  {.dbl = -1 }, -1, FLT_MAX, VE },
    { "crf_max",       "In CRF mode, prevents VBV from lowering quality beyond this point.",OFFSET(crf_max), AV_OPT_TYPE_FLOAT, {.dbl = -1 }, -1, FLT_MAX, VE },
    { "qp",            "Constant quantization parameter rate control method",OFFSET(cqp),        AV_OPT_TYPE_INT,    { .i64 = -1 }, -1, INT_MAX, VE },
    { "aq-mode",       "AQ method",                                       OFFSET(aq_mode),       AV_OPT_TYPE_INT,    { .i64 = -1 }, -1, INT_MAX, VE, "aq_mode"},
    { "none",          NULL,                              0, AV_OPT_TYPE_CONST, {.i64 = X264_AQ_NONE},         INT_MIN, INT_MAX, VE, "aq_mode" },
    { "variance",      "Variance AQ (complexity mask)",   0, AV_OPT_TYPE_CONST, {.i64 = X264_AQ_VARIANCE},     INT_MIN, INT_MAX, VE, "aq_mode" },
    { "autovariance",  "Auto-variance AQ (experimental)", 0, AV_OPT_TYPE_CONST, {.i64 = X264_AQ_AUTOVARIANCE}, INT_MIN, INT_MAX, VE, "aq_mode" },
    { "aq-strength",   "AQ strength. Reduces blocking and blurring in flat and textured areas.", OFFSET(aq_strength), AV_OPT_TYPE_FLOAT, {.dbl = -1}, -1, FLT_MAX, VE},
    { "psy",           "Use psychovisual optimizations.",                 OFFSET(psy),           AV_OPT_TYPE_INT,    { .i64 = -1 }, -1, 1, VE },
    { "psy-rd",        "Strength of psychovisual optimization, in &lt;psy-rd&gt;:&lt;psy-trellis&gt; format.", OFFSET(psy_rd), AV_OPT_TYPE_STRING,  {0 }, 0, 0, VE},
    { "rc-lookahead",  "Number of frames to look ahead for frametype and ratecontrol", OFFSET(rc_lookahead), AV_OPT_TYPE_INT, { .i64 = -1 }, -1, INT_MAX, VE },
    { "weightb",       "Weighted prediction for B-frames.",               OFFSET(weightb),       AV_OPT_TYPE_INT,    { .i64 = -1 }, -1, 1, VE },
    { "weightp",       "Weighted prediction analysis method.",            OFFSET(weightp),       AV_OPT_TYPE_INT,    { .i64 = -1 }, -1, INT_MAX, VE, "weightp" },
    { "none",          NULL, 0, AV_OPT_TYPE_CONST, {.i64 = X264_WEIGHTP_NONE},   INT_MIN, INT_MAX, VE, "weightp" },
    { "simple",        NULL, 0, AV_OPT_TYPE_CONST, {.i64 = X264_WEIGHTP_SIMPLE}, INT_MIN, INT_MAX, VE, "weightp" },
    { "smart",         NULL, 0, AV_OPT_TYPE_CONST, {.i64 = X264_WEIGHTP_SMART},  INT_MIN, INT_MAX, VE, "weightp" },
    { "ssim",          "Calculate and print SSIM stats.",                 OFFSET(ssim),          AV_OPT_TYPE_INT,    { .i64 = -1 }, -1, 1, VE },
    { "intra-refresh", "Use Periodic Intra Refresh instead of IDR frames.",OFFSET(intra_refresh),AV_OPT_TYPE_INT,    { .i64 = -1 }, -1, 1, VE },
    { "bluray-compat", "Bluray compatibility workarounds.",               OFFSET(bluray_compat) ,AV_OPT_TYPE_INT,    { .i64 = -1 }, -1, 1, VE },
    { "b-bias",        "Influences how often B-frames are used",          OFFSET(b_bias),        AV_OPT_TYPE_INT,    { .i64 = INT_MIN}, INT_MIN, INT_MAX, VE },
    { "b-pyramid",     "Keep some B-frames as references.",               OFFSET(b_pyramid),     AV_OPT_TYPE_INT,    { .i64 = -1 }, -1, INT_MAX, VE, "b_pyramid" },
    { "none",          NULL,                                  0, AV_OPT_TYPE_CONST, {.i64 = X264_B_PYRAMID_NONE},   INT_MIN, INT_MAX, VE, "b_pyramid" },
    { "strict",        "Strictly hierarchical pyramid",       0, AV_OPT_TYPE_CONST, {.i64 = X264_B_PYRAMID_STRICT}, INT_MIN, INT_MAX, VE, "b_pyramid" },
    { "normal",        "Non-strict (not Blu-ray compatible)", 0, AV_OPT_TYPE_CONST, {.i64 = X264_B_PYRAMID_NORMAL}, INT_MIN, INT_MAX, VE, "b_pyramid" },
    { "mixed-refs",    "One reference per partition, as opposed to one reference per macroblock", OFFSET(mixed_refs), AV_OPT_TYPE_INT, { .i64 = -1}, -1, 1, VE },
    { "8x8dct",        "High profile 8x8 transform.",                     OFFSET(dct8x8),        AV_OPT_TYPE_INT,    { .i64 = -1 }, -1, 1, VE},
    { "fast-pskip",    NULL,                                              OFFSET(fast_pskip),    AV_OPT_TYPE_INT,    { .i64 = -1 }, -1, 1, VE},
    { "aud",           "Use access unit delimiters.",                     OFFSET(aud),           AV_OPT_TYPE_INT,    { .i64 = -1 }, -1, 1, VE},
    { "mbtree",        "Use macroblock tree ratecontrol.",                OFFSET(mbtree),        AV_OPT_TYPE_INT,    { .i64 = -1 }, -1, 1, VE},
    { "deblock",       "Loop filter parameters, in &lt;alpha:beta&gt; form.",   OFFSET(deblock),       AV_OPT_TYPE_STRING, { 0 },  0, 0, VE},
    { "cplxblur",      "Reduce fluctuations in QP (before curve compression)", OFFSET(cplxblur), AV_OPT_TYPE_FLOAT,  {.dbl = -1 }, -1, FLT_MAX, VE},
    { "partitions",    "A comma-separated list of partitions to consider. "
                       "Possible values: p8x8, p4x4, b8x8, i8x8, i4x4, none, all", OFFSET(partitions), AV_OPT_TYPE_STRING, { 0 }, 0, 0, VE},
    { "direct-pred",   "Direct MV prediction mode",                       OFFSET(direct_pred),   AV_OPT_TYPE_INT,    { .i64 = -1 }, -1, INT_MAX, VE, "direct-pred" },
    { "none",          NULL,      0,    AV_OPT_TYPE_CONST, { .i64 = X264_DIRECT_PRED_NONE },     0, 0, VE, "direct-pred" },
    { "spatial",       NULL,      0,    AV_OPT_TYPE_CONST, { .i64 = X264_DIRECT_PRED_SPATIAL },  0, 0, VE, "direct-pred" },
    { "temporal",      NULL,      0,    AV_OPT_TYPE_CONST, { .i64 = X264_DIRECT_PRED_TEMPORAL }, 0, 0, VE, "direct-pred" },
    { "auto",          NULL,      0,    AV_OPT_TYPE_CONST, { .i64 = X264_DIRECT_PRED_AUTO },     0, 0, VE, "direct-pred" },
    { "slice-max-size","Limit the size of each slice in bytes",           OFFSET(slice_max_size),AV_OPT_TYPE_INT,    { .i64 = -1 }, -1, INT_MAX, VE },
    { "stats",         "Filename for 2 pass stats",                       OFFSET(stats),         AV_OPT_TYPE_STRING, { 0 },  0,       0, VE },
    { "nal-hrd",       "Signal HRD information (requires vbv-bufsize; "
                       "cbr not allowed in .mp4)",                        OFFSET(nal_hrd),       AV_OPT_TYPE_INT,    { .i64 = -1 }, -1, INT_MAX, VE, "nal-hrd" },
    { "none",          NULL, 0, AV_OPT_TYPE_CONST, {.i64 = X264_NAL_HRD_NONE}, INT_MIN, INT_MAX, VE, "nal-hrd" },
    { "vbr",           NULL, 0, AV_OPT_TYPE_CONST, {.i64 = X264_NAL_HRD_VBR},  INT_MIN, INT_MAX, VE, "nal-hrd" },
    { "cbr",           NULL, 0, AV_OPT_TYPE_CONST, {.i64 = X264_NAL_HRD_CBR},  INT_MIN, INT_MAX, VE, "nal-hrd" },
    { "avcintra-class","AVC-Intra class 50/100/200",                      OFFSET(avcintra_class),AV_OPT_TYPE_INT,     { .i64 = -1 }, -1, 200   , VE},
    { "x264-params",  "Override the x264 configuration using a :-separated list of key=value parameters", OFFSET(x264_params), AV_OPT_TYPE_STRING, { 0 }, 0, 0, VE },
    { NULL },
};
</pre>
    <br/>
    options[]数组中包含的选项支持在FFmpeg中通过AVOption进行设置。
    <br/>
    <br/>
    <h2>
     X264_init()
    </h2>
    X264_init()用于初始化libx264编码器。该函数的定义如下所示。
    <br/>
    <pre class="cpp">//libx264编码器初始化
static av_cold int X264_init(AVCodecContext *avctx)
{
	//FFmpeg中针对libx264的私有结构体
    X264Context *x4 = avctx-&gt;priv_data;
    int sw,sh;

    if (avctx-&gt;global_quality &gt; 0)
        av_log(avctx, AV_LOG_WARNING, "-qscale is ignored, -crf is recommended.\n");

    //[libx264 API] 设置默认参数
    x264_param_default(&amp;x4-&gt;params);

    x4-&gt;params.b_deblocking_filter         = avctx-&gt;flags &amp; CODEC_FLAG_LOOP_FILTER;

    if (x4-&gt;preset || x4-&gt;tune)
        if (x264_param_default_preset(&amp;x4-&gt;params, x4-&gt;preset, x4-&gt;tune) &lt; 0) {  //[libx264 API] 设置preset
            int i;
            av_log(avctx, AV_LOG_ERROR, "Error setting preset/tune %s/%s.\n", x4-&gt;preset, x4-&gt;tune);
            av_log(avctx, AV_LOG_INFO, "Possible presets:");
            for (i = 0; x264_preset_names[i]; i++)
                av_log(avctx, AV_LOG_INFO, " %s", x264_preset_names[i]);
            av_log(avctx, AV_LOG_INFO, "\n");
            av_log(avctx, AV_LOG_INFO, "Possible tunes:");
            for (i = 0; x264_tune_names[i]; i++)
                av_log(avctx, AV_LOG_INFO, " %s", x264_tune_names[i]);
            av_log(avctx, AV_LOG_INFO, "\n");
            return AVERROR(EINVAL);
        }

    if (avctx-&gt;level &gt; 0)
        x4-&gt;params.i_level_idc = avctx-&gt;level;
    //libx264日志输出设置为FFmpeg的日志输出
    x4-&gt;params.pf_log               = X264_log;
    x4-&gt;params.p_log_private        = avctx;
    x4-&gt;params.i_log_level          = X264_LOG_DEBUG;
    //FFmpeg像素格式映射到libx264
    x4-&gt;params.i_csp                = convert_pix_fmt(avctx-&gt;pix_fmt);

    OPT_STR("weightp", x4-&gt;wpredp);

    //FFmpeg码率映射到libx264
    if (avctx-&gt;bit_rate) {
        x4-&gt;params.rc.i_bitrate   = avctx-&gt;bit_rate / 1000;
        x4-&gt;params.rc.i_rc_method = X264_RC_ABR;
    }
    x4-&gt;params.rc.i_vbv_buffer_size = avctx-&gt;rc_buffer_size / 1000;
    x4-&gt;params.rc.i_vbv_max_bitrate = avctx-&gt;rc_max_rate    / 1000;
    x4-&gt;params.rc.b_stat_write      = avctx-&gt;flags &amp; CODEC_FLAG_PASS1;
    if (avctx-&gt;flags &amp; CODEC_FLAG_PASS2) {
        x4-&gt;params.rc.b_stat_read = 1;
    } else {
        if (x4-&gt;crf &gt;= 0) {
            x4-&gt;params.rc.i_rc_method   = X264_RC_CRF;
            x4-&gt;params.rc.f_rf_constant = x4-&gt;crf;
        } else if (x4-&gt;cqp &gt;= 0) {
            x4-&gt;params.rc.i_rc_method   = X264_RC_CQP;
            x4-&gt;params.rc.i_qp_constant = x4-&gt;cqp;
        }

        if (x4-&gt;crf_max &gt;= 0)
            x4-&gt;params.rc.f_rf_constant_max = x4-&gt;crf_max;
    }

    if (avctx-&gt;rc_buffer_size &amp;&amp; avctx-&gt;rc_initial_buffer_occupancy &gt; 0 &amp;&amp;
        (avctx-&gt;rc_initial_buffer_occupancy &lt;= avctx-&gt;rc_buffer_size)) {
        x4-&gt;params.rc.f_vbv_buffer_init =
            (float)avctx-&gt;rc_initial_buffer_occupancy / avctx-&gt;rc_buffer_size;
    }

    OPT_STR("level", x4-&gt;level);

    if (avctx-&gt;i_quant_factor &gt; 0)
        x4-&gt;params.rc.f_ip_factor         = 1 / fabs(avctx-&gt;i_quant_factor);
    if (avctx-&gt;b_quant_factor &gt; 0)
        x4-&gt;params.rc.f_pb_factor         = avctx-&gt;b_quant_factor;
    if (avctx-&gt;chromaoffset)
        x4-&gt;params.analyse.i_chroma_qp_offset = avctx-&gt;chromaoffset;
    //FFmpeg运动估计方法映射到libx264
    if (avctx-&gt;me_method == ME_EPZS)
        x4-&gt;params.analyse.i_me_method = X264_ME_DIA;
    else if (avctx-&gt;me_method == ME_HEX)
        x4-&gt;params.analyse.i_me_method = X264_ME_HEX;
    else if (avctx-&gt;me_method == ME_UMH)
        x4-&gt;params.analyse.i_me_method = X264_ME_UMH;
    else if (avctx-&gt;me_method == ME_FULL)
        x4-&gt;params.analyse.i_me_method = X264_ME_ESA;
    else if (avctx-&gt;me_method == ME_TESA)
        x4-&gt;params.analyse.i_me_method = X264_ME_TESA;

    //把AVCodecContext的值（主要是编码时候的一些通用选项）映射到x264_param_t
    if (avctx-&gt;gop_size &gt;= 0)
        x4-&gt;params.i_keyint_max         = avctx-&gt;gop_size;
    if (avctx-&gt;max_b_frames &gt;= 0)
        x4-&gt;params.i_bframe             = avctx-&gt;max_b_frames;
    if (avctx-&gt;scenechange_threshold &gt;= 0)
        x4-&gt;params.i_scenecut_threshold = avctx-&gt;scenechange_threshold;
    if (avctx-&gt;qmin &gt;= 0)
        x4-&gt;params.rc.i_qp_min          = avctx-&gt;qmin;
    if (avctx-&gt;qmax &gt;= 0)
        x4-&gt;params.rc.i_qp_max          = avctx-&gt;qmax;
    if (avctx-&gt;max_qdiff &gt;= 0)
        x4-&gt;params.rc.i_qp_step         = avctx-&gt;max_qdiff;
    if (avctx-&gt;qblur &gt;= 0)
        x4-&gt;params.rc.f_qblur           = avctx-&gt;qblur;     /* temporally blur quants */
    if (avctx-&gt;qcompress &gt;= 0)
        x4-&gt;params.rc.f_qcompress       = avctx-&gt;qcompress; /* 0.0 =&gt; cbr, 1.0 =&gt; constant qp */
    if (avctx-&gt;refs &gt;= 0)
        x4-&gt;params.i_frame_reference    = avctx-&gt;refs;
    else if (x4-&gt;level) {
        int i;
        int mbn = FF_CEIL_RSHIFT(avctx-&gt;width, 4) * FF_CEIL_RSHIFT(avctx-&gt;height, 4);
        int level_id = -1;
        char *tail;
        int scale = X264_BUILD &lt; 129 ? 384 : 1;

        if (!strcmp(x4-&gt;level, "1b")) {
            level_id = 9;
        } else if (strlen(x4-&gt;level) &lt;= 3){
            level_id = av_strtod(x4-&gt;level, &amp;tail) * 10 + 0.5;
            if (*tail)
                level_id = -1;
        }
        if (level_id &lt;= 0)
            av_log(avctx, AV_LOG_WARNING, "Failed to parse level\n");

        for (i = 0; i&lt;x264_levels[i].level_idc; i++)
            if (x264_levels[i].level_idc == level_id)
                x4-&gt;params.i_frame_reference = av_clip(x264_levels[i].dpb / mbn / scale, 1, x4-&gt;params.i_frame_reference);
    }

    if (avctx-&gt;trellis &gt;= 0)
        x4-&gt;params.analyse.i_trellis    = avctx-&gt;trellis;
    if (avctx-&gt;me_range &gt;= 0)
        x4-&gt;params.analyse.i_me_range   = avctx-&gt;me_range;
    if (avctx-&gt;noise_reduction &gt;= 0)
        x4-&gt;params.analyse.i_noise_reduction = avctx-&gt;noise_reduction;
    if (avctx-&gt;me_subpel_quality &gt;= 0)
        x4-&gt;params.analyse.i_subpel_refine   = avctx-&gt;me_subpel_quality;
    if (avctx-&gt;b_frame_strategy &gt;= 0)
        x4-&gt;params.i_bframe_adaptive = avctx-&gt;b_frame_strategy;
    if (avctx-&gt;keyint_min &gt;= 0)
        x4-&gt;params.i_keyint_min = avctx-&gt;keyint_min;
    if (avctx-&gt;coder_type &gt;= 0)
        x4-&gt;params.b_cabac = avctx-&gt;coder_type == FF_CODER_TYPE_AC;
    if (avctx-&gt;me_cmp &gt;= 0)
        x4-&gt;params.analyse.b_chroma_me = avctx-&gt;me_cmp &amp; FF_CMP_CHROMA;

    //把X264Context中的信息（主要是针对于libx264的一些选项）映射到x264_param_t
    if (x4-&gt;aq_mode &gt;= 0)
        x4-&gt;params.rc.i_aq_mode = x4-&gt;aq_mode;
    if (x4-&gt;aq_strength &gt;= 0)
        x4-&gt;params.rc.f_aq_strength = x4-&gt;aq_strength;
    PARSE_X264_OPT("psy-rd", psy_rd);
    PARSE_X264_OPT("deblock", deblock);
    PARSE_X264_OPT("partitions", partitions);
    PARSE_X264_OPT("stats", stats);
    if (x4-&gt;psy &gt;= 0)
        x4-&gt;params.analyse.b_psy  = x4-&gt;psy;
    if (x4-&gt;rc_lookahead &gt;= 0)
        x4-&gt;params.rc.i_lookahead = x4-&gt;rc_lookahead;
    if (x4-&gt;weightp &gt;= 0)
        x4-&gt;params.analyse.i_weighted_pred = x4-&gt;weightp;
    if (x4-&gt;weightb &gt;= 0)
        x4-&gt;params.analyse.b_weighted_bipred = x4-&gt;weightb;
    if (x4-&gt;cplxblur &gt;= 0)
        x4-&gt;params.rc.f_complexity_blur = x4-&gt;cplxblur;

    if (x4-&gt;ssim &gt;= 0)
        x4-&gt;params.analyse.b_ssim = x4-&gt;ssim;
    if (x4-&gt;intra_refresh &gt;= 0)
        x4-&gt;params.b_intra_refresh = x4-&gt;intra_refresh;
    if (x4-&gt;bluray_compat &gt;= 0) {
        x4-&gt;params.b_bluray_compat = x4-&gt;bluray_compat;
        x4-&gt;params.b_vfr_input = 0;
    }
    if (x4-&gt;avcintra_class &gt;= 0)
#if X264_BUILD &gt;= 142
        x4-&gt;params.i_avcintra_class = x4-&gt;avcintra_class;
#else
        av_log(avctx, AV_LOG_ERROR,
               "x264 too old for AVC Intra, at least version 142 needed\n");
#endif
    if (x4-&gt;b_bias != INT_MIN)
        x4-&gt;params.i_bframe_bias              = x4-&gt;b_bias;
    if (x4-&gt;b_pyramid &gt;= 0)
        x4-&gt;params.i_bframe_pyramid = x4-&gt;b_pyramid;
    if (x4-&gt;mixed_refs &gt;= 0)
        x4-&gt;params.analyse.b_mixed_references = x4-&gt;mixed_refs;
    if (x4-&gt;dct8x8 &gt;= 0)
        x4-&gt;params.analyse.b_transform_8x8    = x4-&gt;dct8x8;
    if (x4-&gt;fast_pskip &gt;= 0)
        x4-&gt;params.analyse.b_fast_pskip       = x4-&gt;fast_pskip;
    if (x4-&gt;aud &gt;= 0)
        x4-&gt;params.b_aud                      = x4-&gt;aud;
    if (x4-&gt;mbtree &gt;= 0)
        x4-&gt;params.rc.b_mb_tree               = x4-&gt;mbtree;
    if (x4-&gt;direct_pred &gt;= 0)
        x4-&gt;params.analyse.i_direct_mv_pred   = x4-&gt;direct_pred;

    if (x4-&gt;slice_max_size &gt;= 0)
        x4-&gt;params.i_slice_max_size =  x4-&gt;slice_max_size;
    else {
        /*
         * Allow x264 to be instructed through AVCodecContext about the maximum
         * size of the RTP payload. For example, this enables the production of
         * payload suitable for the H.264 RTP packetization-mode 0 i.e. single
         * NAL unit per RTP packet.
         */
        if (avctx-&gt;rtp_payload_size)
            x4-&gt;params.i_slice_max_size = avctx-&gt;rtp_payload_size;
    }

    if (x4-&gt;fastfirstpass)
        x264_param_apply_fastfirstpass(&amp;x4-&gt;params);

    /* Allow specifying the x264 profile through AVCodecContext. */
    //设置Profile
    if (!x4-&gt;profile)
        switch (avctx-&gt;profile) {
        case FF_PROFILE_H264_BASELINE:
            x4-&gt;profile = av_strdup("baseline");
            break;
        case FF_PROFILE_H264_HIGH:
            x4-&gt;profile = av_strdup("high");
            break;
        case FF_PROFILE_H264_HIGH_10:
            x4-&gt;profile = av_strdup("high10");
            break;
        case FF_PROFILE_H264_HIGH_422:
            x4-&gt;profile = av_strdup("high422");
            break;
        case FF_PROFILE_H264_HIGH_444:
            x4-&gt;profile = av_strdup("high444");
            break;
        case FF_PROFILE_H264_MAIN:
            x4-&gt;profile = av_strdup("main");
            break;
        default:
            break;
        }

    if (x4-&gt;nal_hrd &gt;= 0)
        x4-&gt;params.i_nal_hrd = x4-&gt;nal_hrd;
    //
    if (x4-&gt;profile)
        if (x264_param_apply_profile(&amp;x4-&gt;params, x4-&gt;profile) &lt; 0) {
            int i;
            av_log(avctx, AV_LOG_ERROR, "Error setting profile %s.\n", x4-&gt;profile);
            av_log(avctx, AV_LOG_INFO, "Possible profiles:");
            for (i = 0; x264_profile_names[i]; i++)
                av_log(avctx, AV_LOG_INFO, " %s", x264_profile_names[i]);
            av_log(avctx, AV_LOG_INFO, "\n");
            return AVERROR(EINVAL);
        }
    //宽高，帧率等
    x4-&gt;params.i_width          = avctx-&gt;width;
    x4-&gt;params.i_height         = avctx-&gt;height;
    av_reduce(&amp;sw, &amp;sh, avctx-&gt;sample_aspect_ratio.num, avctx-&gt;sample_aspect_ratio.den, 4096);
    x4-&gt;params.vui.i_sar_width  = sw;
    x4-&gt;params.vui.i_sar_height = sh;
    x4-&gt;params.i_timebase_den = avctx-&gt;time_base.den;
    x4-&gt;params.i_timebase_num = avctx-&gt;time_base.num;
    x4-&gt;params.i_fps_num = avctx-&gt;time_base.den;
    x4-&gt;params.i_fps_den = avctx-&gt;time_base.num * avctx-&gt;ticks_per_frame;

    x4-&gt;params.analyse.b_psnr = avctx-&gt;flags &amp; CODEC_FLAG_PSNR;

    x4-&gt;params.i_threads      = avctx-&gt;thread_count;
    if (avctx-&gt;thread_type)
        x4-&gt;params.b_sliced_threads = avctx-&gt;thread_type == FF_THREAD_SLICE;

    x4-&gt;params.b_interlaced   = avctx-&gt;flags &amp; CODEC_FLAG_INTERLACED_DCT;

    x4-&gt;params.b_open_gop     = !(avctx-&gt;flags &amp; CODEC_FLAG_CLOSED_GOP);

    x4-&gt;params.i_slice_count  = avctx-&gt;slices;

    x4-&gt;params.vui.b_fullrange = avctx-&gt;pix_fmt == AV_PIX_FMT_YUVJ420P ||
                                 avctx-&gt;pix_fmt == AV_PIX_FMT_YUVJ422P ||
                                 avctx-&gt;pix_fmt == AV_PIX_FMT_YUVJ444P ||
                                 avctx-&gt;color_range == AVCOL_RANGE_JPEG;

    if (avctx-&gt;colorspace != AVCOL_SPC_UNSPECIFIED)
        x4-&gt;params.vui.i_colmatrix = avctx-&gt;colorspace;
    if (avctx-&gt;color_primaries != AVCOL_PRI_UNSPECIFIED)
        x4-&gt;params.vui.i_colorprim = avctx-&gt;color_primaries;
    if (avctx-&gt;color_trc != AVCOL_TRC_UNSPECIFIED)
        x4-&gt;params.vui.i_transfer  = avctx-&gt;color_trc;

    if (avctx-&gt;flags &amp; CODEC_FLAG_GLOBAL_HEADER)
        x4-&gt;params.b_repeat_headers = 0;

    if(x4-&gt;x264opts){
        const char *p= x4-&gt;x264opts;
        while(p){
            char param[256]={0}, val[256]={0};
            if(sscanf(p, "%255[^:=]=%255[^:]", param, val) == 1){
                OPT_STR(param, "1");
            }else
                OPT_STR(param, val);
            p= strchr(p, ':');
            p+=!!p;
        }
    }

    if (x4-&gt;x264_params) {
        AVDictionary *dict    = NULL;
        AVDictionaryEntry *en = NULL;

        if (!av_dict_parse_string(&amp;dict, x4-&gt;x264_params, "=", ":", 0)) {
            while ((en = av_dict_get(dict, "", en, AV_DICT_IGNORE_SUFFIX))) {
                if (x264_param_parse(&amp;x4-&gt;params, en-&gt;key, en-&gt;value) &lt; 0)
                    av_log(avctx, AV_LOG_WARNING,
                           "Error parsing option '%s = %s'.\n",
                            en-&gt;key, en-&gt;value);
            }

            av_dict_free(&amp;dict);
        }
    }

    // update AVCodecContext with x264 parameters
    avctx-&gt;has_b_frames = x4-&gt;params.i_bframe ?
        x4-&gt;params.i_bframe_pyramid ? 2 : 1 : 0;
    if (avctx-&gt;max_b_frames &lt; 0)
        avctx-&gt;max_b_frames = 0;

    avctx-&gt;bit_rate = x4-&gt;params.rc.i_bitrate*1000;

    //-------------------------
    //设置完参数后，打开编码器
    x4-&gt;enc = x264_encoder_open(&amp;x4-&gt;params);
    if (!x4-&gt;enc)
        return -1;

    avctx-&gt;coded_frame = av_frame_alloc();
    if (!avctx-&gt;coded_frame)
        return AVERROR(ENOMEM);
    //如果需要全局头
    if (avctx-&gt;flags &amp; CODEC_FLAG_GLOBAL_HEADER) {
        x264_nal_t *nal;
        uint8_t *p;
        int nnal, s, i;

        s = x264_encoder_headers(x4-&gt;enc, &amp;nal, &amp;nnal);
        avctx-&gt;extradata = p = av_malloc(s);

        for (i = 0; i &lt; nnal; i++) {
            /* Don't put the SEI in extradata. */
            if (nal[i].i_type == NAL_SEI) {
                av_log(avctx, AV_LOG_INFO, "%s\n", nal[i].p_payload+25);
                x4-&gt;sei_size = nal[i].i_payload;
                x4-&gt;sei      = av_malloc(x4-&gt;sei_size);
                memcpy(x4-&gt;sei, nal[i].p_payload, nal[i].i_payload);
                continue;
            }
            memcpy(p, nal[i].p_payload, nal[i].i_payload);
            p += nal[i].i_payload;
        }
        avctx-&gt;extradata_size = p - avctx-&gt;extradata;
    }

    return 0;
}
</pre>
    <br/>
    从源代码可以看出，X264_init()主要将各种选项值传递给libx264。这些选项有两个来源：AVCodecContext和X264Context。AVCodecContext中包含了编码器的一些通用选项，而X264Context包含了一些libx264特有的选项。在这里需要注意，FFmpeg中的一些选项的单位和libx264中对应选项的单位是不一样的，因此需要做一些转换。例如像素格式的转换函数convert_pix_fmt()就是完成了这个功能。该函数的定义如下所示。
    <br/>
    <pre class="cpp">//映射FFmpeg和libx264的像素格式
static int convert_pix_fmt(enum AVPixelFormat pix_fmt)
{
    switch (pix_fmt) {
    case AV_PIX_FMT_YUV420P:
    case AV_PIX_FMT_YUVJ420P:
    case AV_PIX_FMT_YUV420P9:
    case AV_PIX_FMT_YUV420P10: return X264_CSP_I420;
    case AV_PIX_FMT_YUV422P:
    case AV_PIX_FMT_YUVJ422P:
    case AV_PIX_FMT_YUV422P10: return X264_CSP_I422;
    case AV_PIX_FMT_YUV444P:
    case AV_PIX_FMT_YUVJ444P:
    case AV_PIX_FMT_YUV444P9:
    case AV_PIX_FMT_YUV444P10: return X264_CSP_I444;
#ifdef X264_CSP_BGR
    case AV_PIX_FMT_BGR24:
        return X264_CSP_BGR;

    case AV_PIX_FMT_RGB24:
        return X264_CSP_RGB;
#endif
    case AV_PIX_FMT_NV12:      return X264_CSP_NV12;
    case AV_PIX_FMT_NV16:
    case AV_PIX_FMT_NV20:      return X264_CSP_NV16;
    };
    return 0;
}
</pre>
    <br/>
    可以看出convert_pix_fmt()将AV_PIX_FMT_XXX转换成了X264_CSP_XXX。
    <br/>
    在一切参数设置完毕后，X264_init()会调用x264_encoder_open()打开编码器，完成初始化工作。
    <br/>
    <br/>
    <h2>
     X264_frame()
    </h2>
    X264_frame()用于编码一帧视频数据。该函数的定义如下所示。
    <br/>
    <pre class="cpp">//libx264编码1帧数据
//
// AVFrame --&gt; x264_picture_t --&gt; x264_nal_t --&gt; AVPacket
//
static int X264_frame(AVCodecContext *ctx, AVPacket *pkt, const AVFrame *frame,
                      int *got_packet)
{
    X264Context *x4 = ctx-&gt;priv_data;
    x264_nal_t *nal;
    int nnal, i, ret;
    x264_picture_t pic_out = {0};
    AVFrameSideData *side_data;

    x264_picture_init( &amp;x4-&gt;pic );
    x4-&gt;pic.img.i_csp   = x4-&gt;params.i_csp;
    if (x264_bit_depth &gt; 8)
        x4-&gt;pic.img.i_csp |= X264_CSP_HIGH_DEPTH;
    x4-&gt;pic.img.i_plane = avfmt2_num_planes(ctx-&gt;pix_fmt);

    if (frame) {
    	//将AVFrame中的数据赋值给x264_picture_t
    	//
    	// AVFrame --&gt; x264_picture_t
        //
    	for (i = 0; i &lt; x4-&gt;pic.img.i_plane; i++) {
            x4-&gt;pic.img.plane[i]    = frame-&gt;data[i];
            x4-&gt;pic.img.i_stride[i] = frame-&gt;linesize[i];
        }

        x4-&gt;pic.i_pts  = frame-&gt;pts;
        //设置帧类型
        x4-&gt;pic.i_type =
            frame-&gt;pict_type == AV_PICTURE_TYPE_I ? X264_TYPE_KEYFRAME :
            frame-&gt;pict_type == AV_PICTURE_TYPE_P ? X264_TYPE_P :
            frame-&gt;pict_type == AV_PICTURE_TYPE_B ? X264_TYPE_B :
                                            X264_TYPE_AUTO;
        //检查参数设置是否正确，不正确就重新设置
        if (x4-&gt;avcintra_class &lt; 0) {
        if (x4-&gt;params.b_interlaced &amp;&amp; x4-&gt;params.b_tff != frame-&gt;top_field_first) {
            x4-&gt;params.b_tff = frame-&gt;top_field_first;
            x264_encoder_reconfig(x4-&gt;enc, &amp;x4-&gt;params);
        }
        if (x4-&gt;params.vui.i_sar_height != ctx-&gt;sample_aspect_ratio.den ||
            x4-&gt;params.vui.i_sar_width  != ctx-&gt;sample_aspect_ratio.num) {
            x4-&gt;params.vui.i_sar_height = ctx-&gt;sample_aspect_ratio.den;
            x4-&gt;params.vui.i_sar_width  = ctx-&gt;sample_aspect_ratio.num;
            x264_encoder_reconfig(x4-&gt;enc, &amp;x4-&gt;params);
        }

        if (x4-&gt;params.rc.i_vbv_buffer_size != ctx-&gt;rc_buffer_size / 1000 ||
            x4-&gt;params.rc.i_vbv_max_bitrate != ctx-&gt;rc_max_rate    / 1000) {
            x4-&gt;params.rc.i_vbv_buffer_size = ctx-&gt;rc_buffer_size / 1000;
            x4-&gt;params.rc.i_vbv_max_bitrate = ctx-&gt;rc_max_rate    / 1000;
            x264_encoder_reconfig(x4-&gt;enc, &amp;x4-&gt;params);
        }

        if (x4-&gt;params.rc.i_rc_method == X264_RC_ABR &amp;&amp;
            x4-&gt;params.rc.i_bitrate != ctx-&gt;bit_rate / 1000) {
            x4-&gt;params.rc.i_bitrate = ctx-&gt;bit_rate / 1000;
            x264_encoder_reconfig(x4-&gt;enc, &amp;x4-&gt;params);
        }

        if (x4-&gt;crf &gt;= 0 &amp;&amp;
            x4-&gt;params.rc.i_rc_method == X264_RC_CRF &amp;&amp;
            x4-&gt;params.rc.f_rf_constant != x4-&gt;crf) {
            x4-&gt;params.rc.f_rf_constant = x4-&gt;crf;
            x264_encoder_reconfig(x4-&gt;enc, &amp;x4-&gt;params);
        }

        if (x4-&gt;params.rc.i_rc_method == X264_RC_CQP &amp;&amp;
            x4-&gt;cqp &gt;= 0 &amp;&amp;
            x4-&gt;params.rc.i_qp_constant != x4-&gt;cqp) {
            x4-&gt;params.rc.i_qp_constant = x4-&gt;cqp;
            x264_encoder_reconfig(x4-&gt;enc, &amp;x4-&gt;params);
        }

        if (x4-&gt;crf_max &gt;= 0 &amp;&amp;
            x4-&gt;params.rc.f_rf_constant_max != x4-&gt;crf_max) {
            x4-&gt;params.rc.f_rf_constant_max = x4-&gt;crf_max;
            x264_encoder_reconfig(x4-&gt;enc, &amp;x4-&gt;params);
        }
        }

        side_data = av_frame_get_side_data(frame, AV_FRAME_DATA_STEREO3D);
        if (side_data) {
            AVStereo3D *stereo = (AVStereo3D *)side_data-&gt;data;
            int fpa_type;

            switch (stereo-&gt;type) {
            case AV_STEREO3D_CHECKERBOARD:
                fpa_type = 0;
                break;
            case AV_STEREO3D_COLUMNS:
                fpa_type = 1;
                break;
            case AV_STEREO3D_LINES:
                fpa_type = 2;
                break;
            case AV_STEREO3D_SIDEBYSIDE:
                fpa_type = 3;
                break;
            case AV_STEREO3D_TOPBOTTOM:
                fpa_type = 4;
                break;
            case AV_STEREO3D_FRAMESEQUENCE:
                fpa_type = 5;
                break;
            default:
                fpa_type = -1;
                break;
            }

            if (fpa_type != x4-&gt;params.i_frame_packing) {
                x4-&gt;params.i_frame_packing = fpa_type;
                x264_encoder_reconfig(x4-&gt;enc, &amp;x4-&gt;params);
            }
        }
    }
    do {
    	//[libx264 API] 编码
    	//
    	// x264_picture_t --&gt; x264_nal_t
        //
        if (x264_encoder_encode(x4-&gt;enc, &amp;nal, &amp;nnal, frame? &amp;x4-&gt;pic: NULL, &amp;pic_out) &lt; 0)
            return -1;

        //把x264_nal_t赋值给AVPacket
    	//
    	// x264_nal_t --&gt; AVPacket
        //
        ret = encode_nals(ctx, pkt, nal, nnal);
        if (ret &lt; 0)
            return -1;
    } while (!ret &amp;&amp; !frame &amp;&amp; x264_encoder_delayed_frames(x4-&gt;enc));

    //赋值AVPacket相关的字段
    pkt-&gt;pts = pic_out.i_pts;
    pkt-&gt;dts = pic_out.i_dts;

    switch (pic_out.i_type) {
    case X264_TYPE_IDR:
    case X264_TYPE_I:
        ctx-&gt;coded_frame-&gt;pict_type = AV_PICTURE_TYPE_I;
        break;
    case X264_TYPE_P:
        ctx-&gt;coded_frame-&gt;pict_type = AV_PICTURE_TYPE_P;
        break;
    case X264_TYPE_B:
    case X264_TYPE_BREF:
        ctx-&gt;coded_frame-&gt;pict_type = AV_PICTURE_TYPE_B;
        break;
    }

    pkt-&gt;flags |= AV_PKT_FLAG_KEY*pic_out.b_keyframe;
    if (ret)
        ctx-&gt;coded_frame-&gt;quality = (pic_out.i_qpplus1 - 1) * FF_QP2LAMBDA;

    *got_packet = ret;
    return 0;
}
</pre>
    <br/>
    从源代码可以看出，X264_frame()调用x264_encoder_encode()完成了编码工作。x264_encoder_encode()的输入是x264_picture_t，输出是x264_nal_t；而X264_frame()的输入是AVFrame，输出是AVPacket。因此X264_frame()在调用编码函数前将AVFrame转换成了x264_picture_t，而在调用编码函数之后调用encode_nals()将x264_nal_t转换成了AVPacket。转换函数encode_nals()的定义如下所示。
    <br/>
    <pre class="cpp">//把x264_nal_t赋值给AVPacket
//
// x264_nal_t --&gt; AVPacket
//
static int encode_nals(AVCodecContext *ctx, AVPacket *pkt,
                       const x264_nal_t *nals, int nnal)
{
    X264Context *x4 = ctx-&gt;priv_data;
    uint8_t *p;
    int i, size = x4-&gt;sei_size, ret;

    if (!nnal)
        return 0;
    //NALU的大小
    //可能有多个NALU
    for (i = 0; i &lt; nnal; i++)
        size += nals[i].i_payload;

    if ((ret = ff_alloc_packet2(ctx, pkt, size)) &lt; 0)
        return ret;

    //p指向AVPacket的data
    p = pkt-&gt;data;

    /* Write the SEI as part of the first frame. */
    if (x4-&gt;sei_size &gt; 0 &amp;&amp; nnal &gt; 0) {
        if (x4-&gt;sei_size &gt; size) {
            av_log(ctx, AV_LOG_ERROR, "Error: nal buffer is too small\n");
            return -1;
        }
        memcpy(p, x4-&gt;sei, x4-&gt;sei_size);
        p += x4-&gt;sei_size;
        x4-&gt;sei_size = 0;
        av_freep(&amp;x4-&gt;sei);
    }
    //拷贝x264_nal_t的数据至AVPacket的数据
    //可能有多个NALU
    for (i = 0; i &lt; nnal; i++){
        memcpy(p, nals[i].p_payload, nals[i].i_payload);
        p += nals[i].i_payload;
    }

    return 1;
}
</pre>
    <br/>
    从源代码可以看出，encode_nals()的作用就是将多个x264_nal_t合并为一个AVPacket。
    <br/>
    <br/>
    <h2>
     X264_close()
    </h2>
    X264_close()用于关闭libx264解码器。该函数的定义如下所示。
    <br/>
    <pre class="cpp">//libx264关闭解码器
static av_cold int X264_close(AVCodecContext *avctx)
{
    X264Context *x4 = avctx-&gt;priv_data;

    av_freep(&amp;avctx-&gt;extradata);
    av_freep(&amp;x4-&gt;sei);

    //[libx264 API] 关闭解码器
    if (x4-&gt;enc)
        x264_encoder_close(x4-&gt;enc);

    av_frame_free(&amp;avctx-&gt;coded_frame);

    return 0;
}
</pre>
    <br/>
    可以看出X264_close()调用x264_encoder_close()关闭了libx264编码器。
    <br/>
    <br/>
    <br/>
    <br/>
    <br/>
    <strong>
     <span style="color:#660000;">
      雷霄骅
      <br/>
      leixiaohua1020@126.com
      <br/>
      http://blog.csdn.net/leixiaohua1020
     </span>
    </strong>
    <br/>
    <br/>
    <br/>
   </div>
  </div>
  <div style="display:none;" class="hide-article-box text-center csdn-tracking-statistics tracking-click" data-mod="popu_376">
   <a class="btn btn-red-hollow" id="btn-readmore">
    阅读更多
   </a>
  </div>
 </article>
 <div class="article-bar-bottom">
  <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。			https://blog.csdn.net/leixiaohua1020/article/details/45960409
  </div>
  <div class="tags-box artic-tag-box">
   <span class="label">
    文章标签：
   </span>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=libx264&amp;t=blog" target="_blank">
    libx264
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=FFmpeg&amp;t=blog" target="_blank">
    FFmpeg
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=H.264&amp;t=blog" target="_blank">
    H.264
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=视频编码&amp;t=blog" target="_blank">
    视频编码
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=AVCodec&amp;t=blog" target="_blank">
    AVCodec
   </a>
  </div>
  <div class="tags-box">
   <span class="label">
    个人分类：
   </span>
   <a class="tag-link" href="https://blog.csdn.net/leixiaohua1020/article/category/2619503" target="_blank">
    x264
   </a>
   <a class="tag-link" href="https://blog.csdn.net/leixiaohua1020/article/category/1360795" target="_blank">
    FFMPEG
   </a>
  </div>
  <div class="tags-box">
   <span class="label">
    所属专栏：
   </span>
   <a class="tag-link" href="https://blog.csdn.net/column/details/ffmpeg-devel.html" target="_blank">
    FFmpeg
   </a>
  </div>
 </div>
 <!-- !empty($pre_next_article[0]) -->
</div>
<div class="recommend-box">
                            <div style="background: #fff; border: dashed 1px #666; padding-left: 1em; padding-top: 1em; padding-bottom: 1em;">
                                <span style="font-size: 0.8em; font-weight: bold;">
                                    此PDF由<a style="color:#0000ff" href="http://www.github.com/spygg"  target="_blank">spygg</a>生成,请尊重原作者版权!!!
                                    <br/>
                                    我的邮箱:liushidc@163.com
                                </span>
                                </div> 
                        </div>
                    </main>
      
                </div>

            <script>
                var recommendCount = 0;
                var articleTit = "";
                var articleId = "";
                var commentscount = 0;

                //1禁止评论，2正常
                var commentAuth = 1;
                //百度搜索
                var baiduKey = "";
                var needInsertBaidu = "";
            </script>
            <script src="https://csdnimg.cn/release/phoenix/template/js/detail-effe72036e.min.js"></script>
            </body>
        </html>