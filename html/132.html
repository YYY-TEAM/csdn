
            <!DOCTYPE html>
            <html lang="zh-CN">
                <head>
                    <meta charset="UTF-8">
                    <title>
 SDL2源代码分析1：初始化（SDL_Init()） - CSDN博客
</title>

                <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-60a2c245da.min.css">
                <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-88717cedf2.min.css">

                <script type="text/javascript">
                var username = "";
                </script>

                <script src="https://csdnimg.cn/public/common/libs/jquery/jquery-1.9.1.min.js" type="text/javascript"></script>

                <!-- 新版上报 -->
                <!-- 新版上报end -->
                <link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.3/css/sandalstrap.min.css"> 
                </head>
                <body>    
        
                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
                    <div class="container clearfix pt0" id="mainBox">
        <main style="width: 100%;"><div class="blog-content-box">
 <div class="article-title-box" id="article_anchors_132">
  <span class="article-type type-1 float-left">
   原
  </span>
  <h1 class="title-article">
   SDL2源代码分析1：初始化（SDL_Init()）
  </h1>
 </div>
 <div class="article-info-box">
  <div class="article-bar-top d-flex">
   <span class="time">
    2014年11月01日 15:46:06
   </span>
   <div ">
    <span class="read-count">
     阅读数：20188
    </span>
   </div>
  </div>
 </div>
 <article>
  <div class="article_content clearfix csdn-tracking-statistics" data-dsm="post" data-mod="popu_307" data-pid="blog" id="article_content">
   <link href="https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css" rel="stylesheet"/>
   <div class="htmledit_views">
    <p>
     =====================================================
     <br/>
    </p>
    <p>
     SDL源代码分析系列文章列表：
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/40680907">
      SDL2源代码分析1：初始化（SDL_Init()）
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/40701203">
      SDL2源代码分析2：窗口（SDL_Window）
     </a>
     <br/>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/40723085">
      SDL2源代码分析3：渲染器（SDL_Renderer）
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/40743061">
      SDL2源代码分析4：纹理（SDL_Texture）
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/40876089">
      SDL2源代码分析5：更新纹理（SDL_UpdateTexture()）
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/40895593">
      SDL2源代码分析6：复制到渲染器（SDL_RenderCopy()）
     </a>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/40895797">
      SDL2源代码分析7：显示（SDL_RenderPresent()）
     </a>
     <br/>
    </p>
    <p>
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/41207787">
      SDL2源代码分析8：视频显示总结
     </a>
     <br/>
    </p>
    <p>
     =====================================================
    </p>
    <br/>
    <p>
     打算花一段时间研究一下SDL的内部代码。前面几篇文章《
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/40246783">
      最简单的视音频播放示例1：总述
     </a>
     》中记录了视频、音频播放的技术，文中提及了SDL实际上封装了Direct3D，DirectSound这类的底层API。但是SDL究竟是如何封装的呢？这次打算深入其源代码一探究竟，看看它是如何封装这些API的。
    </p>
    <div style="text-align:center;">
     <img alt="" src="https://img-blog.csdn.net/20141101152821257?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
     <br/>
    </div>
    <br/>
    <h2>
     SDL简介
    </h2>
    <p>
     有关SDL的简介在《
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/40525591">
      最简单的视音频播放示例7：SDL2播放RGB/YUV
     </a>
     》以及《
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/40544521">
      最简单的视音频播放示例9：SDL2播放PCM
     </a>
     》中已经叙述过了，不再重复。这两篇文章中也提到了一张SDL的原理图，如下所示：
    </p>
    <p style="text-align:center;">
     <img alt="" src="https://img-blog.csdn.net/20141101152841163?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
     <br/>
    </p>
    从这个图中可以看出，SDL根据系统的不同调用不同的API完成相应的功能。至于它是如何实现的，将会在后文中详细叙述。下面不再罗嗦，直接进入正题。
    <br/>
    使用SDL播放一个视频代码流程大体如下
    <br/>
    <strong>
     初始化:
    </strong>
    <br/>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
     SDL_Init(): 初始化SDL。
     <br/>
     SDL_CreateWindow(): 创建窗口（Window）。
     <br/>
     SDL_CreateRenderer(): 基于窗口创建渲染器（Render）。
     <br/>
     SDL_CreateTexture(): 创建纹理（Texture）。
    </blockquote>
    <strong>
     循环渲染数据:
    </strong>
    <br/>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
     SDL_UpdateTexture(): 设置纹理的数据。
     <br/>
     SDL_RenderCopy(): 纹理复制给渲染器。
     <br/>
     SDL_RenderPresent(): 显示。
    </blockquote>
    <span style="white-space:pre;">
    </span>
    本文分析这个流程中最基本的一个函数SDL_Init()。SDL_Init()是SDL运行的初始，通过分析该函数，可以了解到SDL内部的架构。
    <br/>
    <br/>
    <br/>
    <h2>
     获取源代码
    </h2>
    <p>
     SDL的源代码获取十分简单。访问SDL的官方网站（
     <a href="http://www.libsdl.org/">
      http://www.libsdl.org/
     </a>
     ），单击左侧的“Download”进入下载页面，然后下载“SourceCode”栏目下的文件就可以了。
    </p>
    <p style="text-align:center;">
     <img alt="" src="https://img-blog.csdn.net/20141101153050234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
     <br/>
    </p>
    下载下来的文件只有4MB左右大小，但是解压缩之后竟然有50MB左右大小，确实不可思议。
    <br/>
    <p>
     解压缩之后，源代码目录如下图所示。
    </p>
    <p style="text-align:center;">
     <img alt="" src="https://img-blog.csdn.net/20141101153024591?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
     <br/>
    </p>
    <p>
     几个关键的文件夹如下所示：
    </p>
    <p>
     1.
     <span style="white-space:pre;">
     </span>
     include：存储SDL的头文件的文件夹。
    </p>
    <p>
     2.
     <span style="white-space:pre;">
     </span>
     src：存储SDL源代码文件的文件夹。SDL根据功能模块的不同，将源代码分成了很多的文件夹。下图中标出了存储SDL几个子系统的源代码的文件夹。
    </p>
    <p style="text-align:center;">
     <img alt="" src="https://img-blog.csdn.net/20141101153039021?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
     <br/>
    </p>
    <p>
     3.
     <span style="white-space:pre;">
     </span>
     VisualC：存储VC解决方案的文件夹。从下图中可以看出，包含了VS2008，VS2010，VS2012，VS2013等各个版本的VC的解决方案。
    </p>
    <p style="text-align:center;">
     <img alt="" src="https://img-blog.csdn.net/20141101153158000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
     <br/>
    </p>
    <br/>
    <br/>
    实际上从文件名称我们可以看出，其它几个文件夹中，“Xcode，Xcode-iOS”包含了Xcode的项目文件，“test”包含了一些测试例子程序，“android-project”包含了Android下的项目文件。由于我们暂时不研究这些文件，就不详细分析了。
    <br/>
    <br/>
    <h2>
     SDL_Init()
    </h2>
    <p>
     <strong>
      <br/>
     </strong>
    </p>
    <p>
     <strong>
      函数简介
     </strong>
    </p>
    <p>
     下面这一部分进入正题，分析SDL的初始化函数SDL_Init()。该函数可以确定希望激活的子系统。SDL_Init()函数原型如下：
    </p>
    <pre class="cpp">int SDLCALL SDL_Init(Uint32 flags)</pre>
    <br/>
    其中，flags可以取下列值：
    <br/>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
     SDL_INIT_TIMER：定时器
     <br/>
     SDL_INIT_AUDIO：音频
     <br/>
     SDL_INIT_VIDEO：视频
     <br/>
     SDL_INIT_JOYSTICK：摇杆
     <br/>
     SDL_INIT_HAPTIC：触摸屏
     <br/>
     SDL_INIT_GAMECONTROLLER：游戏控制器
     <br/>
     SDL_INIT_EVENTS：事件
     <br/>
     SDL_INIT_NOPARACHUTE：不捕获关键信号（这个不理解）
     <br/>
     SDL_INIT_EVERYTHING：包含上述所有选项
    </blockquote>
    <p>
    </p>
    <p>
     <br/>
    </p>
    <p>
     <strong>
      函数调用关系图
     </strong>
    </p>
    <p>
     SDL_Init()关键函数的调用关系可以用下图表示。
    </p>
    <div style="text-align:center;">
     <a href="http://my.csdn.net/leixiaohua1020/album/detail/1792993">
      <img alt="" src="https://img-blog.csdn.net/20141101154025239?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
     </a>
    </div>
    <br/>
    <p>
     上面的函数调用关系图本来是一张高清大图，但是博客不支持这么大尺寸的图片。因此把图片缩小了，看上去比较模糊。相册里面上传了一份原始的大图片：
    </p>
    <p>
     <a href="http://my.csdn.net/leixiaohua1020/album/detail/1792993">
      http://my.csdn.net/leixiaohua1020/album/detail/1792993
     </a>
    </p>
    选择上述相册里面的图片，右键选择“另存为”即可保存原始大图片。
    <br/>
    <p>
     <br/>
    </p>
    <p>
     <strong>
      源代码分析
     </strong>
    </p>
    <p>
     SDL_Init()的实现位于SDL.c中。定义如下。
    </p>
    <pre class="cpp">int SDL_Init(Uint32 flags)
{
    return SDL_InitSubSystem(flags);
}</pre>
    <br/>
    <p>
     可以看出其代码只有一句，即调用了SDL_InitSubSystem()，下面我们看一下SDL_InitSubSystem()的定义。
    </p>
    <p>
    </p>
    <pre class="cpp">int SDL_InitSubSystem(Uint32 flags)
{
    if (!SDL_MainIsReady) {
        SDL_SetError("Application didn't initialize properly, did you include SDL_main.h in the file containing your main() function?");
        return -1;
    }


    /* Clear the error message */
    SDL_ClearError();


#if SDL_VIDEO_DRIVER_WINDOWS
	if ((flags &amp; (SDL_INIT_HAPTIC|SDL_INIT_JOYSTICK))) {
		if (SDL_HelperWindowCreate() &lt; 0) {
			return -1;
		}
	}
#endif


#if !SDL_TIMERS_DISABLED
    SDL_TicksInit();
#endif


    if ((flags &amp; SDL_INIT_GAMECONTROLLER)) {
        /* game controller implies joystick */
        flags |= SDL_INIT_JOYSTICK;
    }


    if ((flags &amp; (SDL_INIT_VIDEO|SDL_INIT_JOYSTICK))) {
        /* video or joystick implies events */
        flags |= SDL_INIT_EVENTS;
    }


    /* Initialize the event subsystem */
    if ((flags &amp; SDL_INIT_EVENTS)) {
#if !SDL_EVENTS_DISABLED
        if (SDL_PrivateShouldInitSubsystem(SDL_INIT_EVENTS)) {
            if (SDL_StartEventLoop() &lt; 0) {
                return (-1);
            }
            SDL_QuitInit();
        }
        SDL_PrivateSubsystemRefCountIncr(SDL_INIT_EVENTS);
#else
        return SDL_SetError("SDL not built with events support");
#endif
    }


    /* Initialize the timer subsystem */
    if ((flags &amp; SDL_INIT_TIMER)){
#if !SDL_TIMERS_DISABLED
        if (SDL_PrivateShouldInitSubsystem(SDL_INIT_TIMER)) {
            if (SDL_TimerInit() &lt; 0) {
                return (-1);
            }
        }
        SDL_PrivateSubsystemRefCountIncr(SDL_INIT_TIMER);
#else
        return SDL_SetError("SDL not built with timer support");
#endif
    }


    /* Initialize the video subsystem */
    if ((flags &amp; SDL_INIT_VIDEO)){
#if !SDL_VIDEO_DISABLED
        if (SDL_PrivateShouldInitSubsystem(SDL_INIT_VIDEO)) {
            if (SDL_VideoInit(NULL) &lt; 0) {
                return (-1);
            }
        }
        SDL_PrivateSubsystemRefCountIncr(SDL_INIT_VIDEO);
#else
        return SDL_SetError("SDL not built with video support");
#endif
    }


    /* Initialize the audio subsystem */
    if ((flags &amp; SDL_INIT_AUDIO)){
#if !SDL_AUDIO_DISABLED
        if (SDL_PrivateShouldInitSubsystem(SDL_INIT_AUDIO)) {
            if (SDL_AudioInit(NULL) &lt; 0) {
                return (-1);
            }
        }
        SDL_PrivateSubsystemRefCountIncr(SDL_INIT_AUDIO);
#else
        return SDL_SetError("SDL not built with audio support");
#endif
    }


    /* Initialize the joystick subsystem */
    if ((flags &amp; SDL_INIT_JOYSTICK)){
#if !SDL_JOYSTICK_DISABLED
        if (SDL_PrivateShouldInitSubsystem(SDL_INIT_JOYSTICK)) {
           if (SDL_JoystickInit() &lt; 0) {
               return (-1);
           }
        }
        SDL_PrivateSubsystemRefCountIncr(SDL_INIT_JOYSTICK);
#else
        return SDL_SetError("SDL not built with joystick support");
#endif
    }


    if ((flags &amp; SDL_INIT_GAMECONTROLLER)){
#if !SDL_JOYSTICK_DISABLED
        if (SDL_PrivateShouldInitSubsystem(SDL_INIT_GAMECONTROLLER)) {
            if (SDL_GameControllerInit() &lt; 0) {
                return (-1);
            }
        }
        SDL_PrivateSubsystemRefCountIncr(SDL_INIT_GAMECONTROLLER);
#else
        return SDL_SetError("SDL not built with joystick support");
#endif
    }


    /* Initialize the haptic subsystem */
    if ((flags &amp; SDL_INIT_HAPTIC)){
#if !SDL_HAPTIC_DISABLED
        if (SDL_PrivateShouldInitSubsystem(SDL_INIT_HAPTIC)) {
            if (SDL_HapticInit() &lt; 0) {
                return (-1);
            }
        }
        SDL_PrivateSubsystemRefCountIncr(SDL_INIT_HAPTIC);
#else
        return SDL_SetError("SDL not built with haptic (force feedback) support");
#endif
    }


    return (0);
}</pre>
    <br/>
    <p>
    </p>
    SDL_InitSubSystem()函数的定义看上去很长，实际上却并不复杂。下面简单阐述一下它的一些关键点：
    <br/>
    <p>
     1.
     <span style="white-space:pre;">
     </span>
     通过将传入的flag与子系统的宏定义（例如SDL_INIT_VIDEO，SDL_INIT_AUDIO等）相与，判断是否需要初始化该子系统。
    </p>
    <p>
     2.
     <span style="white-space:pre;">
     </span>
     有很多的预定义的宏，用于判断SDL是否支持这些子系统。例如SDL_EVENTS_DISABLED，SDL_TIMERS_DISABLED，SDL_VIDEO_DISABLED，SDL_AUDIO_DISABLED，SDL_JOYSTICK_DISABLED，SDL_HAPTIC_DISABLED等。这些宏的定义位于SDL_config_minimal.h文件中，如下所示。
    </p>
    <pre class="cpp">/* Enable the dummy audio driver (src/audio/dummy/\*.c) */
#define SDL_AUDIO_DRIVER_DUMMY  1


/* Enable the stub joystick driver (src/joystick/dummy/\*.c) */
#define SDL_JOYSTICK_DISABLED   1


/* Enable the stub haptic driver (src/haptic/dummy/\*.c) */
#define SDL_HAPTIC_DISABLED 1


/* Enable the stub shared object loader (src/loadso/dummy/\*.c) */
#define SDL_LOADSO_DISABLED 1


/* Enable the stub thread support (src/thread/generic/\*.c) */
#define SDL_THREADS_DISABLED    1


/* Enable the stub timer support (src/timer/dummy/\*.c) */
#define SDL_TIMERS_DISABLED 1


/* Enable the dummy video driver (src/video/dummy/\*.c) */
#define SDL_VIDEO_DRIVER_DUMMY  1


/* Enable the dummy filesystem driver (src/filesystem/dummy/\*.c) */
#define SDL_FILESYSTEM_DUMMY  1</pre>
    <br/>
    如果这些定义取值不为0，代表该子系统已经被disable了，就不编译指定子系统的源代码了。初始化的时候会调用SDL_SetError()函数输出错误信息。例如SDL_VIDEO_DISABLED如果设置为1的话，初始化视频子系统的时候会执行以下代码。
    <br/>
    <pre class="cpp">SDL_SetError("SDL not built with video support");</pre>
    <br/>
    <p>
     3.
     <span style="white-space:pre;">
     </span>
     在每一个子系统真正初始化之前，都会调用一个函数SDL_PrivateShouldInitSubsystem()。该函数用于检查目标子系统是否需要初始化。
    </p>
    <p>
     4.
     <span style="white-space:pre;">
     </span>
     在一个子系统初始化之后，都会调用一个函数SDL_PrivateSubsystemRefCountIncr()。该函数用于增加子系统的引用计数。
    </p>
    <p>
     5.
     <span style="white-space:pre;">
     </span>
     下表列出各个子系统的初始化函数。
    </p>
    <p>
    </p>
    <table align="center" border="1" cellpadding="0" cellspacing="0">
     <tbody>
      <tr>
       <td valign="top">
        <p>
         子系统名称
        </p>
       </td>
       <td valign="top">
        <p>
         函数
        </p>
       </td>
      </tr>
      <tr>
       <td valign="top">
        <p>
         AUDIO（音频）
        </p>
       </td>
       <td valign="top">
        <p>
         SDL_AudioInit()
        </p>
       </td>
      </tr>
      <tr>
       <td valign="top">
        <p>
         VIDEO（视频）
        </p>
       </td>
       <td valign="top">
        <p>
         SDL_VideoInit()
        </p>
       </td>
      </tr>
      <tr>
       <td valign="top">
        <p>
         TIMERS（定时器）
        </p>
       </td>
       <td valign="top">
        <p>
         SDL_TicksInit()，SDL_TimerInit()
        </p>
       </td>
      </tr>
      <tr>
       <td valign="top">
        <p>
         EVENTS（事件）
        </p>
       </td>
       <td valign="top">
        <p>
         SDL_StartEventLoop()
        </p>
       </td>
      </tr>
      <tr>
       <td valign="top">
        <p>
         JOYSTICK（摇杆）
        </p>
       </td>
       <td valign="top">
        <p>
         SDL_GameControllerInit()
        </p>
       </td>
      </tr>
      <tr>
       <td valign="top">
        <p>
         HAPTIC（触摸屏）
        </p>
       </td>
       <td valign="top">
        <p>
         SDL_HapticInit()
        </p>
       </td>
      </tr>
     </tbody>
    </table>
    <br/>
    <p>
     我们先不看JOYSTICK（摇杆），HAPTIC（触摸屏）这些方面的代码，专门关注AUDIO（音频），VIDEO（视频）这两个方面的代码。
    </p>
    <h3>
     1.
     <span style="white-space:pre;">
     </span>
     VIDEO（视频）
    </h3>
    视频子系统的初始化函数是SDL_VideoInit()。它的源代码位于video\SDL_video.c文件中，如下所示。
    <br/>
    <pre class="cpp">/*
 * Initialize the video and event subsystems -- determine native pixel format
 */
int SDL_VideoInit(const char *driver_name)
{
    SDL_VideoDevice *video;
    const char *hint;
    int index;
    int i;
    SDL_bool allow_screensaver;


    /* Check to make sure we don't overwrite '_this' */
    if (_this != NULL) {
        SDL_VideoQuit();
    }


#if !SDL_TIMERS_DISABLED
    SDL_TicksInit();
#endif


    /* Start the event loop */
    if (SDL_InitSubSystem(SDL_INIT_EVENTS) &lt; 0 ||
        SDL_KeyboardInit() &lt; 0 ||
        SDL_MouseInit() &lt; 0 ||
        SDL_TouchInit() &lt; 0) {
        return -1;
    }


    /* Select the proper video driver */
    index = 0;
    video = NULL;
    if (driver_name == NULL) {
        driver_name = SDL_getenv("SDL_VIDEODRIVER");
    }
    if (driver_name != NULL) {
        for (i = 0; bootstrap[i]; ++i) {
            if (SDL_strncasecmp(bootstrap[i]-&gt;name, driver_name, SDL_strlen(driver_name)) == 0) {
                if (bootstrap[i]-&gt;available()) {
                    video = bootstrap[i]-&gt;create(index);
                    break;
                }
            }
        }
    } else {
        for (i = 0; bootstrap[i]; ++i) {
            if (bootstrap[i]-&gt;available()) {
                video = bootstrap[i]-&gt;create(index);
                if (video != NULL) {
                    break;
                }
            }
        }
    }
    if (video == NULL) {
        if (driver_name) {
            return SDL_SetError("%s not available", driver_name);
        }
        return SDL_SetError("No available video device");
    }
    _this = video;
    _this-&gt;name = bootstrap[i]-&gt;name;
    _this-&gt;next_object_id = 1;




    /* Set some very sane GL defaults */
    _this-&gt;gl_config.driver_loaded = 0;
    _this-&gt;gl_config.dll_handle = NULL;
    SDL_GL_ResetAttributes();


    _this-&gt;current_glwin_tls = SDL_TLSCreate();
    _this-&gt;current_glctx_tls = SDL_TLSCreate();


    /* Initialize the video subsystem */
    if (_this-&gt;VideoInit(_this) &lt; 0) {
        SDL_VideoQuit();
        return -1;
    }


    /* Make sure some displays were added */
    if (_this-&gt;num_displays == 0) {
        SDL_VideoQuit();
        return SDL_SetError("The video driver did not add any displays");
    }


    /* Add the renderer framebuffer emulation if desired */
    if (ShouldUseTextureFramebuffer()) {
        _this-&gt;CreateWindowFramebuffer = SDL_CreateWindowTexture;
        _this-&gt;UpdateWindowFramebuffer = SDL_UpdateWindowTexture;
        _this-&gt;DestroyWindowFramebuffer = SDL_DestroyWindowTexture;
    }


    /* Disable the screen saver by default. This is a change from &lt;= 2.0.1,
       but most things using SDL are games or media players; you wouldn't
       want a screensaver to trigger if you're playing exclusively with a
       joystick, or passively watching a movie. Things that use SDL but
       function more like a normal desktop app should explicitly reenable the
       screensaver. */
    hint = SDL_GetHint(SDL_HINT_VIDEO_ALLOW_SCREENSAVER);
    if (hint) {
        allow_screensaver = SDL_atoi(hint) ? SDL_TRUE : SDL_FALSE;
    } else {
        allow_screensaver = SDL_FALSE;
    }
    if (!allow_screensaver) {
        SDL_DisableScreenSaver();
    }


    /* If we don't use a screen keyboard, turn on text input by default,
       otherwise programs that expect to get text events without enabling
       UNICODE input won't get any events.


       Actually, come to think of it, you needed to call SDL_EnableUNICODE(1)
       in SDL 1.2 before you got text input events.  Hmm...
     */
    if (!SDL_HasScreenKeyboardSupport()) {
        SDL_StartTextInput();
    }


    /* We're ready to go! */
    return 0;
}</pre>
    <br/>
    下面简单阐述一下它的大致步骤：
    <br/>
    <strong>
     1.
     <span style="white-space:pre;">
     </span>
     初始化一些子系统，比如EVENTS（事件）子系统。
    </strong>
    也就是说，就算在调用SDL_Init()的时候不指定初始化EVENTS子系统，在初始化VIDEO子系统的时候，同样也会初始化EVENTS子系统。
    <br/>
    <strong>
     2.
     <span style="white-space:pre;">
     </span>
     选择一个合适的SDL_VideoDevice。
    </strong>
    <br/>
    在这里，涉及到两个重要的结构体：SDL_VideoDevice以及VideoBootStrap。其中SDL_VideoDevice代表了一个视频驱动程序。VideoBootStrap从字面上理解是“视频驱动程序的引导程序”，即用于创建一个SDL_VideoDevice。因此，我们先来看看VideoBootStrap这个结构体。它的定义如下（位于video\SDL_sysvideo.h）。
    <br/>
    <pre class="cpp">typedef struct VideoBootStrap
{
    const char *name;
    const char *desc;
    int (*available) (void);
    SDL_VideoDevice *(*create) (int devindex);
} VideoBootStrap;</pre>
    <br/>
    <span style="white-space:pre;">
    </span>
    可以看出它的定义比较简单，每个字段的含义如下：
    <br/>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
     name：驱动名称
     <br/>
     desc：描述
     <br/>
     available()：检查是否可用的一个函数指针
     <br/>
     create()：创建SDL_VideoDevice的函数指针
    </blockquote>
    <br/>
    <br/>
    SDL中有一个VideoBootStrap类型的静态数组bootstrap。用于存储SDL支持的视频驱动程序。注意这是SDL“跨平台”特性中很重要的一部分。该静态数组定义如下（位于video\SDL_video.c）。
    <br/>
    <pre class="cpp">/* Available video drivers */
static VideoBootStrap *bootstrap[] = {
#if SDL_VIDEO_DRIVER_COCOA
    &amp;COCOA_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_X11
    &amp;X11_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_MIR
    &amp;MIR_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_DIRECTFB
    &amp;DirectFB_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_WINDOWS
    &amp;WINDOWS_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_WINRT
    &amp;WINRT_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_HAIKU
    &amp;HAIKU_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_PANDORA
    &amp;PND_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_UIKIT
    &amp;UIKIT_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_ANDROID
    &amp;Android_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_PSP
    &amp;PSP_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_RPI
    &amp;RPI_bootstrap,
#endif 
#if SDL_VIDEO_DRIVER_WAYLAND
    &amp;Wayland_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_DUMMY
    &amp;DUMMY_bootstrap,
#endif
    NULL
};</pre>
    <br/>
    <br/>
    从代码中可以看出，SDL通过预编译宏取值是否非0来判断是否支持该视频驱动。我们可以看一下Windows的视频设备驱动的定义。该设备驱动同样是一个静态变量，名称为WINDOWS_bootstrap（位于video\windows\SDL_windowsvideo.c）。
    <br/>
    <pre class="cpp">VideoBootStrap WINDOWS_bootstrap = {
    "windows", "SDL Windows video driver", WIN_Available, WIN_CreateDevice
};</pre>
    <br/>
    可以看出该视频驱动名称为“windows”，描述为“SDL Windows video driver”，检查是否可用的函数为“WIN_Available()”，创建SDL_VideoDevice的函数为“WIN_CreateDevice()”。
    <br/>
    同样， Android的视频设备驱动的名称为Android_bootstrap；PSP的视频设备驱动为PSP_bootstrap；X11的视频设备驱动为X11_bootstrap。不再一一例举。
    <br/>
    下面看一下Windows视频驱动中那两个函数的定义。WIN_Available()定义如下。
    <br/>
    <pre class="cpp">static int WIN_Available(void)
{
    return (1);
}</pre>
    <br/>
    <p>
     可见该函数没有做任何的处理。WIN_CreateDevice()定义如下。
    </p>
    <p>
    </p>
    <pre class="cpp">static SDL_VideoDevice *
WIN_CreateDevice(int devindex)
{
    SDL_VideoDevice *device;
    SDL_VideoData *data;


    SDL_RegisterApp(NULL, 0, NULL);


    /* Initialize all variables that we clean on shutdown */
    device = (SDL_VideoDevice *) SDL_calloc(1, sizeof(SDL_VideoDevice));
    if (device) {
        data = (struct SDL_VideoData *) SDL_calloc(1, sizeof(SDL_VideoData));
    } else {
        data = NULL;
    }
    if (!data) {
        SDL_free(device);
        SDL_OutOfMemory();
        return NULL;
    }
    device-&gt;driverdata = data;


    data-&gt;userDLL = SDL_LoadObject("USER32.DLL");
    if (data-&gt;userDLL) {
        data-&gt;CloseTouchInputHandle = (BOOL (WINAPI *)( HTOUCHINPUT )) SDL_LoadFunction(data-&gt;userDLL, "CloseTouchInputHandle");
        data-&gt;GetTouchInputInfo = (BOOL (WINAPI *)( HTOUCHINPUT, UINT, PTOUCHINPUT, int )) SDL_LoadFunction(data-&gt;userDLL, "GetTouchInputInfo");
        data-&gt;RegisterTouchWindow = (BOOL (WINAPI *)( HWND, ULONG )) SDL_LoadFunction(data-&gt;userDLL, "RegisterTouchWindow");
    }


    /* Set the function pointers */
    device-&gt;VideoInit = WIN_VideoInit;
    device-&gt;VideoQuit = WIN_VideoQuit;
    device-&gt;GetDisplayBounds = WIN_GetDisplayBounds;
    device-&gt;GetDisplayModes = WIN_GetDisplayModes;
    device-&gt;SetDisplayMode = WIN_SetDisplayMode;
    device-&gt;PumpEvents = WIN_PumpEvents;


#undef CreateWindow
    device-&gt;CreateWindow = WIN_CreateWindow;
    device-&gt;CreateWindowFrom = WIN_CreateWindowFrom;
    device-&gt;SetWindowTitle = WIN_SetWindowTitle;
    device-&gt;SetWindowIcon = WIN_SetWindowIcon;
    device-&gt;SetWindowPosition = WIN_SetWindowPosition;
    device-&gt;SetWindowSize = WIN_SetWindowSize;
    device-&gt;ShowWindow = WIN_ShowWindow;
    device-&gt;HideWindow = WIN_HideWindow;
    device-&gt;RaiseWindow = WIN_RaiseWindow;
    device-&gt;MaximizeWindow = WIN_MaximizeWindow;
    device-&gt;MinimizeWindow = WIN_MinimizeWindow;
    device-&gt;RestoreWindow = WIN_RestoreWindow;
    device-&gt;SetWindowBordered = WIN_SetWindowBordered;
    device-&gt;SetWindowFullscreen = WIN_SetWindowFullscreen;
    device-&gt;SetWindowGammaRamp = WIN_SetWindowGammaRamp;
    device-&gt;GetWindowGammaRamp = WIN_GetWindowGammaRamp;
    device-&gt;SetWindowGrab = WIN_SetWindowGrab;
    device-&gt;DestroyWindow = WIN_DestroyWindow;
    device-&gt;GetWindowWMInfo = WIN_GetWindowWMInfo;
    device-&gt;CreateWindowFramebuffer = WIN_CreateWindowFramebuffer;
    device-&gt;UpdateWindowFramebuffer = WIN_UpdateWindowFramebuffer;
    device-&gt;DestroyWindowFramebuffer = WIN_DestroyWindowFramebuffer;
    device-&gt;OnWindowEnter = WIN_OnWindowEnter;


    device-&gt;shape_driver.CreateShaper = Win32_CreateShaper;
    device-&gt;shape_driver.SetWindowShape = Win32_SetWindowShape;
    device-&gt;shape_driver.ResizeWindowShape = Win32_ResizeWindowShape;


#if SDL_VIDEO_OPENGL_WGL
    device-&gt;GL_LoadLibrary = WIN_GL_LoadLibrary;
    device-&gt;GL_GetProcAddress = WIN_GL_GetProcAddress;
    device-&gt;GL_UnloadLibrary = WIN_GL_UnloadLibrary;
    device-&gt;GL_CreateContext = WIN_GL_CreateContext;
    device-&gt;GL_MakeCurrent = WIN_GL_MakeCurrent;
    device-&gt;GL_SetSwapInterval = WIN_GL_SetSwapInterval;
    device-&gt;GL_GetSwapInterval = WIN_GL_GetSwapInterval;
    device-&gt;GL_SwapWindow = WIN_GL_SwapWindow;
    device-&gt;GL_DeleteContext = WIN_GL_DeleteContext;
#endif
    device-&gt;StartTextInput = WIN_StartTextInput;
    device-&gt;StopTextInput = WIN_StopTextInput;
    device-&gt;SetTextInputRect = WIN_SetTextInputRect;


    device-&gt;SetClipboardText = WIN_SetClipboardText;
    device-&gt;GetClipboardText = WIN_GetClipboardText;
    device-&gt;HasClipboardText = WIN_HasClipboardText;


    device-&gt;free = WIN_DeleteDevice;


    return device;
}</pre>
    <br/>
    <p>
    </p>
    <p>
     该函数首先通过SDL_calloc()的方法为创建的SDL_VideoDevice分配了一块内存，接下来为创建的SDL_VideoDevice结构体中的函数指针赋了一大堆的值。这也是SDL“跨平台”特性的一个特点：通过调用SDL_VideoDevice中的接口函数，就可以调用不同平台的具体实现功能的函数。
    </p>
    <p>
     PS：在这里补充一个SDL中内存分配函数的知识。在SDL中分配内存使用SDL_malloc()，SDL_calloc()，这些函数实际上就是malloc()，calloc()。它们的定义位于stdlib\SDL_malloc.c文件中。如下所示：
    </p>
    <p>
    </p>
    <pre class="cpp">#define memset  SDL_memset
#define memcpy  SDL_memcpy
#define malloc  SDL_malloc
#define calloc  SDL_calloc
#define realloc SDL_realloc
#define free    SDL_free</pre>
    <br/>
    下面来看一下SDL_VideoDevice这个结构体的定义（位于video\SDL_sysvideo.h）。
    <br/>
    <pre class="cpp">struct SDL_VideoDevice
{
    /* * * */
    /* The name of this video driver */
    const char *name;


    /* * * */
    /* Initialization/Query functions */


    /*
     * Initialize the native video subsystem, filling in the list of
     * displays for this driver, returning 0 or -1 if there's an error.
     */
    int (*VideoInit) (_THIS);


    /*
     * Reverse the effects VideoInit() -- called if VideoInit() fails or
     * if the application is shutting down the video subsystem.
     */
    void (*VideoQuit) (_THIS);


    /* * * */
    /*
     * Display functions
     */


    /*
     * Get the bounds of a display
     */
    int (*GetDisplayBounds) (_THIS, SDL_VideoDisplay * display, SDL_Rect * rect);


    /*
     * Get a list of the available display modes for a display.
     */
    void (*GetDisplayModes) (_THIS, SDL_VideoDisplay * display);


    /*
     * Setting the display mode is independent of creating windows, so
     * when the display mode is changed, all existing windows should have
     * their data updated accordingly, including the display surfaces
     * associated with them.
     */
    int (*SetDisplayMode) (_THIS, SDL_VideoDisplay * display, SDL_DisplayMode * mode);


    /* * * */
    /*
     * Window functions
     */
    int (*CreateWindow) (_THIS, SDL_Window * window);
    int (*CreateWindowFrom) (_THIS, SDL_Window * window, const void *data);
    void (*SetWindowTitle) (_THIS, SDL_Window * window);
    void (*SetWindowIcon) (_THIS, SDL_Window * window, SDL_Surface * icon);
    void (*SetWindowPosition) (_THIS, SDL_Window * window);
    void (*SetWindowSize) (_THIS, SDL_Window * window);
    void (*SetWindowMinimumSize) (_THIS, SDL_Window * window);
    void (*SetWindowMaximumSize) (_THIS, SDL_Window * window);
    void (*ShowWindow) (_THIS, SDL_Window * window);
    void (*HideWindow) (_THIS, SDL_Window * window);
    void (*RaiseWindow) (_THIS, SDL_Window * window);
    void (*MaximizeWindow) (_THIS, SDL_Window * window);
    void (*MinimizeWindow) (_THIS, SDL_Window * window);
    void (*RestoreWindow) (_THIS, SDL_Window * window);
    void (*SetWindowBordered) (_THIS, SDL_Window * window, SDL_bool bordered);
    void (*SetWindowFullscreen) (_THIS, SDL_Window * window, SDL_VideoDisplay * display, SDL_bool fullscreen);
    int (*SetWindowGammaRamp) (_THIS, SDL_Window * window, const Uint16 * ramp);
    int (*GetWindowGammaRamp) (_THIS, SDL_Window * window, Uint16 * ramp);
    void (*SetWindowGrab) (_THIS, SDL_Window * window, SDL_bool grabbed);
    void (*DestroyWindow) (_THIS, SDL_Window * window);
    int (*CreateWindowFramebuffer) (_THIS, SDL_Window * window, Uint32 * format, void ** pixels, int *pitch);
    int (*UpdateWindowFramebuffer) (_THIS, SDL_Window * window, const SDL_Rect * rects, int numrects);
    void (*DestroyWindowFramebuffer) (_THIS, SDL_Window * window);
    void (*OnWindowEnter) (_THIS, SDL_Window * window);


    /* * * */
    /*
     * Shaped-window functions
     */
    SDL_ShapeDriver shape_driver;


    /* Get some platform dependent window information */
      SDL_bool(*GetWindowWMInfo) (_THIS, SDL_Window * window,
                                  struct SDL_SysWMinfo * info);


    /* * * */
    /*
     * OpenGL support
     */
    int (*GL_LoadLibrary) (_THIS, const char *path);
    void *(*GL_GetProcAddress) (_THIS, const char *proc);
    void (*GL_UnloadLibrary) (_THIS);
      SDL_GLContext(*GL_CreateContext) (_THIS, SDL_Window * window);
    int (*GL_MakeCurrent) (_THIS, SDL_Window * window, SDL_GLContext context);
    void (*GL_GetDrawableSize) (_THIS, SDL_Window * window, int *w, int *h);
    int (*GL_SetSwapInterval) (_THIS, int interval);
    int (*GL_GetSwapInterval) (_THIS);
    void (*GL_SwapWindow) (_THIS, SDL_Window * window);
    void (*GL_DeleteContext) (_THIS, SDL_GLContext context);


    /* * * */
    /*
     * Event manager functions
     */
    void (*PumpEvents) (_THIS);


    /* Suspend the screensaver */
    void (*SuspendScreenSaver) (_THIS);


    /* Text input */
    void (*StartTextInput) (_THIS);
    void (*StopTextInput) (_THIS);
    void (*SetTextInputRect) (_THIS, SDL_Rect *rect);


    /* Screen keyboard */
    SDL_bool (*HasScreenKeyboardSupport) (_THIS);
    void (*ShowScreenKeyboard) (_THIS, SDL_Window *window);
    void (*HideScreenKeyboard) (_THIS, SDL_Window *window);
    SDL_bool (*IsScreenKeyboardShown) (_THIS, SDL_Window *window);


    /* Clipboard */
    int (*SetClipboardText) (_THIS, const char *text);
    char * (*GetClipboardText) (_THIS);
    SDL_bool (*HasClipboardText) (_THIS);


    /* MessageBox */
    int (*ShowMessageBox) (_THIS, const SDL_MessageBoxData *messageboxdata, int *buttonid);


    /* * * */
    /* Data common to all drivers */
    SDL_bool suspend_screensaver;
    int num_displays;
    SDL_VideoDisplay *displays;
    SDL_Window *windows;
    Uint8 window_magic;
    Uint32 next_object_id;
    char * clipboard_text;


    /* * * */
    /* Data used by the GL drivers */
    struct
    {
        int red_size;
        int green_size;
        int blue_size;
        int alpha_size;
        int depth_size;
        int buffer_size;
        int stencil_size;
        int double_buffer;
        int accum_red_size;
        int accum_green_size;
        int accum_blue_size;
        int accum_alpha_size;
        int stereo;
        int multisamplebuffers;
        int multisamplesamples;
        int accelerated;
        int major_version;
        int minor_version;
        int flags;
        int profile_mask;
        int share_with_current_context;
        int framebuffer_srgb_capable;
        int retained_backing;
        int driver_loaded;
        char driver_path[256];
        void *dll_handle;
    } gl_config;


    /* * * */
    /* Cache current GL context; don't call the OS when it hasn't changed. */
    /* We have the global pointers here so Cocoa continues to work the way
       it always has, and the thread-local storage for the general case.
     */
    SDL_Window *current_glwin;
    SDL_GLContext current_glctx;
    SDL_TLSID current_glwin_tls;
    SDL_TLSID current_glctx_tls;


    /* * * */
    /* Data private to this driver */
    void *driverdata;
    struct SDL_GLDriverData *gl_data;
    
#if SDL_VIDEO_OPENGL_EGL
    struct SDL_EGL_VideoData *egl_data;
#endif
    
#if SDL_VIDEO_OPENGL_ES || SDL_VIDEO_OPENGL_ES2
    struct SDL_PrivateGLESData *gles_data;
#endif


    /* * * */
    /* The function used to dispose of this structure */
    void (*free) (_THIS);
};</pre>
    <br/>
    这个结构体包含了一大堆的函数指针。这些指针在前文所说的VideoBootStrap的create()方法调用的时候会被赋值。SDL通过调用这些函数指针，完成视频显示的各项内容。
    <br/>
    <br/>
    <br/>
    <strong>
     3.
     <span style="white-space:pre;">
     </span>
     调用选中的SDL_VideoDevice的VideoInit()方法。
    </strong>
    <br/>
    选择了合适的SDL_VideoDevice之后，调用该SDL_VideoDevice的VideoInit()就可以真正的初始化视频驱动了。以Windows系统为例。从前文的函数中可以看出，Windows系统的VideoInit()接口实际上调用了WIN_VideoInit()函数。我们来看一下WIN_VideoInit()函数的定义（位于video\windows\SDL_windowsvideo.c）。
    <br/>
    <pre class="cpp">int WIN_VideoInit(_THIS)
{
    if (WIN_InitModes(_this) &lt; 0) {
        return -1;
    }


    WIN_InitKeyboard(_this);
    WIN_InitMouse(_this);


    return 0;
}</pre>
    <br/>
    <br/>
    其中有3个函数：WIN_InitModes()，WIN_InitKeyboard()，WIN_InitMouse()。后两个函数用于初始化键盘和鼠标，我们暂且不研究。看一下WIN_InitModes()的函数。
    <br/>
    <pre class="cpp">int WIN_InitModes(_THIS)
{
    int pass;
    DWORD i, j, count;
    DISPLAY_DEVICE device;


    device.cb = sizeof(device);


    /* Get the primary display in the first pass */
    for (pass = 0; pass &lt; 2; ++pass) {
        for (i = 0; ; ++i) {
            TCHAR DeviceName[32];


            if (!EnumDisplayDevices(NULL, i, &amp;device, 0)) {
                break;
            }
            if (!(device.StateFlags &amp; DISPLAY_DEVICE_ATTACHED_TO_DESKTOP)) {
                continue;
            }
            if (pass == 0) {
                if (!(device.StateFlags &amp; DISPLAY_DEVICE_PRIMARY_DEVICE)) {
                    continue;
                }
            } else {
                if (device.StateFlags &amp; DISPLAY_DEVICE_PRIMARY_DEVICE) {
                    continue;
                }
            }
            SDL_memcpy(DeviceName, device.DeviceName, sizeof(DeviceName));
#ifdef DEBUG_MODES
            printf("Device: %s\n", WIN_StringToUTF8(DeviceName));
#endif
            count = 0;
            for (j = 0; ; ++j) {
                if (!EnumDisplayDevices(DeviceName, j, &amp;device, 0)) {
                    break;
                }
                if (!(device.StateFlags &amp; DISPLAY_DEVICE_ATTACHED_TO_DESKTOP)) {
                    continue;
                }
                if (pass == 0) {
                    if (!(device.StateFlags &amp; DISPLAY_DEVICE_PRIMARY_DEVICE)) {
                        continue;
                    }
                } else {
                    if (device.StateFlags &amp; DISPLAY_DEVICE_PRIMARY_DEVICE) {
                        continue;
                    }
                }
                count += WIN_AddDisplay(device.DeviceName);
            }
            if (count == 0) {
                WIN_AddDisplay(DeviceName);
            }
        }
    }
    if (_this-&gt;num_displays == 0) {
        return SDL_SetError("No displays available");
    }
    return 0;
}</pre>
    <br/>
    <br/>
    该函数的作用就是获得系统中显示设备的信息。目前还没有深入研究，待有时间再补上该函数的分析。
    <br/>
    <br/>
    <h3>
     2.
     <span style="white-space:pre;">
     </span>
     AUDIO（音频）
    </h3>
    <p>
     音频子系统的初始化函数是SDL_ AudioInit ()。它的源代码位于audio\SDL_audio.c文件中，如下所示。
    </p>
    <pre class="cpp">int SDL_AudioInit(const char *driver_name)
{
    int i = 0;
    int initialized = 0;
    int tried_to_init = 0;


    if (SDL_WasInit(SDL_INIT_AUDIO)) {
        SDL_AudioQuit();        /* shutdown driver if already running. */
    }


    SDL_memset(¤t_audio, '\0', sizeof(current_audio));
    SDL_memset(open_devices, '\0', sizeof(open_devices));


    /* Select the proper audio driver */
    if (driver_name == NULL) {
        driver_name = SDL_getenv("SDL_AUDIODRIVER");
    }


    for (i = 0; (!initialized) &amp;&amp; (bootstrap[i]); ++i) {
        /* make sure we should even try this driver before doing so... */
        const AudioBootStrap *backend = bootstrap[i];
        if ((driver_name &amp;&amp; (SDL_strncasecmp(backend-&gt;name, driver_name, SDL_strlen(driver_name)) != 0)) ||
            (!driver_name &amp;&amp; backend-&gt;demand_only)) {
            continue;
        }


        tried_to_init = 1;
        SDL_memset(¤t_audio, 0, sizeof(current_audio));
        current_audio.name = backend-&gt;name;
        current_audio.desc = backend-&gt;desc;
        initialized = backend-&gt;init(¤t_audio.impl);
    }


    if (!initialized) {
        /* specific drivers will set the error message if they fail... */
        if (!tried_to_init) {
            if (driver_name) {
                SDL_SetError("Audio target '%s' not available", driver_name);
            } else {
                SDL_SetError("No available audio device");
            }
        }


        SDL_memset(¤t_audio, 0, sizeof(current_audio));
        return (-1);            /* No driver was available, so fail. */
    }


    finalize_audio_entry_points();


    return (0);
}</pre>
    <p>
     <br/>
    </p>
    <p>
     音频初始化和视频很类似，比视频简单一些，关键在于选择一个合适的SDL_AudioDriver。
    </p>
    <p>
     <br/>
    </p>
    在这里，涉及到两个重要的结构体：SDL_AudioDriver以及AudioBootStrap。其中SDL_AudioDriver代表了一个音频驱动程序。AudioBootStrap从字面上理解是“音频驱动程序的引导程序”，即用于创建一个SDL_AudioDriver。可以看出音频子系统中的结构体和视频子系统中的结构体的格式基本上是一模一样的。我们先来看看AudioBootStrap这个结构体。它的定义如下（位于audio\SDL_sysaudio.h）。
    <br/>
    <pre class="cpp">typedef struct AudioBootStrap
{
    const char *name;
    const char *desc;
    int (*init) (SDL_AudioDriverImpl * impl);
    int demand_only;  /* 1==request explicitly, or it won't be available. */
} AudioBootStrap;</pre>
    <br/>
    <span style="white-space:pre;">
    </span>
    可以看出它的定义比较简单，每个字段的含义如下：
    <br/>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
     name：驱动名称
     <br/>
     desc：描述
     <br/>
     init()：创建SDL_AudioDriver的函数指针
     <br/>
     demand_only：没有研究过。
    </blockquote>
    <br/>
    SDL中有一个AudioBootStrap类型的静态数组bootstrap。用于存储SDL支持的音频驱动程序。该静态数组定义如下（位于audio\SDL_audio.c）。
    <br/>
    <pre class="cpp">/* Available audio drivers */
static const AudioBootStrap *const bootstrap[] = {
#if SDL_AUDIO_DRIVER_PULSEAUDIO
    &amp;PULSEAUDIO_bootstrap,
#endif
#if SDL_AUDIO_DRIVER_ALSA
    &amp;ALSA_bootstrap,
#endif
#if SDL_AUDIO_DRIVER_SNDIO
    &amp;SNDIO_bootstrap,
#endif
#if SDL_AUDIO_DRIVER_BSD
    &amp;BSD_AUDIO_bootstrap,
#endif
#if SDL_AUDIO_DRIVER_OSS
    &amp;DSP_bootstrap,
#endif
#if SDL_AUDIO_DRIVER_QSA
    &amp;QSAAUDIO_bootstrap,
#endif
#if SDL_AUDIO_DRIVER_SUNAUDIO
    &amp;SUNAUDIO_bootstrap,
#endif
#if SDL_AUDIO_DRIVER_ARTS
    &amp;ARTS_bootstrap,
#endif
#if SDL_AUDIO_DRIVER_ESD
    &amp;ESD_bootstrap,
#endif
#if SDL_AUDIO_DRIVER_NAS
    &amp;NAS_bootstrap,
#endif
#if SDL_AUDIO_DRIVER_XAUDIO2
    &amp;XAUDIO2_bootstrap,
#endif
#if SDL_AUDIO_DRIVER_DSOUND
    &amp;DSOUND_bootstrap,
#endif
#if SDL_AUDIO_DRIVER_WINMM
    &amp;WINMM_bootstrap,
#endif
#if SDL_AUDIO_DRIVER_PAUDIO
    &amp;PAUDIO_bootstrap,
#endif
#if SDL_AUDIO_DRIVER_HAIKU
    &amp;HAIKUAUDIO_bootstrap,
#endif
#if SDL_AUDIO_DRIVER_COREAUDIO
    &amp;COREAUDIO_bootstrap,
#endif
#if SDL_AUDIO_DRIVER_DISK
    &amp;DISKAUD_bootstrap,
#endif
#if SDL_AUDIO_DRIVER_DUMMY
    &amp;DUMMYAUD_bootstrap,
#endif
#if SDL_AUDIO_DRIVER_FUSIONSOUND
    &amp;FUSIONSOUND_bootstrap,
#endif
#if SDL_AUDIO_DRIVER_ANDROID
    &amp;ANDROIDAUD_bootstrap,
#endif
#if SDL_AUDIO_DRIVER_PSP
    &amp;PSPAUD_bootstrap,
#endif
    NULL
};</pre>
    <br/>
    <br/>
    在这里我们可以看一下DirectSound的AudioBootStrap的变量DSOUND_bootstrap（audio\directsound\SDL_directsound.c）。
    <br/>
    <pre class="cpp">AudioBootStrap DSOUND_bootstrap = {
    "directsound", "DirectSound", DSOUND_Init, 0
};</pre>
    <br/>
    可以看出该音频驱动名称为“directsound”，描述为“DirectSound”，创建SDL_AudioDriver的函数为“DSOUND_Init()”。
    <br/>
    下面看一下DirectSound初始化函数DSOUND_Init()的定义。
    <br/>
    <pre class="cpp">static int DSOUND_Init(SDL_AudioDriverImpl * impl)
{
    if (!DSOUND_Load()) {
        return 0;
    }


    /* Set the function pointers */
    impl-&gt;DetectDevices = DSOUND_DetectDevices;
    impl-&gt;OpenDevice = DSOUND_OpenDevice;
    impl-&gt;PlayDevice = DSOUND_PlayDevice;
    impl-&gt;WaitDevice = DSOUND_WaitDevice;
    impl-&gt;WaitDone = DSOUND_WaitDone;
    impl-&gt;GetDeviceBuf = DSOUND_GetDeviceBuf;
    impl-&gt;CloseDevice = DSOUND_CloseDevice;
    impl-&gt;Deinitialize = DSOUND_Deinitialize;


    return 1;   /* this audio target is available. */
}</pre>
    <br/>
    <br/>
    和视频驱动的初始化一样，音频驱动初始化也是对SDL_AudioDriver的接口指针进行赋值。在这里涉及到了一个DirectSound的加载函数DSOUND_Load()，我们可以看一下它的代码。
    <br/>
    <pre class="cpp">static int DSOUND_Load(void)
{
    int loaded = 0;


    DSOUND_Unload();


    DSoundDLL = SDL_LoadObject("DSOUND.DLL");
    if (DSoundDLL == NULL) {
        SDL_SetError("DirectSound: failed to load DSOUND.DLL");
    } else {
        /* Now make sure we have DirectX 8 or better... */
        #define DSOUNDLOAD(f) { \
            p##f = (fn##f) SDL_LoadFunction(DSoundDLL, #f); \
            if (!p##f) loaded = 0; \
        }
        loaded = 1;  /* will reset if necessary. */
        DSOUNDLOAD(DirectSoundCreate8);
        DSOUNDLOAD(DirectSoundEnumerateW);
        DSOUNDLOAD(DirectSoundCaptureEnumerateW);
        #undef DSOUNDLOAD


        if (!loaded) {
            SDL_SetError("DirectSound: System doesn't appear to have DX8.");
        }
    }


    if (!loaded) {
        DSOUND_Unload();
    }


    return loaded;
}</pre>
    <br/>
    <br/>
    从代码中可以看出，该函数加载了“DSOUND.DLL”的DirectSoundCreate8()，DirectSoundEnumerateW()，DirectSoundCaptureEnumerateW()函数。
    <br/>
    <br/>
   </div>
  </div>
  <div style="display:none;" class="hide-article-box text-center csdn-tracking-statistics tracking-click" data-mod="popu_376">
   <a class="btn btn-red-hollow" id="btn-readmore">
    阅读更多
   </a>
  </div>
 </article>
 <div class="article-bar-bottom">
  <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。			https://blog.csdn.net/leixiaohua1020/article/details/40680907
  </div>
  <div class="tags-box artic-tag-box">
   <span class="label">
    文章标签：
   </span>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=SDL&amp;t=blog" target="_blank">
    SDL
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=初始化&amp;t=blog" target="_blank">
    初始化
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=源代码分析&amp;t=blog" target="_blank">
    源代码分析
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=视频&amp;t=blog" target="_blank">
    视频
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=音频&amp;t=blog" target="_blank">
    音频
   </a>
  </div>
  <div class="tags-box">
   <span class="label">
    个人分类：
   </span>
   <a class="tag-link" href="https://blog.csdn.net/leixiaohua1020/article/category/2619497" target="_blank">
    SDL
   </a>
  </div>
  <div class="tags-box">
   <span class="label">
    所属专栏：
   </span>
   <a class="tag-link" href="https://blog.csdn.net/column/details/osmedia.html" target="_blank">
    开源多媒体项目源代码分析
   </a>
  </div>
 </div>
 <!-- !empty($pre_next_article[0]) -->
</div>
<div class="recommend-box">
                            <div style="background: #fff; border: dashed 1px #666; padding-left: 1em; padding-top: 1em; padding-bottom: 1em;">
                                <span style="font-size: 0.8em; font-weight: bold;">
                                    此PDF由<a style="color:#0000ff" href="http://www.github.com/spygg"  target="_blank">spygg</a>生成,请尊重原作者版权!!!
                                    <br/>
                                    我的邮箱:liushidc@163.com
                                </span>
                                </div> 
                        </div>
                    </main>
      
                </div>

            <script>
                var recommendCount = 0;
                var articleTit = "";
                var articleId = "";
                var commentscount = 0;

                //1禁止评论，2正常
                var commentAuth = 1;
                //百度搜索
                var baiduKey = "";
                var needInsertBaidu = "";
            </script>
            <script src="https://csdnimg.cn/release/phoenix/template/js/detail-effe72036e.min.js"></script>
            </body>
        </html>