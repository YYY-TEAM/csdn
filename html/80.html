
            <!DOCTYPE html>
            <html lang="zh-CN">
                <head>
                    <meta charset="UTF-8">
                    <title>
 FFmpeg源代码简单分析：日志输出系统（av_log()等） - CSDN博客
</title>

                <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/detail-60a2c245da.min.css">
                <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/themes/skin3-template/skin3-template-88717cedf2.min.css">

                <script type="text/javascript">
                var username = "";
                </script>

                <script src="https://csdnimg.cn/public/common/libs/jquery/jquery-1.9.1.min.js" type="text/javascript"></script>

                <!-- 新版上报 -->
                <!-- 新版上报end -->
                <link rel="stylesheet" href="https://csdnimg.cn/public/sandalstrap/1.3/css/sandalstrap.min.css"> 
                </head>
                <body>    
        
                    <link rel="stylesheet" href="https://csdnimg.cn/release/phoenix/template/css/blog_code-c3a0c33d5c.css">
                    <div class="container clearfix pt0" id="mainBox">
        <main style="width: 100%;"><div class="blog-content-box">
 <div class="article-title-box" id="article_anchors_80">
  <span class="article-type type-1 float-left">
   原
  </span>
  <h1 class="title-article">
   FFmpeg源代码简单分析：日志输出系统（av_log()等）
  </h1>
 </div>
 <div class="article-info-box">
  <div class="article-bar-top d-flex">
   <span class="time">
    2015年03月14日 12:19:53
   </span>
   <div ">
    <span class="read-count">
     阅读数：26083
    </span>
   </div>
  </div>
 </div>
 <article>
  <div class="article_content clearfix csdn-tracking-statistics" data-dsm="post" data-mod="popu_307" data-pid="blog" id="article_content">
   <link href="https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css" rel="stylesheet"/>
   <div class="htmledit_views">
    <p>
    </p>
    <p align="left">
     =====================================================
    </p>
    <p align="left">
     FFmpeg的库函数源代码分析文章列表：
    </p>
    <p align="left">
     【架构图】
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44220151">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码结构图 -
      </span>
      <span style="color:#0000FF;">
       解码
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44226355">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码结构图 -
      </span>
      <span style="color:#0000FF;">
       编码
      </span>
     </a>
    </p>
    <p align="left">
     【通用】
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/12677129">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       av_register_all()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/12677265">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avcodec_register_all()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/41176777">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：内存的分配和释放（
      </span>
      <span style="color:#0000FF;">
       av_malloc()
      </span>
      <span style="color:#0000FF;">
       、
      </span>
      <span style="color:#0000FF;">
       av_free()
      </span>
      <span style="color:#0000FF;">
       等）
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/41181155">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：常见结构体的初始化和销毁（
      </span>
      <span style="color:#0000FF;">
       AVFormatContext
      </span>
      <span style="color:#0000FF;">
       ，
      </span>
      <span style="color:#0000FF;">
       AVFrame
      </span>
      <span style="color:#0000FF;">
       等）
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/41199947">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avio_open2()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44084557">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       av_find_decoder()
      </span>
      <span style="color:#0000FF;">
       和
      </span>
      <span style="color:#0000FF;">
       av_find_encoder()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44117891">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avcodec_open2()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44206699">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avcodec_close()
      </span>
     </a>
    </p>
    <p align="left">
     【解码】
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/8661601">
      <span style="color:#0000FF;">
       图解
      </span>
      <span style="color:#0000FF;">
       FFMPEG
      </span>
      <span style="color:#0000FF;">
       打开媒体的函数
      </span>
      <span style="color:#0000FF;">
       avformat_open_input
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44064715">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avformat_open_input()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44084321">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avformat_find_stream_info()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/12678577">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       av_read_frame()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/12679719">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avcodec_decode_video2()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44110683">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avformat_close_input()
      </span>
     </a>
    </p>
    <p align="left">
     【编码】
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/41198929">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avformat_alloc_output_context2()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44116215">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avformat_write_header()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44206485">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       avcodec_encode_video()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44199673">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       av_write_frame()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44201645">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       av_write_trailer()
      </span>
     </a>
    </p>
    <p align="left">
     【其它】
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44243155">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：日志输出系统（
      </span>
      <span style="color:#0000FF;">
       av_log()
      </span>
      <span style="color:#0000FF;">
       等）
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44268323">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：结构体成员管理系统
      </span>
      <span style="color:#0000FF;">
       -AVClass
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44279329">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：结构体成员管理系统
      </span>
      <span style="color:#0000FF;">
       -AVOption
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44305697">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       libswscale
      </span>
      <span style="color:#0000FF;">
       的
      </span>
      <span style="color:#0000FF;">
       sws_getContext()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44346687">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       libswscale
      </span>
      <span style="color:#0000FF;">
       的
      </span>
      <span style="color:#0000FF;">
       sws_scale()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/41211121">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       libavdevice
      </span>
      <span style="color:#0000FF;">
       的
      </span>
      <span style="color:#0000FF;">
       avdevice_register_all()
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44597955">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       libavdevice
      </span>
      <span style="color:#0000FF;">
       的
      </span>
      <span style="color:#0000FF;">
       gdigrab
      </span>
     </a>
    </p>
    <p align="left">
     【脚本】
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44556525">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       makefile
      </span>
     </a>
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44587465">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       源代码简单分析：
      </span>
      <span style="color:#0000FF;">
       configure
      </span>
     </a>
    </p>
    <p align="left">
     【H.264】
    </p>
    <p align="left">
     <a href="http://blog.csdn.net/leixiaohua1020/article/details/44864509">
      <span style="color:#0000FF;">
       FFmpeg
      </span>
      <span style="color:#0000FF;">
       的
      </span>
      <span style="color:#0000FF;">
       H.264
      </span>
      <span style="color:#0000FF;">
       解码器源代码简单分析：概述
      </span>
     </a>
    </p>
    <p align="left">
     =====================================================
    </p>
    <br/>
    <p>
     本文分析一下FFmpeg的日志（Log）输出系统的源代码。日志输出部分的核心函数只有一个：av_log()。使用av_log()在控制台输出日志的效果如下图所示。
    </p>
    <p style="text-align:center;">
     <img alt="" src="https://img-blog.csdn.net/20150313170846773?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
     <br/>
    </p>
    <h2>
     函数调用结构图
    </h2>
    <p style="text-align:left;">
     FFmpeg日志输出系统的函数调用结构图如图所示。
     <br/>
    </p>
    <p style="text-align:center;">
     <img alt="" src="https://img-blog.csdn.net/20150313210943459"/>
     <br/>
    </p>
    <h2>
     av_log()
    </h2>
    av_log()是FFmpeg中输出日志的函数。随便打开一个FFmpeg的源代码文件，就会发现其中遍布着av_log()函数。一般情况下FFmpeg类库的源代码中是不允许使用printf()这种的函数的，所有的输出一律使用av_log()。
    <br/>
    av_log()的声明位于libavutil\log.h，如下所示。
    <br/>
    <pre class="cpp">/**
 * Send the specified message to the log if the level is less than or equal
 * to the current av_log_level. By default, all logging messages are sent to
 * stderr. This behavior can be altered by setting a different logging callback
 * function.
 * @see av_log_set_callback
 *
 * @param avcl A pointer to an arbitrary struct of which the first field is a
 *        pointer to an AVClass struct.
 * @param level The importance level of the message expressed using a @ref
 *        lavu_log_constants "Logging Constant".
 * @param fmt The format string (printf-compatible) that specifies how
 *        subsequent arguments are converted to output.
 */
void av_log(void *avcl, int level, const char *fmt, ...) av_printf_format(3, 4);</pre>
    <p>
     这个函数的声明有两个地方比较特殊：
    </p>
    （1）函数最后一个参数是“…”。
    <br/>
    在C语言中，在函数参数数量不确定的情况下使用“…”来代表参数。例如printf()的原型定义如下
    <br/>
    <pre class="cpp">int printf (const char*, ...);</pre>
    <p>
     后文中对此再作详细分析。
    </p>
    （2）它的声明后面有一个av_printf_format(3, 4)。有关这个地方的左右还没有深入研究，网上资料中说它的作用是按照printf()的格式检查av_log()的格式。
    <br/>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
     av_log()每个字段的含义如下：
     <br/>
     avcl：指定一个包含AVClass的结构体。
     <br/>
     level：log的级别
     <br/>
     fmt：和printf()一样。
    </blockquote>
    由此可见，av_log()和printf()的不同主要在于前面多了两个参数。其中第一个参数指定该log所属的结构体，例如AVFormatContext、AVCodecContext等等。第二个参数指定log的级别，源代码中定义了如下几个级别。
    <br/>
    <pre class="cpp">/**
 * Print no output.
 */
#define AV_LOG_QUIET    -8

/**
 * Something went really wrong and we will crash now.
 */
#define AV_LOG_PANIC     0

/**
 * Something went wrong and recovery is not possible.
 * For example, no header was found for a format which depends
 * on headers or an illegal combination of parameters is used.
 */
#define AV_LOG_FATAL     8

/**
 * Something went wrong and cannot losslessly be recovered.
 * However, not all future data is affected.
 */
#define AV_LOG_ERROR    16

/**
 * Something somehow does not look correct. This may or may not
 * lead to problems. An example would be the use of '-vstrict -2'.
 */
#define AV_LOG_WARNING  24

/**
 * Standard information.
 */
#define AV_LOG_INFO     32

/**
 * Detailed information.
 */
#define AV_LOG_VERBOSE  40

/**
 * Stuff which is only useful for libav* developers.
 */
#define AV_LOG_DEBUG    48
</pre>
    <br/>
    <p>
     从定义中可以看出来，随着严重程度逐渐下降，一共包含如下级别：AV_LOG_PANIC，AV_LOG_FATAL，AV_LOG_ERROR，AV_LOG_WARNING，AV_LOG_INFO，AV_LOG_VERBOSE，AV_LOG_DEBUG。每个级别定义的数值代表了严重程度，数值越小代表越严重。默认的级别是AV_LOG_INFO。此外，还有一个级别不输出任何信息，即AV_LOG_QUIET。
    </p>
    <p>
     当前系统存在着一个“Log级别”。所有严重程度高于该级别的Log信息都会输出出来。例如当前的Log级别是AV_LOG_WARNING，则会输出AV_LOG_PANIC，AV_LOG_FATAL，AV_LOG_ERROR，AV_LOG_WARNING级别的信息，而不会输出AV_LOG_INFO级别的信息。可以通过av_log_get_level()获得当前Log的级别，通过另一个函数av_log_set_level()设置当前的Log级别。
    </p>
    <p>
     <br/>
    </p>
    <h2>
     av_log_get_level(), av_log_set_level()
    </h2>
    <p>
     av_log_get_level()的定义如下所示
     <br/>
    </p>
    <pre class="cpp">/**
 * Get the current log level
 *
 * @see lavu_log_constants
 *
 * @return Current log level
 */
int av_log_get_level(void);</pre>
    <p>
     可以通过av_log_set_level()设置当前Log的级别。
    </p>
    <pre class="cpp">/**
 * Set the log level
 *
 * @see lavu_log_constants
 *
 * @param level Logging level
 */
void av_log_set_level(int level);</pre>
    上述两个函数的定义十分的简单，如下所示。
    <br/>
    <pre class="cpp">int av_log_get_level(void)
{
    return av_log_level;
}</pre>
    <pre class="cpp">void av_log_set_level(int level)
{
    av_log_level = level;
}</pre>
    从代码中可以看出，以上两个函数主要操作了一个静态全局变量av_log_level。该变量用于存储当前系统Log的级别。它的定义如下所示。
    <br/>
    <pre class="cpp">static int av_log_level = AV_LOG_INFO;</pre>
    下面我们看一下H.264编码的时候libx264的Log输出的示例：
    <br/>
    <div style="text-align:center;">
     <img alt="" src="https://img-blog.csdn.net/20150313182135575?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
    </div>
    下面回到av_log()函数的源代码。它的源代码位于libavutil\log.c，如下所示。
    <br/>
    <pre class="cpp">void av_log(void* avcl, int level, const char *fmt, ...)
{
    AVClass* avc = avcl ? *(AVClass **) avcl : NULL;
    va_list vl;
    va_start(vl, fmt);
    if (avc &amp;&amp; avc-&gt;version &gt;= (50 &lt;&lt; 16 | 15 &lt;&lt; 8 | 2) &amp;&amp;
        avc-&gt;log_level_offset_offset &amp;&amp; level &gt;= AV_LOG_FATAL)
        level += *(int *) (((uint8_t *) avcl) + avc-&gt;log_level_offset_offset);
    av_vlog(avcl, level, fmt, vl);
    va_end(vl);
}</pre>
    首先来提一下C语言函数中“…”参数的含义。与它相关还涉及到以下4个部分：
    <br/>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
     （1）va_list变量
     <br/>
     （2）va_start()
     <br/>
     （3）va_arg()
     <br/>
     （4）va_end()
    </blockquote>
    va_list是一个指向函数的参数的指针。va_start()用于初始化va_list变量。va_arg()用于返回可变参数。va_start()用于结束可变参数的获取。有关它们的用法可以参考一个小demo，如下所示。
    <br/>
    <pre class="cpp">#include &lt;stdio.h&gt;
#include&lt;stdarg.h&gt;
void fun(int a,...){
	va_list pp;
	va_start(pp,a);
	do{
		printf("param =%d\n",a);
		a=va_arg(pp,int);//使 pp 指向下一个参数，将下一个参数的值赋给变量 a
	}
	while (a!=0);//直到参数为 0 时停止循环
}
void main(){
	fun(20,40,60,80,0);
}</pre>
    <br/>
    有关这方面的知识很难用简短的语言描述清楚，因此不再详述。av_log()的源代码中，在va_start()和va_end()之间，调用了另一个函数av_vlog()。
    <br/>
    <p>
     <br/>
    </p>
    <h2>
     av_vlog()
    </h2>
    av_vlog()是一个FFmpeg的API函数。它的声明位于libavutil\log.h中，如下所示。
    <br/>
    <pre class="cpp">/**
 * Send the specified message to the log if the level is less than or equal
 * to the current av_log_level. By default, all logging messages are sent to
 * stderr. This behavior can be altered by setting a different logging callback
 * function.
 * @see av_log_set_callback
 *
 * @param avcl A pointer to an arbitrary struct of which the first field is a
 *        pointer to an AVClass struct.
 * @param level The importance level of the message expressed using a @ref
 *        lavu_log_constants "Logging Constant".
 * @param fmt The format string (printf-compatible) that specifies how
 *        subsequent arguments are converted to output.
 * @param vl The arguments referenced by the format string.
 */
void av_vlog(void *avcl, int level, const char *fmt, va_list vl);</pre>
    <p>
     <br/>
    </p>
    <p>
     从声明中可以看出，av_vlog()和av_log()的参数基本上是一模一样的。唯一的不同在于av_log()中的“…”变成了av_vlog()中的va_list。
    </p>
    av_vlog()的定义位于libavutil\log.c中，如下所示。
    <br/>
    <pre class="cpp">void av_vlog(void* avcl, int level, const char *fmt, va_list vl)
{
    void (*log_callback)(void*, int, const char*, va_list) = av_log_callback;
    if (log_callback)
        log_callback(avcl, level, fmt, vl);
}</pre>
    从定义中可以看出，av_vlog()简单调用了一个函数指针av_log_callback。av_log_callback是一个全局静态变量，定义如下所示。
    <br/>
    <pre class="cpp">static void (*av_log_callback)(void*, int, const char*, va_list) =
av_log_default_callback;</pre>
    从代码中可以看出，av_log_callback指针默认指向一个函数av_log_default_callback()。av_log_default_callback()即FFmpeg默认的Log函数。需要注意的是，这个Log函数是可以自定义的。按照指定的参数定义一个自定义的函数后，可以通过FFmpeg的另一个API函数av_log_set_callback()设定为Log函数。
    <br/>
    av_log_set_callback()的声明如下所示。
    <br/>
    <pre class="cpp">/**
 * Set the logging callback
 *
 * @note The callback must be thread safe, even if the application does not use
 *       threads itself as some codecs are multithreaded.
 *
 * @see av_log_default_callback
 *
 * @param callback A logging function with a compatible signature.
 */
void av_log_set_callback(void (*callback)(void*, int, const char*, va_list));</pre>
    从声明中可以看出，需要指定一个参数为(void*, int, const char*, va_list)，返回值为void的函数作为Log函数。
    <br/>
    av_log_set_callback()的定义很简单，做了一个函数指针赋值的工作，如下所示。
    <br/>
    <pre class="cpp">void av_log_set_callback(void (*callback)(void*, int, const char*, va_list))
{
    av_log_callback = callback;
}</pre>
    例如，我们可以指定一个my_logoutput()函数作为Log的输出函数，就可以将Log信息输出到文本中（而不是屏幕上）。
    <br/>
    <pre class="cpp">void my_logoutput(void* ptr, int level, const char* fmt,va_list vl){
	FILE *fp = fopen("my_log.txt","a+");   
	if(fp){   
		vfprintf(fp,fmt,vl);
		fflush(fp);
		fclose(fp);
	}   
}</pre>
    编辑好函数之后，使用av_log_set_callback()函数设置该函数为Log输出函数即可。
    <br/>
    <pre class="cpp">av_log_set_callback(my_logoutput);</pre>
    <br/>
    <h2>
     av_log_default_callback()
    </h2>
    下面我们看一下FFmpeg的默认Log输出函数av_log_default_callback()。它的定义如下。
    <br/>
    <pre class="cpp">void av_log_default_callback(void* ptr, int level, const char* fmt, va_list vl)
{
    static int print_prefix = 1;
    static int count;
    static char prev[LINE_SZ];
    AVBPrint part[4];
    char line[LINE_SZ];
    static int is_atty;
    int type[2];
    unsigned tint = 0;

    if (level &gt;= 0) {
        tint = level &amp; 0xff00;
        level &amp;= 0xff;
    }

    if (level &gt; av_log_level)
        return;
#if HAVE_PTHREADS
    pthread_mutex_lock(&amp;mutex);
#endif

    format_line(ptr, level, fmt, vl, part, &amp;print_prefix, type);
    snprintf(line, sizeof(line), "%s%s%s%s", part[0].str, part[1].str, part[2].str, part[3].str);

#if HAVE_ISATTY
    if (!is_atty)
        is_atty = isatty(2) ? 1 : -1;
#endif

    if (print_prefix &amp;&amp; (flags &amp; AV_LOG_SKIP_REPEATED) &amp;&amp; !strcmp(line, prev) &amp;&amp;
        *line &amp;&amp; line[strlen(line) - 1] != '\r'){
        count++;
        if (is_atty == 1)
            fprintf(stderr, "    Last message repeated %d times\r", count);
        goto end;
    }
    if (count &gt; 0) {
        fprintf(stderr, "    Last message repeated %d times\n", count);
        count = 0;
    }
    strcpy(prev, line);
    sanitize(part[0].str);
    colored_fputs(type[0], 0, part[0].str);
    sanitize(part[1].str);
    colored_fputs(type[1], 0, part[1].str);
    sanitize(part[2].str);
    colored_fputs(av_clip(level &gt;&gt; 3, 0, 6), tint &gt;&gt; 8, part[2].str);
    sanitize(part[3].str);
    colored_fputs(av_clip(level &gt;&gt; 3, 0, 6), tint &gt;&gt; 8, part[3].str);
end:
    av_bprint_finalize(part+3, NULL);
#if HAVE_PTHREADS
    pthread_mutex_unlock(&amp;mutex);
#endif
}
</pre>
    <br/>
    av_log_default_callback()的代码是比较复杂的。其实如果我们仅仅是希望把Log信息输出到屏幕上，远不需要那么多代码，只需要简单打印一下就可以了。av_log_default_callback()之所以会那么复杂，主要是因为他还包含了很多的功能，比如说根据Log级别的不同将输出的文本设置成不同的颜色等等。下图显示了不同级别的Log不同的背景颜色。
    <br/>
    <div style="text-align:center;">
     <img alt="" src="https://img-blog.csdn.net/20150313170846773?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
    </div>
    下面看一下av_log_default_callback()的源代码大致的流程：
    <br/>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
     （1）如果输入参数level大于系统当前的日志级别av_log_level，表明不需要做任何处理，直接返回。
     <br/>
     （2）调用format_line()设定Log的输出格式。
     <br/>
     （3）调用colored_fputs()设定Log的颜色。
    </blockquote>
    <br/>
    <h3>
     format_line(), av_log_format_line()
    </h3>
    format_line()用于设定Log的输出格式。它本身并不是一个FFmpeg的API，但是FFmpeg有一个API函数av_log_format_line()调用了这个函数。av_log_format_line()的声明如下所示。
    <br/>
    <pre class="cpp">/**
 * Format a line of log the same way as the default callback.
 * @param line          buffer to receive the formated line
 * @param line_size     size of the buffer
 * @param print_prefix  used to store whether the prefix must be printed;
 *                      must point to a persistent integer initially set to 1
 */
void av_log_format_line(void *ptr, int level, const char *fmt, va_list vl,
                        char *line, int line_size, int *print_prefix);</pre>
    <br/>
    av_log_format_line()的定义如下所示。
    <br/>
    <pre class="cpp">void av_log_format_line(void *ptr, int level, const char *fmt, va_list vl,
                        char *line, int line_size, int *print_prefix)
{
    AVBPrint part[4];
    format_line(ptr, level, fmt, vl, part, print_prefix, NULL);
    snprintf(line, line_size, "%s%s%s%s", part[0].str, part[1].str, part[2].str, part[3].str);
    av_bprint_finalize(part+3, NULL);
}</pre>
    <br/>
    从代码中可以看出，首先声明了一个AVBPrint类型的数组，其中包含了4个元素；接着调用format_line()设定格式；最后将设置格式后的AVBPrint数组中的4个元素连接起来。
    <br/>
    在这里遇到了一个结构体AVBPrint，它的定义位于libavutil\bprint.h，如下所示。
    <br/>
    <pre class="cpp">/**
 * Buffer to print data progressively
 *
 * The string buffer grows as necessary and is always 0-terminated.
 * The content of the string is never accessed, and thus is
 * encoding-agnostic and can even hold binary data.
 *
 * Small buffers are kept in the structure itself, and thus require no
 * memory allocation at all (unless the contents of the buffer is needed
 * after the structure goes out of scope). This is almost as lightweight as
 * declaring a local "char buf[512]".
 *
 * The length of the string can go beyond the allocated size: the buffer is
 * then truncated, but the functions still keep account of the actual total
 * length.
 *
 * In other words, buf-&gt;len can be greater than buf-&gt;size and records the
 * total length of what would have been to the buffer if there had been
 * enough memory.
 *
 * Append operations do not need to be tested for failure: if a memory
 * allocation fails, data stop being appended to the buffer, but the length
 * is still updated. This situation can be tested with
 * av_bprint_is_complete().
 *
 * The size_max field determines several possible behaviours:
 *
 * size_max = -1 (= UINT_MAX) or any large value will let the buffer be
 * reallocated as necessary, with an amortized linear cost.
 *
 * size_max = 0 prevents writing anything to the buffer: only the total
 * length is computed. The write operations can then possibly be repeated in
 * a buffer with exactly the necessary size
 * (using size_init = size_max = len + 1).
 *
 * size_max = 1 is automatically replaced by the exact size available in the
 * structure itself, thus ensuring no dynamic memory allocation. The
 * internal buffer is large enough to hold a reasonable paragraph of text,
 * such as the current paragraph.
 */
typedef struct AVBPrint {
    FF_PAD_STRUCTURE(1024,
    char *str;         /**&lt; string so far */
    unsigned len;      /**&lt; length so far */
    unsigned size;     /**&lt; allocated memory */
    unsigned size_max; /**&lt; maximum allocated memory */
    char reserved_internal_buffer[1];
    )
} AVBPrint;</pre>
    <br/>
    AVBPrint的注释代码很长，不再详细叙述。在这里只要知道他是用于打印字符串的缓存就可以了。它的名称BPrint的意思应该就是“Buffer to Print”。其中的str存储了将要打印的字符串。
    <br/>
    format_line()函数的定义如下所示。
    <br/>
    <pre class="cpp">static void format_line(void *avcl, int level, const char *fmt, va_list vl,
                        AVBPrint part[4], int *print_prefix, int type[2])
{
    AVClass* avc = avcl ? *(AVClass **) avcl : NULL;
    av_bprint_init(part+0, 0, 1);
    av_bprint_init(part+1, 0, 1);
    av_bprint_init(part+2, 0, 1);
    av_bprint_init(part+3, 0, 65536);

    if(type) type[0] = type[1] = AV_CLASS_CATEGORY_NA + 16;
    if (*print_prefix &amp;&amp; avc) {
        if (avc-&gt;parent_log_context_offset) {
            AVClass** parent = *(AVClass ***) (((uint8_t *) avcl) +
                                   avc-&gt;parent_log_context_offset);
            if (parent &amp;&amp; *parent) {
                av_bprintf(part+0, "[%s @ %p] ",
                         (*parent)-&gt;item_name(parent), parent);
                if(type) type[0] = get_category(parent);
            }
        }
        av_bprintf(part+1, "[%s @ %p] ",
                 avc-&gt;item_name(avcl), avcl);
        if(type) type[1] = get_category(avcl);

        if (flags &amp; AV_LOG_PRINT_LEVEL)
            av_bprintf(part+2, "[%s] ", get_level_str(level));
    }

    av_vbprintf(part+3, fmt, vl);

    if(*part[0].str || *part[1].str || *part[2].str || *part[3].str) {
        char lastc = part[3].len &amp;&amp; part[3].len &lt;= part[3].size ? part[3].str[part[3].len - 1] : 0;
        *print_prefix = lastc == '\n' || lastc == '\r';
    }
}
</pre>
    <br/>
    从代码中可以看出，其分别处理了AVBPrint类型数组part的4个元素。由此我们也可以看出FFmpeg一条Log可以分成4个组成部分。在这里涉及到几个与AVBPrint相关的函数，由于篇幅的关系，不再分析它们的源代码，仅仅列出它们的定义：
    <br/>
    初始化AVBPrint的函数av_bprint_init()。
    <br/>
    <pre class="cpp">/**
 * Init a print buffer.
 *
 * @param buf        buffer to init
 * @param size_init  initial size (including the final 0)
 * @param size_max   maximum size;
 *                   0 means do not write anything, just count the length;
 *                   1 is replaced by the maximum value for automatic storage;
 *                   any large value means that the internal buffer will be
 *                   reallocated as needed up to that limit; -1 is converted to
 *                   UINT_MAX, the largest limit possible.
 *                   Check also AV_BPRINT_SIZE_* macros.
 */
void av_bprint_init(AVBPrint *buf, unsigned size_init, unsigned size_max);</pre>
    <br/>
    向AVBPrint添加一个字符串的函数av_bprintf()。
    <br/>
    <pre class="cpp">/**
 * Append a formatted string to a print buffer.
 */
void av_bprintf(AVBPrint *buf, const char *fmt, ...) av_printf_format(2, 3);</pre>
    <br/>
    向AVBPrint添加一个字符串的函数av_vbprintf ()，注意与av_bprintf()的不同在于其第3个参数不一样。
    <br/>
    <pre class="cpp">/**
 * Append a formatted string to a print buffer.
 */
void av_vbprintf(AVBPrint *buf, const char *fmt, va_list vl_arg);</pre>
    我们可以瞄一眼av_bprintf()的定义，位于libavutil\bprint.c，如下所示。
    <br/>
    <p>
    </p>
    <pre class="cpp">void av_bprintf(AVBPrint *buf, const char *fmt, ...)
{
    unsigned room;
    char *dst;
    va_list vl;
    int extra_len;

    while (1) {
        room = av_bprint_room(buf);
        dst = room ? buf-&gt;str + buf-&gt;len : NULL;
        va_start(vl, fmt);
        extra_len = vsnprintf(dst, room, fmt, vl);
        va_end(vl);
        if (extra_len &lt;= 0)
            return;
        if (extra_len &lt; room)
            break;
        if (av_bprint_alloc(buf, extra_len))
            break;
    }
    av_bprint_grow(buf, extra_len);
}</pre>
    <br/>
    可以看出av_bprintf()实际上调用了系统的vsnprintf()完成了相应的功能。
    <p>
    </p>
    <p>
     看完以上几个与AVBPrint相关函数之后，就可以来看一下format_line()的代码了。例如，part[0]对应的是目标结构体的父结构体的名称（如果父结构体存在的话）；其打印格式形如“[%s @ %p]”，其中前面的“%s”对应父结构体的名称，“%p”对应其所在的地址。part[1]对应的是目标结构体的名称；其打印格式形如“[%s @ %p]”，其中前面的“%s”对应本结构体的名称，“%p”对应其所在的地址。part[2]用于输出Log的级别，这个字符串只有在flag中设置AV_LOG_PRINT_LEVEL的时候才能打印。part[3]则是打印原本传送进来的文本。将format_line()函数处理后得到的4个字符串连接其来，就可以的到一条完整的Log信息。下面图显示了flag设置AV_LOG_PRINT_LEVEL后的打印出来的Log的格式。
    </p>
    <div style="text-align:center;">
     <img alt="" src="https://img-blog.csdn.net/20150313172016466?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
    </div>
    默认情况下不设置flag打印出来的格式如下所示。
    <br/>
    <div style="text-align:center;">
     <img alt="" src="https://img-blog.csdn.net/20150313172203357?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
    </div>
    <div style="text-align:left;">
     <br/>
    </div>
    <h3>
     colored_fputs()
    </h3>
    <p>
     colored_fputs()函数用于将输出的文本“上色”并且输出。在这里有一点需要注意：Windows和Linux下控制台程序上色的方法是不一样的。Windows下是通过SetConsoleTextAttribute()方法给控制台中的文本上色；Linux下则是通过添加一些ANSI控制码完成上色。
    </p>
    <h4>
     Linux下控制台文字上色的方法
    </h4>
    <p>
     Linux下控制台颜色是通过添加专用数字来选择的。这些数字夹在 "\e["和 "m"之间。如果指定一个以上的数字，则用分号将它们分开。
    </p>
    <p>
     举几个例子：
    </p>
    <p>
     （1）第一个数字(31)为前景颜色(红色)；第二个数字为(42)背景颜色(绿色)
     <br/>
    </p>
    <pre class="plain">echo -e "\e[31;42m"</pre>
    （2）使用"\e[0m"序列将颜色重新设置为正常值
    <br/>
    <pre class="plain">echo -e "\e[0m" 或 echo -e "\033[0m"</pre>
    （3）颜色对应关系如下所示：
    <br/>
    \e[30m -- \e[37m    设置前景色(字体颜色)
    <br/>
    echo -e "\e[30m"    灰色
    <br/>
    echo -e "\e[31m"    红色
    <br/>
    echo -e "\e[32m"    绿色
    <br/>
    echo -e "\e[33m"    黄色
    <br/>
    echo -e "\e[34m"    蓝色
    <br/>
    echo -e "\e[35m"    紫色
    <br/>
    echo -e "\e[36m"    淡蓝色
    <br/>
    echo -e "\e[37m"    白色
    <br/>
    <br/>
    \e[40m -- \e[47m    设置背景色
    <br/>
    echo -e "\e[40m"    灰色
    <br/>
    echo -e "\e[41m"    红色
    <br/>
    echo -e "\e[42m"    绿色
    <br/>
    echo -e "\e[43m"    黄色
    <br/>
    echo -e "\e[44m"    蓝色
    <br/>
    echo -e "\e[45m"    紫色
    <br/>
    echo -e "\e[46m"    淡蓝色
    <br/>
    echo -e "\e[47m"    白色
    <br/>
    <br/>
    具体到编程中，printf() 颜色设置示例代码如下所示。
    <br/>
    <pre class="cpp">int main()
{
printf("\e[31m Hello World. \e[0m \n"); // 红色字体
return 0;
}</pre>
    <br/>
    <h4>
     Windows下控制台文字上色的方法
    </h4>
    Windows下控制台颜色是通过SetConsoleTextAttribute()函数完成的。SetConsoleTextAttribute()函数的原型如下所示。
    <br/>
    <pre class="cpp">BOOL SetConsoleTextAttribute(HANDLE hConsoleOutput, WORD wAttributes);</pre>
    其中2个参数的含义如下所示：
    <br/>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
     hConsoleOutput：指向控制台的句柄。
     <br/>
     wAttributes：文本属性。
    </blockquote>
    <br/>
    hConsoleOutput可以选择以下3种句柄：
    <br/>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
     STD_INPUT_HANDLE：
     <span style="white-space:pre;">
     </span>
     标准输入的句柄
     <br/>
     STD_OUTPUT_HANDLE：
     <span style="white-space:pre;">
     </span>
     标准输出的句柄
     <br/>
     STD_ERROR_HANDLE：
     <span style="white-space:pre;">
     </span>
     标准错误的句柄
    </blockquote>
    wAttributes可以控制前景色和背景色：
    <br/>
    <blockquote style="margin:0 0 0 40px;border:none;padding:0px;">
     FOREGROUND_BLUE：
     <span style="white-space:pre;">
     </span>
     字体颜色：蓝
     <br/>
     FOREGROUND_GREEN：
     <span style="white-space:pre;">
     </span>
     字体颜色：绿
     <br/>
     FOREGROUND_RED：
     <span style="white-space:pre;">
     </span>
     字体颜色：红
     <br/>
     FOREGROUND_INTENSITY：
     <span style="white-space:pre;">
     </span>
     前景色高亮显示
     <br/>
     BACKGROUND_BLUE：
     <span style="white-space:pre;">
     </span>
     背景颜色：蓝
     <br/>
     BACKGROUND_GREEN：
     <span style="white-space:pre;">
     </span>
     背景颜色：绿
     <br/>
     BACKGROUND_RED：
     <span style="white-space:pre;">
     </span>
     背景颜色：红
     <br/>
     BACKGROUND_INTENSITY
     <span style="white-space:pre;">
     </span>
     背景色高亮显示
    </blockquote>
    控制台文本上色demo代码如下所示。
    <br/>
    <pre class="cpp">/**
 * 雷霄骅 Lei Xiaohua
 * leixiaohua1020@126.com
 * http://blog.csdn.net/leixiaohua1020
 */
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;


int main()
{
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED);
	printf("red\n");
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_GREEN);
	printf("green\n");
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_BLUE);
	printf("blue\n");
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED|FOREGROUND_GREEN);
	printf("red+green=yellow\n");
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED|FOREGROUND_BLUE);
	printf("red+blue=purple\n");
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_GREEN|FOREGROUND_BLUE);
	printf("green+blue=cyan\n");
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_RED|BACKGROUND_GREEN);
	printf("Add background\n");


	return 0;
}</pre>
    <br/>
    程序的运行结果如下图所示。
    <br/>
    <div style="text-align:center;">
     <img alt="" src="https://img-blog.csdn.net/20150313172902779?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/>
    </div>
    <br/>
    <h3>
     colored_fputs()源代码
    </h3>
    <p>
     下面看一下colored_fputs()函数的源代码。
    </p>
    <pre class="cpp">static void colored_fputs(int level, int tint, const char *str)
{
    int local_use_color;
    if (!*str)
        return;

    if (use_color &lt; 0)
        check_color_terminal();

    if (level == AV_LOG_INFO/8) local_use_color = 0;
    else                        local_use_color = use_color;

#if defined(_WIN32) &amp;&amp; !defined(__MINGW32CE__) &amp;&amp; HAVE_SETCONSOLETEXTATTRIBUTE
    if (local_use_color)
        SetConsoleTextAttribute(con, background | color[level]);
    fputs(str, stderr);
    if (local_use_color)
        SetConsoleTextAttribute(con, attr_orig);
#else
    if (local_use_color == 1) {
        fprintf(stderr,
                "\033[%d;3%dm%s\033[0m",
                (color[level] &gt;&gt; 4) &amp; 15,
                color[level] &amp; 15,
                str);
    } else if (tint &amp;&amp; use_color == 256) {
        fprintf(stderr,
                "\033[48;5;%dm\033[38;5;%dm%s\033[0m",
                (color[level] &gt;&gt; 16) &amp; 0xff,
                tint,
                str);
    } else if (local_use_color == 256) {
        fprintf(stderr,
                "\033[48;5;%dm\033[38;5;%dm%s\033[0m",
                (color[level] &gt;&gt; 16) &amp; 0xff,
                (color[level] &gt;&gt; 8) &amp; 0xff,
                str);
    } else
        fputs(str, stderr);
#endif

}
</pre>
    <br/>
    从colored_fputs()的源代码中可以看出如下流程：
    <br/>
    首先判定根据宏定义系统的类型，如果系统类型是Windows，那么就调用SetConsoleTextAttribute()方法设定控制台文本的颜色，然后调用fputs()将Log记录输出到stderr（注意不是stdout）；如果系统类型是Linux，则通过添加特定字符串的方式设定控制台文本的颜色，然后将Log记录输出到stderr。
    <br/>
    至此FFmpeg的日志输出系统的源代码就分析完毕了。
    <br/>
    <br/>
    <p>
     <br/>
    </p>
    <p>
     <strong>
      <span style="color:#990000;">
       雷霄骅
       <br/>
       leixiaohua1020@126.com
       <br/>
       http://blog.csdn.net/leixiaohua1020
      </span>
     </strong>
     <br/>
    </p>
    <p>
     <br/>
    </p>
   </div>
  </div>
  <div style="display:none;" class="hide-article-box text-center csdn-tracking-statistics tracking-click" data-mod="popu_376">
   <a class="btn btn-red-hollow" id="btn-readmore">
    阅读更多
   </a>
  </div>
 </article>
 <div class="article-bar-bottom">
  <div class="article-copyright">
   版权声明：本文为博主原创文章，未经博主允许不得转载。			https://blog.csdn.net/leixiaohua1020/article/details/44243155
  </div>
  <div class="tags-box artic-tag-box">
   <span class="label">
    文章标签：
   </span>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=FFmpeg&amp;t=blog" target="_blank">
    FFmpeg
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=源代码&amp;t=blog" target="_blank">
    源代码
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=日志&amp;t=blog" target="_blank">
    日志
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=log&amp;t=blog" target="_blank">
    log
   </a>
   <a class="tag-link" href="http://so.csdn.net/so/search/s.do?q=av_log&amp;t=blog" target="_blank">
    av_log
   </a>
  </div>
  <div class="tags-box">
   <span class="label">
    个人分类：
   </span>
   <a class="tag-link" href="https://blog.csdn.net/leixiaohua1020/article/category/1360795" target="_blank">
    FFMPEG
   </a>
  </div>
  <div class="tags-box">
   <span class="label">
    所属专栏：
   </span>
   <a class="tag-link" href="https://blog.csdn.net/column/details/ffmpeg-devel.html" target="_blank">
    FFmpeg
   </a>
  </div>
 </div>
 <!-- !empty($pre_next_article[0]) -->
</div>
<div class="recommend-box">
                            <div style="background: #fff; border: dashed 1px #666; padding-left: 1em; padding-top: 1em; padding-bottom: 1em;">
                                <span style="font-size: 0.8em; font-weight: bold;">
                                    此PDF由<a style="color:#0000ff" href="http://www.github.com/spygg"  target="_blank">spygg</a>生成,请尊重原作者版权!!!
                                    <br/>
                                    我的邮箱:liushidc@163.com
                                </span>
                                </div> 
                        </div>
                    </main>
      
                </div>

            <script>
                var recommendCount = 0;
                var articleTit = "";
                var articleId = "";
                var commentscount = 0;

                //1禁止评论，2正常
                var commentAuth = 1;
                //百度搜索
                var baiduKey = "";
                var needInsertBaidu = "";
            </script>
            <script src="https://csdnimg.cn/release/phoenix/template/js/detail-effe72036e.min.js"></script>
            </body>
        </html>